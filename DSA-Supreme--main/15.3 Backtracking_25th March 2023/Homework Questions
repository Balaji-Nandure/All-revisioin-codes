/*
--------------------------------------------------------------------------------
1) Generate Parentheses (Backtracking)
--------------------------------------------------------------------------------
Approach:
- Use backtracking to generate all valid combinations of n pairs of parentheses.
- At each step, you can add an open '(' if you still have open brackets left.
- You can add a close ')' only if the number of close brackets left is more than open (to ensure validity).
- When both open and close reach 0, we have a valid combination.

Better/Alternative Approaches:
- The backtracking approach is optimal for this problem.
- You can also use dynamic programming to build up solutions for n from solutions for n-1, but backtracking is more intuitive and direct.

Code with detailed comments:
*/
#include <iostream>
#include <vector>
using namespace std;

// Helper function to generate all valid parentheses combinations
void generateParenthesisHelper(int n, int open, int close, string output, vector<string>& result) {
    // Base case: if no open or close brackets left, add the current combination to result
    if(open == 0 && close == 0) {
        result.push_back(output);
        return;
    }
    // If we have open brackets left, add '(' and recurse
    if(open > 0) {
        generateParenthesisHelper(n, open-1, close, output + '(', result);
    }
    // If we have more close than open, we can add ')'
    if(close > open) {
        generateParenthesisHelper(n, open, close-1, output + ')', result);
    }
}

// Main function to generate parentheses
vector<string> generateParenthesis(int n) {
    vector<string> result;
    generateParenthesisHelper(n, n, n, "", result);
    return result;
}

/*
Dry Run for Generate Parentheses (n = 3):

Call: generateParenthesis(3)
- output: ""
- open: 3, close: 3

Step 1: Add '(' -> output: "(", open: 2, close: 3
Step 2: Add '(' -> output: "((", open: 1, close: 3
Step 3: Add '(' -> output: "(((", open: 0, close: 3
Step 4: Add ')' -> output: "((()", open: 0, close: 2
Step 5: Add ')' -> output: "((())", open: 0, close: 1
Step 6: Add ')' -> output: "((()))", open: 0, close: 0 (Add to result)

... (other branches explored similarly)

Final result for n=3: ["((()))","(()())","(())()","()(())","()()()"]

Test Cases:
n=1: ["()"]
n=2: ["(())","()()"]
n=3: ["((()))","(()())","(())()","()(())","()()()"]
n=4: ["(((())))","((()()))","((())())","((()))()","(()(()))","(()()())","(()())()","(())(())","(())()()","()((()))","()(()())","()(())()","()()(())","()()()()"]
n=0: [""]

--------------------------------------------------------------------------------
2) Letter Combinations of a Phone Number (Backtracking)
--------------------------------------------------------------------------------
Approach:
- Use backtracking to generate all possible letter combinations for a given digit string based on the mapping of digits to letters (like on a phone keypad).
- For each digit, try all possible letters and recurse for the next digit.

Better/Alternative Approaches:
- Iterative approach using a queue to build combinations level by level.
- Backtracking is the most common and intuitive for this problem.

Code with detailed comments:
*/
#include <string>
#include <map>

// Helper function for backtracking
void letterCombinationsHelper(const string& digits, int index, string current, vector<string>& result, const vector<string>& mapping) {
    // Base case: if we've processed all digits, add the current combination
    if(index == digits.size()) {
        if(!current.empty())
            result.push_back(current);
        return;
    }
    // Get the possible letters for the current digit
    int digit = digits[index] - '0';
    for(char c : mapping[digit]) {
        letterCombinationsHelper(digits, index+1, current + c, result, mapping);
    }
}

// Main function to get all letter combinations
vector<string> letterCombinations(string digits) {
    vector<string> result;
    if(digits.empty()) return result;
    // Mapping from digit to corresponding letters
    vector<string> mapping = {"",    "",    "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    letterCombinationsHelper(digits, 0, "", result, mapping);
    return result;
}

/*
Dry Run for Letter Combinations (digits = "23"):

mapping[2] = "abc"
mapping[3] = "def"

Step 1: index=0, digit='2', try 'a'
    Step 2: index=1, digit='3', try 'd' -> "ad"
    Step 2: index=1, digit='3', try 'e' -> "ae"
    Step 2: index=1, digit='3', try 'f' -> "af"
Step 1: index=0, digit='2', try 'b'
    Step 2: index=1, digit='3', try 'd' -> "bd"
    Step 2: index=1, digit='3', try 'e' -> "be"
    Step 2: index=1, digit='3', try 'f' -> "bf"
Step 1: index=0, digit='2', try 'c'
    Step 2: index=1, digit='3', try 'd' -> "cd"
    Step 2: index=1, digit='3', try 'e' -> "ce"
    Step 2: index=1, digit='3', try 'f' -> "cf"

Result: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

Test Cases:
digits="2": ["a","b","c"]
digits="23": ["ad","ae","af","bd","be","bf","cd","ce","cf"]
digits="": []
digits="7": ["p","q","r","s"]
digits="79": ["pw","px","py","pz","qw","qx","qy","qz","rw","rx","ry","rz","sw","sx","sy","sz"]

--------------------------------------------------------------------------------
3) Number of Squareful Arrays (Backtracking + Permutations)
--------------------------------------------------------------------------------
Approach:
- Generate all permutations of the array.
- For each permutation, check if every pair of adjacent elements sums to a perfect square.
- Use backtracking to generate permutations and a set to avoid duplicates.

Better/Alternative Approaches:
- Use next_permutation and check each permutation (less efficient).
- Use backtracking with pruning and memoization for large inputs.

Code with detailed comments:
*/
#include <algorithm>
#include <set>
#include <cmath>

// Helper function to check if a number is a perfect square
bool isPerfectSquare(int x) {
    int s = sqrt(x);
    return s * s == x;
}

// Helper function for backtracking
void squarefulHelper(vector<int>& nums, int index, int& count) {
    if(index == nums.size()) {
        count++;
        return;
    }
    set<int> used; // To avoid duplicate permutations at this position
    for(int i = index; i < nums.size(); ++i) {
        if(used.count(nums[i])) continue;
        if(index == 0 || isPerfectSquare(nums[index-1] + nums[i])) {
            used.insert(nums[i]);
            swap(nums[index], nums[i]);
            squarefulHelper(nums, index+1, count);
            swap(nums[index], nums[i]);
        }
    }
}

// Main function to count squareful arrays
int numSquarefulPerms(vector<int>& nums) {
    int count = 0;
    squarefulHelper(nums, 0, count);
    return count;
}

/*
Dry Run for nums = [1,17,8]:
Permutations: [1,8,17], [1,17,8], [8,1,17], [8,17,1], [17,1,8], [17,8,1]
Check each for adjacent pairs summing to perfect square.
Result: 2

Test Cases:
[1,17,8] -> 2
[2,2,2] -> 1
[1,1,8,1] -> 0
[9,0,9] -> 2
[16,9,7] -> 0

--------------------------------------------------------------------------------
4) Word Break I (Backtracking)
--------------------------------------------------------------------------------
Approach:
- Try to break the string into words from the dictionary using recursion.
- At each step, check all prefixes; if a prefix is in the dictionary, recursively check the rest of the string.

Better/Alternative Approaches:
- Use dynamic programming (DP) for optimal solution (O(n^2) time).
- Backtracking is simple but can be slow for large inputs.

Code with detailed comments:
*/
#include <unordered_set>

// Helper function for backtracking
bool wordBreakHelper(string s, unordered_set<string>& dict) {
    if(s.empty()) return true;
    for(int i = 1; i <= s.size(); ++i) {
        string prefix = s.substr(0, i);
        if(dict.count(prefix) && wordBreakHelper(s.substr(i), dict)) {
            return true;
        }
    }
    return false;
}

// Main function
bool wordBreak(string s, vector<string>& wordDict) {
    unordered_set<string> dict(wordDict.begin(), wordDict.end());
    return wordBreakHelper(s, dict);
}

/*
Dry Run for s = "leetcode", wordDict = ["leet","code"]:
- Try prefix "l", not in dict
- Try "le", not in dict
- Try "lee", not in dict
- Try "leet", in dict, check "code"
- "code" in dict, return true

Test Cases:
"leetcode", ["leet","code"] -> true
"applepenapple", ["apple","pen"] -> true
"catsandog", ["cats","dog","sand","and","cat"] -> false
"aaaaaaa", ["aaaa","aaa"] -> true
"cars", ["car","ca","rs"] -> true

--------------------------------------------------------------------------------
5) Letter Tile Possibilities (Backtracking + Set)
--------------------------------------------------------------------------------
Approach:
- Use backtracking to generate all possible sequences from the given tiles.
- At each step, try each unused tile and recurse.
- Use a set to avoid duplicate sequences.

Better/Alternative Approaches:
- Use a frequency array to avoid using the same tile more than available.

Code with detailed comments:
*/
#include <unordered_map>

// Helper function for backtracking
void tileHelper(unordered_map<char,int>& freq, int& count) {
    for(auto& p : freq) {
        if(p.second == 0) continue;
        count++;
        p.second--;
        tileHelper(freq, count);
        p.second++;
    }
}

// Main function
int numTilePossibilities(string tiles) {
    unordered_map<char,int> freq;
    for(char c : tiles) freq[c]++;
    int count = 0;
    tileHelper(freq, count);
    return count;
}

/*
Dry Run for tiles = "AAB":
- Use 'A': "A", then "AA", "AB"
- Use 'B': "B", then "BA"
Total: 8

Test Cases:
"A" -> 1
"AB" -> 4
"AAB" -> 8
"AAABBC" -> 188
"XYZ" -> 15

--------------------------------------------------------------------------------
6) Sum of All Subset XOR Totals (Backtracking)
--------------------------------------------------------------------------------
Approach:
- Use backtracking to generate all subsets and calculate their XOR.
- For each element, either include it in the current subset or not.

Better/Alternative Approaches:
- Use bitmasking to generate all subsets (2^n).

Code with detailed comments:
*/
void subsetXORHelper(vector<int>& nums, int index, int currXOR, int& total) {
    if(index == nums.size()) {
        total += currXOR;
        return;
    }
    // Include nums[index]
    subsetXORHelper(nums, index+1, currXOR ^ nums[index], total);
    // Exclude nums[index]
    subsetXORHelper(nums, index+1, currXOR, total);
}

int subsetXORSum(vector<int>& nums) {
    int total = 0;
    subsetXORHelper(nums, 0, 0, total);
    return total;
}

/*
Dry Run for nums = [1,3]:
Subsets: [], [1], [3], [1,3]
XORs:   0,   1,   3,    2
Sum: 0+1+3+2 = 6

Test Cases:
[1,3] -> 6
[5,1,6] -> 28
[0] -> 0
[2,2,2] -> 8
[1,2,3,4] -> 28

--------------------------------------------------------------------------------
Summary:
- All problems above use backtracking as the main approach.
- For each, better alternatives (DP, bitmasking, etc.) are mentioned where applicable.
- Each code block is commented for clarity.
- Dry runs and test cases are provided for understanding.
*/
