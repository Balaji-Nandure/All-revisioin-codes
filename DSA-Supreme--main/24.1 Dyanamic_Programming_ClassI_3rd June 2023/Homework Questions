/*
Approach:
We will solve the Fibonacci Series problem using three approaches:
1. Top-Down (Recursion + Memoization)
2. Bottom-Up (Tabulation)
3. Space Optimization

Fibonacci Series: F(n) = F(n-1) + F(n-2), with F(0)=0, F(1)=1

Below are the implementations with detailed comments and a dry run at the end.
*/

// 1. Top-Down Approach (Recursion + Memoization)
#include <iostream>
#include <vector>
using namespace std;

// Function to calculate nth Fibonacci number using memoization
int fibTopDown(int n, vector<int>& dp) {
    // Base cases
    if (n == 0) return 0; // F(0) = 0
    if (n == 1) return 1; // F(1) = 1

    // If already computed, return the stored value
    if (dp[n] != -1) return dp[n];

    // Recursive calculation with memoization
    dp[n] = fibTopDown(n-1, dp) + fibTopDown(n-2, dp); // Store result for future use
    return dp[n];
}

/*
Alternative: Pure Recursion (Not recommended for large n due to exponential time complexity)
int fibRec(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    return fibRec(n-1) + fibRec(n-2);
}
*/

// 2. Bottom-Up Approach (Tabulation)
int fibBottomUp(int n) {
    // Create a dp array to store Fibonacci numbers up to n
    vector<int> dp(n+1, 0);
    dp[0] = 0; // F(0)
    if (n > 0) dp[1] = 1; // F(1)

    // Build the dp array from 2 to n
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i-1] + dp[i-2]; // Current Fibonacci is sum of previous two
    }
    return dp[n];
}

// 3. Space Optimized Approach
int fibSpaceOptimized(int n) {
    if (n == 0) return 0; // Base case
    if (n == 1) return 1; // Base case

    int prev2 = 0; // F(0)
    int prev1 = 1; // F(1)
    int curr = 0;

    // Only keep last two computed values
    for (int i = 2; i <= n; ++i) {
        curr = prev1 + prev2; // Current Fibonacci
        prev2 = prev1;        // Update prev2 to previous prev1
        prev1 = curr;         // Update prev1 to current
    }
    return curr;
}

/*
Better Alternatives:
- For very large n, use matrix exponentiation (O(log n) time, O(1) space).
- For constant time, use Binet's formula (not recommended due to floating point errors for large n).
*/

// Example usage and dry run
int main() {
    int n = 5; // Change n for different Fibonacci numbers

    // Top-Down
    vector<int> dp(n+1, -1); // Initialize dp array with -1
    cout << "Top-Down (Memoization) F(" << n << "): " << fibTopDown(n, dp) << endl;

    // Bottom-Up
    cout << "Bottom-Up (Tabulation) F(" << n << "): " << fibBottomUp(n) << endl;

    // Space Optimized
    cout << "Space Optimized F(" << n << "): " << fibSpaceOptimized(n) << endl;

    return 0;
}

/*
Dry Run for n = 5:

Top-Down:
fibTopDown(5)
-> fibTopDown(4) + fibTopDown(3)
-> (fibTopDown(3) + fibTopDown(2)) + (fibTopDown(2) + fibTopDown(1))
-> ((fibTopDown(2) + fibTopDown(1)) + (fibTopDown(1) + fibTopDown(0))) + ((fibTopDown(1) + fibTopDown(0)) + 1)
-> ((fibTopDown(1) + fibTopDown(0)) + 1) + (1 + 0) + (1 + 0) + 1
-> (1 + 0 + 1) + (1 + 0) + (1 + 0) + 1
-> 2 + 1 + 1 + 1 = 5

Bottom-Up:
dp[0]=0, dp[1]=1
i=2: dp[2]=dp[1]+dp[0]=1+0=1
i=3: dp[3]=dp[2]+dp[1]=1+1=2
i=4: dp[4]=dp[3]+dp[2]=2+1=3
i=5: dp[5]=dp[4]+dp[3]=3+2=5

Space Optimized:
prev2=0, prev1=1
i=2: curr=1, prev2=1, prev1=1
i=3: curr=2, prev2=1, prev1=2
i=4: curr=3, prev2=2, prev1=3
i=5: curr=5, prev2=3, prev1=5

All approaches output F(5) = 5
*/
