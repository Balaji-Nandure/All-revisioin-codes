## **Question: Bubble sort**

**Approach:**
Question: Implement Bubble Sort

Approach:

1. Traverse the array multiple times.
2. In each pass, compare adjacent elements:
   a. If arr[i] > arr[i+1], swap them.
3. After each pass, the largest element "bubbles" to the end.
4. Optimize by stopping early if no swaps occur in a pass.
   Time Complexity: O(n^2) worst/average, O(n) best (optimized)
   Space Complexity: O(1) in-place

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to perform bubble sort
void bubbleSort(vector<int>& arr){
    int n = arr.size();
    for(int i = 0; i < n-1; i++){            // Number of passes
        bool swapped = false;                 // Track if any swap happens in this pass
        for(int j = 0; j < n-i-1; j++){      // Compare adjacent elements
            if(arr[j] > arr[j+1]){           // Swap if out of order
                swap(arr[j], arr[j+1]);
                swapped = true;
            }
        }
        if(!swapped) break;                   // If no swaps, array is sorted
    }
}

// Main function to test bubble sort
int main(){
    vector<int> arr = {64, 34, 25, 12, 22, 11, 90};

    cout << "Original Array: ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    bubbleSort(arr);

    cout << "Sorted Array:   ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {64, 34, 25, 12, 22, 11, 90}

Pass 1:
64>34 → swap → {34,64,25,12,22,11,90}
64>25 → swap → {34,25,64,12,22,11,90}
64>12 → swap → {34,25,12,64,22,11,90}
64>22 → swap → {34,25,12,22,64,11,90}
64>11 → swap → {34,25,12,22,11,64,90}
64>90 → no swap

Pass 2:
34>25 → swap → {25,34,12,22,11,64,90}
34>12 → swap → {25,12,34,22,11,64,90}
34>22 → swap → {25,12,22,34,11,64,90}
34>11 → swap → {25,12,22,11,34,64,90}
34>64 → no swap

...
Continue until array is sorted

Final Array: {11,12,22,25,34,64,90}

```

---

## **Question: optimised bubble sort**

**Approach:**
Question: Implement Optimized Bubble Sort

Approach:

1. Traverse the array multiple times.
2. In each pass, compare adjacent elements:
   a. If arr[i] > arr[i+1], swap them.
3. Track whether any swap happened in the current pass.
4. If no swaps occurred in a pass, the array is already sorted → stop early.
   Time Complexity: O(n^2) worst/average, O(n) best (already sorted)
   Space Complexity: O(1) in-place

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to perform optimized bubble sort
void optimizedBubbleSort(vector<int>& arr){
    int n = arr.size();
    for(int i = 0; i < n-1; i++){          // Total passes
        bool swapped = false;               // Flag to detect if any swap occurs
        for(int j = 0; j < n-i-1; j++){    // Compare adjacent elements
            if(arr[j] > arr[j+1]){
                swap(arr[j], arr[j+1]);    // Swap if elements are out of order
                swapped = true;            // Mark that a swap happened
            }
        }
        if(!swapped) break;                 // No swaps → array already sorted → break early
    }
}

// Main function to test optimized bubble sort
int main(){
    vector<int> arr = {11, 12, 22, 25, 34, 64, 90}; // Already partially sorted

    cout << "Original Array: ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    optimizedBubbleSort(arr);

    cout << "Sorted Array:   ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {11, 12, 22, 25, 34, 64, 90}

Pass 1:
Compare 11>12? no swap
Compare 12>22? no swap
Compare 22>25? no swap
Compare 25>34? no swap
Compare 34>64? no swap
Compare 64>90? no swap
No swaps → break early → array is sorted

Final Array: {11,12,22,25,34,64,90}

```

---

## **Question: Selection Sort**

**Approach:**
Question: Implement Selection Sort

Approach:

1. Traverse the array and find the minimum element in the unsorted part.
2. Swap it with the first element of the unsorted part.
3. Repeat for all positions until the array is sorted.
   Time Complexity: O(n^2) worst/average/best
   Space Complexity: O(1) in-place
   Notes:

- Unstable sorting algorithm (equal elements may change relative order)
- Useful for small arrays or learning purpose

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to perform selection sort
void selectionSort(vector<int>& arr){
    int n = arr.size();
    for(int i = 0; i < n-1; i++){          // Traverse each position
        int minIndex = i;                  // Assume first element of unsorted part is minimum
        for(int j = i+1; j < n; j++){      // Search for the minimum in unsorted part
            if(arr[j] < arr[minIndex]){
                minIndex = j;              // Update index of minimum
            }
        }
        if(minIndex != i) swap(arr[i], arr[minIndex]); // Swap with first element of unsorted part
    }
}

// Main function to test selection sort
int main(){
    vector<int> arr = {64, 25, 12, 22, 11};

    cout << "Original Array: ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    selectionSort(arr);

    cout << "Sorted Array:   ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {64, 25, 12, 22, 11}

Pass 1: i=0
Find min in {64,25,12,22,11} → 11
Swap 64 and 11 → {11,25,12,22,64}

Pass 2: i=1
Find min in {25,12,22,64} → 12
Swap 25 and 12 → {11,12,25,22,64}

Pass 3: i=2
Find min in {25,22,64} → 22
Swap 25 and 22 → {11,12,22,25,64}

Pass 4: i=3
Find min in {25,64} → 25
Swap 25 and 25 → no change

Final Array: {11,12,22,25,64}

```

---

## **Question: Insertion Sort**

**Approach:**
Question: Implement Insertion Sort

Approach:

1. Treat the first element as sorted.
2. Pick the next element and insert it into the sorted part at the correct position.
3. Shift elements in the sorted part to make space.
4. Repeat for all elements.
   Time Complexity: O(n^2) worst/average, O(n) best (already sorted)
   Space Complexity: O(1) in-place
   Notes:

- Stable sorting algorithm (equal elements retain relative order)
- Efficient for small arrays or nearly sorted arrays

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to perform insertion sort
void insertionSort(vector<int>& arr){
    int n = arr.size();
    for(int i = 1; i < n; i++){             // Pick element from unsorted part
        int key = arr[i];                   // Element to insert
        int j = i - 1;

        // Shift elements in sorted part greater than key to the right
        while(j >= 0 && arr[j] > key){
            arr[j+1] = arr[j];
            j--;
        }

        arr[j+1] = key;                     // Insert key at correct position
    }
}

// Main function to test insertion sort
int main(){
    vector<int> arr = {12, 11, 13, 5, 6};

    cout << "Original Array: ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    insertionSort(arr);

    cout << "Sorted Array:   ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {12, 11, 13, 5, 6}

Pass 1: i=1, key=11
Compare 12>11 → shift 12 → place 11 → {11,12,13,5,6}

Pass 2: i=2, key=13
Compare 12>13? no → place 13 → {11,12,13,5,6}

Pass 3: i=3, key=5
Shift 13,12,11 → place 5 → {5,11,12,13,6}

Pass 4: i=4, key=6
Shift 13,12,11 → place 6 → {5,6,11,12,13}

Final Array: {5,6,11,12,13}

```

---

## **Question: Merge Sort**

**Approach:**
Question: Implement Merge Sort

Approach:

1. Divide & Conquer approach.
2. Steps:
   a. Divide the array into two halves.
   b. Recursively sort each half.
   c. Merge the two sorted halves.
3. Merging: Compare elements from both halves and place in sorted order.
   Time Complexity: O(n log n) for all cases
   Space Complexity: O(n) extra space for merging
   Notes:

- Stable sorting algorithm
- Suitable for large arrays and linked lists

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to merge two sorted halves
void merge(vector<int>& arr, int left, int mid, int right){
    int n1 = mid - left + 1;
    int n2 = right - mid;

    vector<int> L(n1), R(n2);

    // Copy data to temp arrays
    for(int i=0;i<n1;i++) L[i] = arr[left+i];
    for(int i=0;i<n2;i++) R[i] = arr[mid+1+i];

    int i=0, j=0, k=left;

    // Merge L and R into arr
    while(i<n1 && j<n2){
        if(L[i] <= R[j]){
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy remaining elements of L, if any
    while(i<n1){
        arr[k] = L[i];
        i++; k++;
    }

    // Copy remaining elements of R, if any
    while(j<n2){
        arr[k] = R[j];
        j++; k++;
    }
}

// Recursive Merge Sort function
void mergeSort(vector<int>& arr, int left, int right){
    if(left < right){
        int mid = left + (right-left)/2;
        mergeSort(arr, left, mid);        // Sort left half
        mergeSort(arr, mid+1, right);     // Sort right half
        merge(arr, left, mid, right);     // Merge sorted halves
    }
}

int main(){
    vector<int> arr = {12, 11, 13, 5, 6, 7};

    cout << "Original Array: ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    mergeSort(arr, 0, arr.size()-1);

    cout << "Sorted Array:   ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {12, 11, 13, 5, 6, 7}

Divide: [12,11,13] and [5,6,7]
Left: [12,11,13] → divide [12,11] and [13]
[12,11] → divide [12] and [11] → merge → [11,12]
Merge [11,12] with [13] → [11,12,13]

Right: [5,6,7] → divide [5,6] and [7]
[5,6] → divide [5] and [6] → merge → [5,6]
Merge [5,6] with [7] → [5,6,7]

Merge [11,12,13] with [5,6,7] → [5,6,7,11,12,13]

Final Array: {5,6,7,11,12,13}

```

---

## **Question: Quick Sort – Divide & Conquer; pick pivot, partition, sort halves. O(n log n) avg, O(n²) worst, in-place.**

**Approach:**
Question: Implement Quick Sort

Approach:

1. Divide & Conquer approach.
2. Steps:
   a. Pick a pivot element (commonly last element).
   b. Partition the array such that:
   - Elements <= pivot go to left
   - Elements > pivot go to right
     c. Recursively sort left and right partitions.
3. In-place sorting: no extra arrays needed.
   Time Complexity: O(n log n) average, O(n^2) worst (already sorted array + bad pivot)
   Space Complexity: O(log n) recursive stack
   Notes:

- Not stable
- Can be optimized using random pivot to avoid worst-case

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Partition function: Lomuto partition scheme
int partition(vector<int>& arr, int low, int high){
    int pivot = arr[high];      // Pivot element (last element)
    int i = low - 1;            // Index of smaller element

    for(int j = low; j <= high-1; j++){
        if(arr[j] <= pivot){    // If current element <= pivot
            i++;
            swap(arr[i], arr[j]); // Swap to left side
        }
    }
    swap(arr[i+1], arr[high]);  // Place pivot at correct position
    return i+1;                 // Return pivot index
}

// Recursive Quick Sort function
void quickSort(vector<int>& arr, int low, int high){
    if(low < high){
        int pi = partition(arr, low, high); // Partitioning index
        quickSort(arr, low, pi-1);          // Sort left subarray
        quickSort(arr, pi+1, high);         // Sort right subarray
    }
}

int main(){
    vector<int> arr = {10, 7, 8, 9, 1, 5};

    cout << "Original Array: ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    quickSort(arr, 0, arr.size()-1);

    cout << "Sorted Array:   ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {10,7,8,9,1,5}
Pivot = 5

Partition:
10>5 → stay
7>5 → stay
8>5 → stay
9>5 → stay
1<=5 → swap with first >5 → swap 10 and 1 → {1,7,8,9,10,5}
Place pivot 5 → swap with 7 → {1,5,8,9,10,7}
Pivot index=1

Left subarray: {1} → already sorted
Right subarray: {8,9,10,7} → pivot=7 → partition → {7,9,10,8}...
Continue recursively until sorted

Final Array: {1,5,7,8,9,10}

```

---

## **Question: Quick Sort Randomized**

**Approach:**
Question: Implement Randomized Quick Sort

Approach:

1. Quick Sort variant to avoid worst-case O(n^2) on already sorted or adversarial arrays.
2. Steps:
   a. Randomly pick a pivot element from the subarray.
   b. Swap it with the last element and perform Lomuto partition.
   c. Recursively sort left and right partitions.
3. Randomization ensures average O(n log n) time even for nearly sorted input.
   Time Complexity: O(n log n) average, O(n^2) worst (rare)
   Space Complexity: O(log n) recursive stack
   Notes:

- Not stable
- Random pivot reduces likelihood of worst-case behavior

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <cstdlib>   // For rand()
#include <ctime>     // For seeding rand()
using namespace std;

// Lomuto partition function
int partition(vector<int>& arr, int low, int high){
    int pivot = arr[high];  // Pivot element
    int i = low - 1;

    for(int j = low; j <= high-1; j++){
        if(arr[j] <= pivot){
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i+1], arr[high]);
    return i+1;
}

// Randomized partition
int randomizedPartition(vector<int>& arr, int low, int high){
    int pivotIndex = low + rand() % (high - low + 1); // Random pivot index
    swap(arr[pivotIndex], arr[high]);                 // Swap pivot with last element
    return partition(arr, low, high);                // Partition around pivot
}

// Recursive Randomized Quick Sort
void randomizedQuickSort(vector<int>& arr, int low, int high){
    if(low < high){
        int pi = randomizedPartition(arr, low, high); // Partition index
        randomizedQuickSort(arr, low, pi-1);          // Sort left
        randomizedQuickSort(arr, pi+1, high);         // Sort right
    }
}

int main(){
    srand(time(0)); // Seed random number generator

    vector<int> arr = {10, 7, 8, 9, 1, 5};

    cout << "Original Array: ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    randomizedQuickSort(arr, 0, arr.size()-1);

    cout << "Sorted Array:   ";
    for(int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {10,7,8,9,1,5}
Random pivot chosen, e.g., 8 → swap with last → {10,7,5,9,1,8}
Partition around pivot=8 → {5,7,1,8,10,9}
Pivot index=3

Left subarray: {5,7,1} → random pivot=7 → partition → {5,1,7}
Right subarray: {10,9} → random pivot=10 → partition → {9,10}

Final Array after recursive merges: {1,5,7,8,9,10}

```

---
