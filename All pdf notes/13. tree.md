## **Question: | 1 | Preorder Traversal (recursive) | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, perform **preorder traversal** in both recursive and iterative ways:

- Visit **root** first
- Traverse **left subtree**
- Traverse **right subtree**

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output (Preorder): 1 2 4 5 3

---

APPROACH:

1. Recursive Method:
   a. Base case: if node is NULL, return
   b. Visit root
   c. Traverse left subtree recursively
   d. Traverse right subtree recursively
   Time Complexity: O(n), Space Complexity: O(h) (recursion stack)

2. Iterative Method:
   a. Use a stack
   b. Push root to stack
   c. While stack is not empty: - Pop top node → visit it - Push right child (if exists) - Push left child (if exists)
   d. Ensures root-left-right order
   Time Complexity: O(n), Space Complexity: O(h)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Recursive Preorder Traversal
// ----------------------
void preorderRecursive(TreeNode* root, vector<int> &res) {
    if(root == nullptr) return;     // Base case
    res.push_back(root->val);       // Visit root
    preorderRecursive(root->left, res);   // Traverse left subtree
    preorderRecursive(root->right, res);  // Traverse right subtree
}

// ----------------------
// Iterative Preorder Traversal
// ----------------------
vector<int> preorderIterative(TreeNode* root) {
    vector<int> res;
    if(root == nullptr) return res;

    stack<TreeNode*> st;
    st.push(root);                  // Push root

    while(!st.empty()) {
        TreeNode* node = st.top();
        st.pop();

        res.push_back(node->val);   // Visit node

        if(node->right) st.push(node->right); // Push right child first
        if(node->left) st.push(node->left);   // Push left child next
    }
    return res;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> resRecursive;
    preorderRecursive(root, resRecursive);

    cout << "Preorder Recursive: ";
    for(int x : resRecursive) cout << x << " ";
    cout << endl;

    vector<int> resIterative = preorderIterative(root);
    cout << "Preorder Iterative: ";
    for(int x : resIterative) cout << x << " ";
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Recursive:
Visit 1 → res=[1]
Left of 1 → 2 → res=[1,2]
Left of 2 → 4 → res=[1,2,4]
Left & Right of 4 → null → return
Right of 2 → 5 → res=[1,2,4,5]
Right of 1 → 3 → res=[1,2,4,5,3]

Iterative:
Stack: [1]
Pop 1 → visit → res=[1], push 3, push 2 → stack=[3,2]
Pop 2 → visit → res=[1,2], push 5, push 4 → stack=[3,5,4]
Pop 4 → visit → res=[1,2,4]
Pop 5 → visit → res=[1,2,4,5]
Pop 3 → visit → res=[1,2,4,5,3]

Final Output:
Preorder Recursive: 1 2 4 5 3
Preorder Iterative: 1 2 4 5 3

```

---

## **Question: | 2 | Inorder Traversal (both) | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, perform **inorder traversal** in both recursive and iterative ways:

- Traverse **left subtree**
- Visit **root**
- Traverse **right subtree**

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output (Inorder): 4 2 5 1 3

---

APPROACH:

1. Recursive Method:
   a. Base case: if node is NULL, return
   b. Recursively traverse left subtree
   c. Visit root
   d. Recursively traverse right subtree
   Time Complexity: O(n), Space Complexity: O(h) (recursion stack)

2. Iterative Method (using stack):
   a. Initialize an empty stack
   b. Set current = root
   c. While current != NULL or stack not empty: - Push all left children to stack - Pop from stack → visit node - Move to right child
   d. Ensures left-root-right order
   Time Complexity: O(n), Space Complexity: O(h)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Recursive Inorder Traversal
// ----------------------
void inorderRecursive(TreeNode* root, vector<int> &res) {
    if(root == nullptr) return;           // Base case
    inorderRecursive(root->left, res);   // Traverse left
    res.push_back(root->val);             // Visit root
    inorderRecursive(root->right, res);  // Traverse right
}

// ----------------------
// Iterative Inorder Traversal
// ----------------------
vector<int> inorderIterative(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> st;
    TreeNode* curr = root;

    while(curr != nullptr || !st.empty()) {
        // Push all left children to stack
        while(curr != nullptr) {
            st.push(curr);
            curr = curr->left;
        }

        // Pop and visit
        curr = st.top();
        st.pop();
        res.push_back(curr->val);

        // Move to right subtree
        curr = curr->right;
    }
    return res;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> resRecursive;
    inorderRecursive(root, resRecursive);
    cout << "Inorder Recursive: ";
    for(int x : resRecursive) cout << x << " ";
    cout << endl;

    vector<int> resIterative = inorderIterative(root);
    cout << "Inorder Iterative: ";
    for(int x : resIterative) cout << x << " ";
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Recursive:
Left of 1 → 2
Left of 2 → 4 → visit 4 → res=[4]
Back to 2 → visit 2 → res=[4,2]
Right of 2 → 5 → visit 5 → res=[4,2,5]
Back to 1 → visit 1 → res=[4,2,5,1]
Right of 1 → 3 → visit 3 → res=[4,2,5,1,3]

Iterative:
curr=1 → push 1, curr=2 → push 2, curr=4 → push 4
curr=null → pop 4 → visit → res=[4], curr=null
pop 2 → visit → res=[4,2], curr=5 → push 5
curr=null → pop 5 → visit → res=[4,2,5], curr=null
pop 1 → visit → res=[4,2,5,1], curr=3 → push 3
curr=null → pop 3 → visit → res=[4,2,5,1,3]

Final Output:
Inorder Recursive: 4 2 5 1 3
Inorder Iterative: 4 2 5 1 3

```

---

## **Question: | 3 | Postorder Traversal (both) | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, perform **postorder traversal** in both recursive and iterative ways:

- Traverse **left subtree**
- Traverse **right subtree**
- Visit **root**

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output (Postorder): 4 5 2 3 1

---

APPROACH:

1. Recursive Method:
   a. Base case: if node is NULL, return
   b. Recursively traverse left subtree
   c. Recursively traverse right subtree
   d. Visit root
   Time Complexity: O(n), Space Complexity: O(h) (recursion stack)

2. Iterative Method (using two stacks or one stack + previous pointer):
   a. Method with one stack: - Use a stack and track previously visited node - Push nodes and traverse left until NULL - Peek top, check if right child is visited - If yes, visit node; else, move to right child
   b. Ensures left-right-root order
   Time Complexity: O(n), Space Complexity: O(h)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Recursive Postorder Traversal
// ----------------------
void postorderRecursive(TreeNode* root, vector<int> &res) {
    if(root == nullptr) return;           // Base case
    postorderRecursive(root->left, res);  // Traverse left
    postorderRecursive(root->right, res); // Traverse right
    res.push_back(root->val);             // Visit root
}

// ----------------------
// Iterative Postorder Traversal (single stack)
// ----------------------
vector<int> postorderIterative(TreeNode* root) {
    vector<int> res;
    if(root == nullptr) return res;

    stack<TreeNode*> st;
    TreeNode* curr = root;
    TreeNode* prev = nullptr;  // previously visited node

    while(curr != nullptr || !st.empty()) {
        // Go to leftmost node
        while(curr != nullptr) {
            st.push(curr);
            curr = curr->left;
        }

        curr = st.top();  // peek node

        // If right child is NULL or already visited
        if(curr->right == nullptr || curr->right == prev) {
            res.push_back(curr->val);  // visit node
            st.pop();
            prev = curr;
            curr = nullptr;
        } else {
            curr = curr->right;        // move to right subtree
        }
    }
    return res;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> resRecursive;
    postorderRecursive(root, resRecursive);
    cout << "Postorder Recursive: ";
    for(int x : resRecursive) cout << x << " ";
    cout << endl;

    vector<int> resIterative = postorderIterative(root);
    cout << "Postorder Iterative: ";
    for(int x : resIterative) cout << x << " ";
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Recursive:
Left of 1 → 2
Left of 2 → 4 → visit 4 → res=[4]
Right of 2 → 5 → visit 5 → res=[4,5]
Visit 2 → res=[4,5,2]
Right of 1 → 3 → visit 3 → res=[4,5,2,3]
Visit 1 → res=[4,5,2,3,1]

Iterative:
Push 1 → stack=[1], move left 2 → push 2, move left 4 → push 4
Left null → peek 4, right null → visit 4 → pop → prev=4
Peek 2, right=5 not visited → move 5 → push 5
Left null → peek 5, right null → visit 5 → pop → prev=5
Peek 2, right=5 prev → visit 2 → pop → prev=2
Peek 1, right=3 not visited → move 3 → push 3
Left null → peek 3, right null → visit 3 → pop → prev=3
Peek 1, right=3 prev → visit 1 → pop → prev=1

Final Output:
Postorder Recursive: 4 5 2 3 1
Postorder Iterative: 4 5 2 3 1

```

---

## **Question: | 4 | Level Order Traversal (BFS) | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, perform **level order traversal (BFS)**:

- Visit nodes **level by level** from left to right.

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output: [1,2,3,4,5]

---

APPROACH:

1. Use a queue to traverse nodes level by level:
   a. Push root into queue
   b. While queue is not empty: - Pop front node → visit it - Push left child if exists - Push right child if exists
2. Time Complexity: O(n) → each node visited once
3. Space Complexity: O(n) → queue may store up to n nodes

**Code:**

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Level Order Traversal
// ----------------------
vector<int> levelOrder(TreeNode* root) {
    vector<int> res;                 // store result
    if(root == nullptr) return res;  // empty tree

    queue<TreeNode*> q;              // queue for BFS
    q.push(root);                    // start with root

    while(!q.empty()) {
        TreeNode* node = q.front();  // get front node
        q.pop();                     // remove it from queue
        res.push_back(node->val);    // visit node

        if(node->left) q.push(node->left);   // enqueue left child
        if(node->right) q.push(node->right); // enqueue right child
    }
    return res;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> res = levelOrder(root);

    cout << "Level Order Traversal: ";
    for(int x : res) cout << x << " ";  // print all nodes
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Step 1: Queue = [1]
Pop 1 → visit 1 → res=[1], enqueue 2,3 → Queue=[2,3]
Pop 2 → visit 2 → res=[1,2], enqueue 4,5 → Queue=[3,4,5]
Pop 3 → visit 3 → res=[1,2,3], no children → Queue=[4,5]
Pop 4 → visit 4 → res=[1,2,3,4], no children → Queue=[5]
Pop 5 → visit 5 → res=[1,2,3,4,5], no children → Queue=[]

Final Output:
Level Order Traversal: 1 2 3 4 5

```

---

## **Question: | 5 | Iterative Preorder Traversal | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, perform **preorder traversal** iteratively:

- Visit **root** first
- Traverse **left subtree**
- Traverse **right subtree**

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output (Preorder): 1 2 4 5 3

---

APPROACH (Iterative using stack):

1. Use a stack to mimic recursion:
   a. Push root onto stack
   b. While stack is not empty: - Pop top node → visit it - Push right child if exists - Push left child if exists
   c. This ensures root-left-right order
2. Time Complexity: O(n) → each node visited once
3. Space Complexity: O(h) → stack stores nodes along current path

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Iterative Preorder Traversal
// ----------------------
vector<int> preorderIterative(TreeNode* root) {
    vector<int> res;                 // store traversal
    if(root == nullptr) return res;  // empty tree

    stack<TreeNode*> st;             // stack to store nodes
    st.push(root);                   // push root to start

    while(!st.empty()) {
        TreeNode* node = st.top();   // get top node
        st.pop();                    // remove from stack
        res.push_back(node->val);    // visit node

        if(node->right) st.push(node->right); // push right child first
        if(node->left) st.push(node->left);   // push left child next
        // left child will be processed before right → preorder
    }
    return res;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> res = preorderIterative(root);

    cout << "Iterative Preorder Traversal: ";
    for(int x : res) cout << x << " ";  // print traversal
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Step 1: Stack=[1]
Pop 1 → visit → res=[1], push 3, push 2 → Stack=[3,2]
Pop 2 → visit → res=[1,2], push 5, push 4 → Stack=[3,5,4]
Pop 4 → visit → res=[1,2,4] → no children
Pop 5 → visit → res=[1,2,4,5] → no children
Pop 3 → visit → res=[1,2,4,5,3] → no children

Final Output:
Iterative Preorder Traversal: 1 2 4 5 3

```

---

## **Question: | 6 | Iterative Inorder Traversal | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, perform **inorder traversal** iteratively:

- Traverse **left subtree**
- Visit **root**
- Traverse **right subtree**

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output (Inorder): 4 2 5 1 3

---

APPROACH (Iterative using stack):

1. Use a stack to simulate recursion:
   a. Initialize an empty stack
   b. Set current = root
   c. While current != NULL or stack not empty: - Push all left children onto stack - Pop top → visit node - Move to right child
2. Time Complexity: O(n) → each node visited once
3. Space Complexity: O(h) → stack stores nodes along current path

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Iterative Inorder Traversal
// ----------------------
vector<int> inorderIterative(TreeNode* root) {
    vector<int> res;                 // store traversal
    stack<TreeNode*> st;             // stack to store nodes
    TreeNode* curr = root;           // start from root

    while(curr != nullptr || !st.empty()) {
        // Step 1: push all left children to stack
        while(curr != nullptr) {
            st.push(curr);
            curr = curr->left;
        }

        // Step 2: pop and visit node
        curr = st.top();
        st.pop();
        res.push_back(curr->val);

        // Step 3: move to right subtree
        curr = curr->right;
    }

    return res;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> res = inorderIterative(root);

    cout << "Iterative Inorder Traversal: ";
    for(int x : res) cout << x << " ";  // print traversal
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Step 1: curr=1 → push 1 → move left curr=2 → push 2 → move left curr=4 → push 4 → curr=null
Step 2: pop 4 → visit → res=[4], move right → null
Step 3: pop 2 → visit → res=[4,2], move right → curr=5 → push 5 → curr=null
Step 4: pop 5 → visit → res=[4,2,5], move right → null
Step 5: pop 1 → visit → res=[4,2,5,1], move right → curr=3 → push 3 → curr=null
Step 6: pop 3 → visit → res=[4,2,5,1,3], move right → null

Final Output:
Iterative Inorder Traversal: 4 2 5 1 3

```

---

## **Question: | 7 | Iterative Postorder Traversal (2 stacks) | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, perform **postorder traversal iteratively using 2 stacks**:

- Traverse **left subtree**
- Traverse **right subtree**
- Visit **root**

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output (Postorder): 4 5 2 3 1

---

APPROACH (2 stacks):

1. Use two stacks (s1 and s2):
   a. Push root to s1
   b. While s1 is not empty: - Pop node from s1 → push it to s2 - Push left child to s1 if exists - Push right child to s1 if exists
   c. After s1 is empty, pop all nodes from s2 → gives postorder
2. Time Complexity: O(n) → each node pushed/popped twice
3. Space Complexity: O(n) → 2 stacks

**Code:**

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Iterative Postorder Traversal using 2 stacks
// ----------------------
vector<int> postorderIterativeTwoStacks(TreeNode* root) {
    vector<int> res;                 // store traversal
    if(root == nullptr) return res;  // empty tree

    stack<TreeNode*> s1, s2;         // two stacks
    s1.push(root);                    // push root to s1

    while(!s1.empty()) {
        TreeNode* node = s1.top();   // get top of s1
        s1.pop();                    // remove from s1
        s2.push(node);               // push to s2 (reversed order)

        if(node->left) s1.push(node->left);    // push left child to s1
        if(node->right) s1.push(node->right);  // push right child to s1
    }

    // Pop all nodes from s2 → postorder
    while(!s2.empty()) {
        res.push_back(s2.top()->val);
        s2.pop();
    }

    return res;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> res = postorderIterativeTwoStacks(root);

    cout << "Iterative Postorder Traversal (2 stacks): ";
    for(int x : res) cout << x << " ";  // print traversal
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Step 1: s1=[1], s2=[]
Pop 1 from s1 → push to s2 → s2=[1], push left 2, right 3 → s1=[2,3]
Pop 3 → push to s2 → s2=[1,3], no children → s1=[2]
Pop 2 → push to s2 → s2=[1,3,2], push left 4, right 5 → s1=[4,5]
Pop 5 → push to s2 → s2=[1,3,2,5], no children → s1=[4]
Pop 4 → push to s2 → s2=[1,3,2,5,4], no children → s1=[]

Step 2: Pop all from s2 → postorder
Pop 4 → res=[4]
Pop 5 → res=[4,5]
Pop 2 → res=[4,5,2]
Pop 3 → res=[4,5,2,3]
Pop 1 → res=[4,5,2,3,1]

Final Output:
Iterative Postorder Traversal (2 stacks): 4 5 2 3 1

```

---

## **Question: | 8 | Iterative Postorder Traversal (1 stack) | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, perform **postorder traversal iteratively using 1 stack**:

- Traverse **left subtree**
- Traverse **right subtree**
- Visit **root**

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output (Postorder): 4 5 2 3 1

---

APPROACH (1 stack):

1. Use a single stack and a pointer to track previous node:
   a. Push nodes while moving left
   b. Peek top node: - If right child is NULL or already visited → visit node - Else → move to right child
2. Time Complexity: O(n) → each node visited once
3. Space Complexity: O(h) → stack stores nodes along current path

**Code:**

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Iterative Postorder Traversal using 1 stack
// ----------------------
vector<int> postorderIterativeOneStack(TreeNode* root) {
    vector<int> res;                 // store traversal
    if(root == nullptr) return res;  // empty tree

    stack<TreeNode*> st;             // stack for traversal
    TreeNode* curr = root;           // current node
    TreeNode* prev = nullptr;        // previously visited node

    while(curr != nullptr || !st.empty()) {
        // push all left children
        while(curr != nullptr) {
            st.push(curr);
            curr = curr->left;
        }

        curr = st.top();              // peek top node

        // if right child is null or already visited
        if(curr->right == nullptr || curr->right == prev) {
            res.push_back(curr->val); // visit node
            st.pop();
            prev = curr;              // mark as visited
            curr = nullptr;
        } else {
            curr = curr->right;       // move to right child
        }
    }

    return res;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> res = postorderIterativeOneStack(root);

    cout << "Iterative Postorder Traversal (1 stack): ";
    for(int x : res) cout << x << " ";  // print traversal
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Step 1: curr=1 → push 1 → curr=2 → push 2 → curr=4 → push 4 → curr=null
Peek 4 → right=null → visit 4 → res=[4] → prev=4
Peek 2 → right=5 not visited → curr=5 → push 5 → curr=null
Peek 5 → right=null → visit 5 → res=[4,5] → prev=5
Peek 2 → right=5 visited → visit 2 → res=[4,5,2] → prev=2
Peek 1 → right=3 not visited → curr=3 → push 3 → curr=null
Peek 3 → right=null → visit 3 → res=[4,5,2,3] → prev=3
Peek 1 → right=3 visited → visit 1 → res=[4,5,2,3,1] → prev=1

Final Output:
Iterative Postorder Traversal (1 stack): 4 5 2 3 1

```

---

## **Question: | 9 | Preorder, Inorder, Postorder in single traversal | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, print **preorder, inorder, and postorder traversals** in a **single traversal** without recursion for each.

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output:
Preorder: 1 2 4 5 3
Inorder: 4 2 5 1 3
Postorder:4 5 2 3 1

---

APPROACH (Iterative using stack with state):

1. Use a stack of pairs: (node, state)
   - state = 1 → preorder processing
   - state = 2 → inorder processing
   - state = 3 → postorder processing
2. While stack not empty:
   a. Pop top node & state
   b. state=1 → push left child, add to preorder
   c. state=2 → add to inorder, push right child
   d. state=3 → add to postorder
3. Time Complexity: O(n) → each node visited once
4. Space Complexity: O(h) → stack stores nodes along current path

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Single Traversal Preorder, Inorder, Postorder
// ----------------------
void allTraversals(TreeNode* root, vector<int> &pre, vector<int> &in, vector<int> &post) {
    if(root == nullptr) return;

    stack<pair<TreeNode*, int>> st;    // node + state
    st.push({root, 1});                // initial state=1 for preorder

    while(!st.empty()) {
        auto &p = st.top();            // peek top
        TreeNode* node = p.first;
        int state = p.second;
        st.pop();

        if(state == 1) {               // Preorder
            pre.push_back(node->val);  // visit for preorder
            st.push({node, 2});        // next state for inorder
            if(node->left) st.push({node->left, 1});  // push left child for preorder
        }
        else if(state == 2) {          // Inorder
            in.push_back(node->val);   // visit for inorder
            st.push({node, 3});        // next state for postorder
            if(node->right) st.push({node->right, 1}); // push right child for preorder
        }
        else {                          // Postorder
            post.push_back(node->val); // visit for postorder
        }
    }
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> pre, in, post;
    allTraversals(root, pre, in, post);

    cout << "Preorder: ";
    for(int x : pre) cout << x << " ";
    cout << "\nInorder: ";
    for(int x : in) cout << x << " ";
    cout << "\nPostorder: ";
    for(int x : post) cout << x << " ";
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Step 1: Push root 1, state=1
Pop 1,state=1 → preorder push 1 → pre=[1], push 1,state=2 → push left 2,state=1
Pop 2,state=1 → preorder push 2 → pre=[1,2], push 2,state=2 → push left 4,state=1
Pop 4,state=1 → preorder push 4 → pre=[1,2,4], push 4,state=2
Pop 4,state=2 → inorder push 4 → in=[4], push right=null
Pop 4,state=3 → postorder push 4 → post=[4]
Pop 2,state=2 → inorder push 2 → in=[4,2], push right 5,state=1
Pop 5,state=1 → preorder push 5 → pre=[1,2,4,5], push 5,state=2
Pop 5,state=2 → inorder push 5 → in=[4,2,5], push right=null
Pop 5,state=3 → postorder push 5 → post=[4,5]
Pop 2,state=3 → postorder push 2 → post=[4,5,2]
Pop 1,state=2 → inorder push 1 → in=[4,2,5,1], push right 3,state=1
Pop 3,state=1 → preorder push 3 → pre=[1,2,4,5,3], push 3,state=2
Pop 3,state=2 → inorder push 3 → in=[4,2,5,1,3], push right=null
Pop 3,state=3 → postorder push 3 → post=[4,5,2,3]
Pop 1,state=3 → postorder push 1 → post=[4,5,2,3,1]

Final Output:
Preorder: 1 2 4 5 3
Inorder:  4 2 5 1 3
Postorder:4 5 2 3 1

```

---

## **Question: | 10 | Maximum Depth / Height of BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, find its **maximum depth / height**:

- Depth = number of nodes along the longest path from root to a leaf.

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output: 3 (path 1→2→4 or 1→2→5)

---

APPROACH:

1. Recursive (DFS):
   a. Base case: if node is NULL → return 0
   b. Recursively compute left height
   c. Recursively compute right height
   d. Height = max(left, right) + 1
   Time Complexity: O(n) → visit each node once
   Space Complexity: O(h) → recursion stack

2. Iterative (BFS):
   a. Use a queue for level order traversal
   b. For each level, increment depth
   Time Complexity: O(n)
   Space Complexity: O(n) → queue can store nodes of a level

**Code:**

```cpp
#include <iostream>
#include <queue>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Recursive DFS Approach
// ----------------------
int maxDepthRecursive(TreeNode* root) {
    if(root == nullptr) return 0;             // empty node → height 0
    int leftHeight = maxDepthRecursive(root->left);   // left subtree height
    int rightHeight = maxDepthRecursive(root->right); // right subtree height
    return max(leftHeight, rightHeight) + 1;  // current height = max + 1
}

// ----------------------
// Iterative BFS Approach
// ----------------------
int maxDepthIterative(TreeNode* root) {
    if(root == nullptr) return 0;            // empty tree → height 0

    queue<TreeNode*> q;
    q.push(root);
    int depth = 0;

    while(!q.empty()) {
        int levelSize = q.size();            // nodes in current level
        for(int i=0;i<levelSize;i++) {
            TreeNode* node = q.front();      // get front node
            q.pop();                         // remove from queue
            if(node->left) q.push(node->left);   // enqueue left child
            if(node->right) q.push(node->right); // enqueue right child
        }
        depth++;                             // increment depth after each level
    }

    return depth;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    cout << "Max Depth (Recursive): " << maxDepthRecursive(root) << endl;
    cout << "Max Depth (Iterative): " << maxDepthIterative(root) << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Recursive DFS:
Node 4 → left=null,right=null → height=1
Node 5 → left=null,right=null → height=1
Node 2 → max(1,1)+1=2
Node 3 → left=null,right=null → height=1
Node 1 → max(2,1)+1=3

Iterative BFS:
Queue=[1] → depth=1, push 2,3 → Queue=[2,3]
Queue=[2,3] → depth=2, push 4,5 → Queue=[4,5]
Queue=[4,5] → depth=3, push none → Queue=[]
Final Depth = 3

Output:
Max Depth (Recursive): 3
Max Depth (Iterative): 3

```

---

## **Question: | 11 | Check if Balanced BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, check if it is **height-balanced**:

- A binary tree is balanced if for every node:
  |height(left subtree) - height(right subtree)| ≤ 1

Example:
Input: 1
/ \
 2 3
/
4  
Output: true (balanced)

Input: 1
/
2  
 /
3  
Output: false (unbalanced)

---

APPROACH (Bottom-up recursion):

1. Recursive function returns height:
   a. Base case: if node is NULL → return 0
   b. Recursively get leftHeight and rightHeight
   c. If difference >1 → mark unbalanced
   d. Return max(leftHeight,rightHeight)+1
2. Time Complexity: O(n) → each node visited once
3. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Check if Binary Tree is Balanced
// ----------------------
bool isBalancedBT(TreeNode* root, int &height) {
    if(root == nullptr) {
        height = 0;         // empty node → height 0
        return true;        // empty tree is balanced
    }

    int lh=0, rh=0;          // left height, right height

    bool leftBalanced = isBalancedBT(root->left, lh);   // check left subtree
    bool rightBalanced = isBalancedBT(root->right, rh); // check right subtree

    height = max(lh,rh) + 1; // height of current node

    if(!leftBalanced || !rightBalanced) return false;  // if either subtree unbalanced
    if(abs(lh - rh) > 1) return false;                // if height difference >1
    return true;                                      // balanced
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     /
    //    4
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);

    int height = 0;
    bool balanced = isBalancedBT(root, height);

    cout << "Is Balanced BT? " << (balanced ? "Yes" : "No") << endl;

    // Example of unbalanced tree:
    TreeNode* root2 = new TreeNode(1);
    root2->left = new TreeNode(2);
    root2->left->left = new TreeNode(3);
    int h2=0;
    cout << "Is Balanced BT? "
         << (isBalancedBT(root2,h2) ? "Yes" : "No") << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree 1:
        1
       / \
      2   3
     /
    4
Step:
Node 4 → left=0,right=0 → balanced → height=1
Node 2 → left=1,right=0 → abs(1-0)=1 ≤1 → balanced → height=2
Node 3 → left=0,right=0 → balanced → height=1
Node 1 → left=2,right=1 → abs(2-1)=1 ≤1 → balanced → height=3
Output: Yes

Tree 2:
        1
       /
      2
     /
    3
Step:
Node 3 → balanced → height=1
Node 2 → left=1,right=0 → abs(1-0)=1 ≤1 → balanced → height=2
Node 1 → left=2,right=0 → abs(2-0)=2 >1 → unbalanced
Output: No

```

---

## **Question: | 12 | Diameter of BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, find its **diameter**:

- Diameter = number of nodes on the longest path between any two nodes.
- Path may pass through root or not.

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output: 4 (path 4→2→1→3)

---

APPROACH (Optimized DFS):

1. Use recursive DFS function:
   a. Base case: if node is NULL → height=0
   b. Recursively compute leftHeight and rightHeight
   c. Diameter passing through node = leftHeight + rightHeight + 1
   d. Update global maximum diameter
   e. Return height = max(leftHeight,rightHeight)+1
2. Time Complexity: O(n) → each node visited once
3. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Optimized Diameter Calculation
// ----------------------
int diameterUtil(TreeNode* root, int &diameter) {
    if(root == nullptr) return 0;           // empty node → height 0

    int lh = diameterUtil(root->left, diameter);   // left subtree height
    int rh = diameterUtil(root->right, diameter);  // right subtree height

    diameter = max(diameter, lh + rh + 1); // update max diameter
    return max(lh, rh) + 1;               // return height of current node
}

int diameterOfBT(TreeNode* root) {
    int diameter = 0;
    diameterUtil(root, diameter);
    return diameter;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    cout << "Diameter of BT: " << diameterOfBT(root) << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Step:
Node 4 → left=0,right=0 → diameter=max(0,0+0+1)=1 → height=1
Node 5 → left=0,right=0 → diameter=max(1,0+0+1)=1 → height=1
Node 2 → left=1,right=1 → diameter=max(1,1+1+1)=3 → height=2
Node 3 → left=0,right=0 → diameter=max(3,0+0+1)=3 → height=1
Node 1 → left=2,right=1 → diameter=max(3,2+1+1)=4 → height=3

Final Output:
Diameter of BT: 4

```

---

## **Question: | 13 | Maximum Path Sum in BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, find the **maximum path sum**:

- A path is any sequence of nodes from some starting node to any node in the tree along parent-child connections.
- The path must contain at least one node and does not need to go through the root.

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Output: 11 (path 4→2→5)

---

APPROACH (DFS):

1. Use a recursive function that returns max path sum **from current node to leaf**:
   a. Base case: if node is NULL → return 0
   b. Recursively calculate left and right sums → ignore negative sums (use max(0, ...))
   c. Max path through current node = node->val + left + right
   d. Update global maximum sum
   e. Return max path from current node to one child = node->val + max(left,right)
2. Time Complexity: O(n) → each node visited once
3. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Maximum Path Sum Calculation
// ----------------------
int maxPathSumUtil(TreeNode* root, int &maxSum) {
    if(root == nullptr) return 0;                    // empty node → contribute 0

    int left = max(0, maxPathSumUtil(root->left, maxSum));   // ignore negative paths
    int right = max(0, maxPathSumUtil(root->right, maxSum));

    maxSum = max(maxSum, root->val + left + right); // max path including this node

    return root->val + max(left, right);           // return max path from node to one child
}

int maxPathSum(TreeNode* root) {
    int maxSum = INT_MIN;
    maxPathSumUtil(root, maxSum);
    return maxSum;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    cout << "Maximum Path Sum in BT: " << maxPathSum(root) << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Step:
Node 4 → left=0,right=0 → maxSum=max(-inf,4+0+0)=4 → return 4+0=4
Node 5 → left=0,right=0 → maxSum=max(4,5+0+0)=5 → return 5+0=5
Node 2 → left=4,right=5 → maxSum=max(5,2+4+5)=11 → return 2+max(4,5)=7
Node 3 → left=0,right=0 → maxSum=max(11,3+0+0)=11 → return 3+0=3
Node 1 → left=7,right=3 → maxSum=max(11,1+7+3)=11 → return 1+max(7,3)=8

Final Output:
Maximum Path Sum in BT: 11

```

---

## **Question: | 14 | Check if two trees are identical | BT |**

**Approach:**
PROBLEM STATEMENT:
Given two binary trees, determine if they are **identical**:

- Two trees are identical if they have the same structure and same node values.

Example:
Tree1: 1
/ \
 2 3

Tree2: 1
/ \
 2 3
Output: true (identical)

Tree2: 1
/ \
 3 2
Output: false (not identical)

---

APPROACH (Recursive DFS):

1. Compare roots:
   a. If both nodes are NULL → identical
   b. If one NULL → not identical
   c. If values differ → not identical
2. Recursively check left and right subtrees
3. Time Complexity: O(n) → visit each node once
4. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Check if Two Binary Trees are Identical
// ----------------------
bool areIdentical(TreeNode* t1, TreeNode* t2) {
    if(t1 == nullptr && t2 == nullptr) return true;  // both empty → identical
    if(t1 == nullptr || t2 == nullptr) return false; // one empty → not identical
    if(t1->val != t2->val) return false;            // values differ → not identical

    // recursively check left and right subtrees
    return areIdentical(t1->left, t2->left) && areIdentical(t1->right, t2->right);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Tree 1
    TreeNode* t1 = new TreeNode(1);
    t1->left = new TreeNode(2);
    t1->right = new TreeNode(3);

    // Tree 2 (identical)
    TreeNode* t2 = new TreeNode(1);
    t2->left = new TreeNode(2);
    t2->right = new TreeNode(3);

    cout << "Are Trees Identical? " << (areIdentical(t1,t2) ? "Yes" : "No") << endl;

    // Tree 3 (not identical)
    TreeNode* t3 = new TreeNode(1);
    t3->left = new TreeNode(3);
    t3->right = new TreeNode(2);

    cout << "Are Trees Identical? " << (areIdentical(t1,t3) ? "Yes" : "No") << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree1:       1
            / \
           2   3
Tree2:       1
            / \
           2   3

Step:
Compare root 1 → same
Compare left child 2 → same
Compare right child 3 → same
→ All nodes matched → Identical

Tree3:       1
            / \
           3   2
Compare root 1 → same
Compare left child 2 vs 3 → differ → Not Identical

Final Output:
Are Trees Identical? Yes
Are Trees Identical? No

```

---

## **Question: | 15 | Symmetric / Mirror Tree Check | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, check if it is **symmetric** (mirror of itself):

- A tree is symmetric if left subtree is a mirror reflection of right subtree.

Example:
Input: 1
/ \
 2 2
/ \ / \
 3 4 4 3
Output: true (symmetric)

Input: 1
/ \
 2 2
\ \
 3 3
Output: false (not symmetric)

---

APPROACH (Recursive DFS):

1. Write helper function `isMirror(t1,t2)`:
   a. If both NULL → true
   b. If one NULL → false
   c. Check values t1->val == t2->val
   d. Recursively check: t1->left vs t2->right AND t1->right vs t2->left
2. Main function: check isMirror(root->left, root->right)
3. Time Complexity: O(n) → each node visited once
4. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Check if Tree is Symmetric (Mirror)
// ----------------------
bool isMirror(TreeNode* t1, TreeNode* t2) {
    if(t1 == nullptr && t2 == nullptr) return true;  // both empty → mirror
    if(t1 == nullptr || t2 == nullptr) return false; // one empty → not mirror
    if(t1->val != t2->val) return false;            // values differ → not mirror

    // left of t1 vs right of t2 AND right of t1 vs left of t2
    return isMirror(t1->left, t2->right) && isMirror(t1->right, t2->left);
}

bool isSymmetric(TreeNode* root) {
    if(root == nullptr) return true;
    return isMirror(root->left, root->right);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Symmetric Tree
    TreeNode* root1 = new TreeNode(1);
    root1->left = new TreeNode(2);
    root1->right = new TreeNode(2);
    root1->left->left = new TreeNode(3);
    root1->left->right = new TreeNode(4);
    root1->right->left = new TreeNode(4);
    root1->right->right = new TreeNode(3);

    cout << "Is Symmetric? " << (isSymmetric(root1) ? "Yes" : "No") << endl;

    // Not Symmetric Tree
    TreeNode* root2 = new TreeNode(1);
    root2->left = new TreeNode(2);
    root2->right = new TreeNode(2);
    root2->left->right = new TreeNode(3);
    root2->right->right = new TreeNode(3);

    cout << "Is Symmetric? " << (isSymmetric(root2) ? "Yes" : "No") << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree 1:
        1
       / \
      2   2
     / \ / \
    3  4 4  3
Step:
Compare 2 vs 2 → same
Compare left 3 vs right 3 → same
Compare right 4 vs left 4 → same
→ All mirrored → Symmetric

Tree 2:
        1
       / \
      2   2
       \   \
        3   3
Step:
Compare 2 vs 2 → same
Compare left NULL vs right 3 → differ → Not Symmetric

Final Output:
Is Symmetric? Yes
Is Symmetric? No

```

---

## **Question: | 16 | Root-to-Node Path Print | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree and a target node value, print the path from root to that node.

Example:
Input: 1
/ \
 2 3
/ \
 4 5
Target: 5
Output: 1 → 2 → 5

Target: 6
Output: No path (node not present)

---

APPROACH (Recursive DFS):

1. Use a recursive function `findPath(node, target, path)`:
   a. If node is NULL → return false
   b. Add current node value to path
   c. If node->val == target → return true
   d. Recursively check left or right subtree
   e. If neither returns true → remove node from path, return false
2. Time Complexity: O(n) → each node visited once
3. Space Complexity: O(h) → recursion stack + O(h) for path

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Find Root-to-Node Path
// ----------------------
bool findPath(TreeNode* root, int target, vector<int> &path) {
    if(root == nullptr) return false;        // empty node → path not found

    path.push_back(root->val);               // add current node to path

    if(root->val == target) return true;     // target found

    // search left or right subtree
    if(findPath(root->left, target, path) || findPath(root->right, target, path))
        return true;

    path.pop_back();                         // backtrack if not found
    return false;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    vector<int> path;
    int target = 5;

    if(findPath(root, target, path)) {
        cout << "Path to " << target << ": ";
        for(int val : path) cout << val << " ";
        cout << endl;
    } else {
        cout << "No path found for " << target << endl;
    }

    // Example: target not present
    path.clear();
    target = 6;
    if(findPath(root, target, path)) {
        cout << "Path to " << target << ": ";
        for(int val : path) cout << val << " ";
        cout << endl;
    } else {
        cout << "No path found for " << target << endl;
    }

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Target: 5
Step:
Visit 1 → add 1
Visit 2 → add 2
Visit 4 → add 4 → target? no → backtrack remove 4
Visit 5 → add 5 → target found → stop
Path: 1 → 2 → 5

Target: 6
Step:
Visit all nodes → target not found → backtrack fully
Path: none

Final Output:
Path to 5: 1 2 5
No path found for 6

```

---

## **Question: | 17 | Lowest Common Ancestor in BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree and two node values n1 and n2, find their **Lowest Common Ancestor (LCA)**:

- LCA is the lowest node in the tree that has both n1 and n2 as descendants (a node can be descendant of itself).

Example:
Input: 1
/ \
 2 3
/ \
 4 5
n1=4, n2=5
Output: 2

n1=4, n2=3
Output: 1

---

APPROACH (Recursive DFS):

1. Base case: if node is NULL → return NULL
2. If node->val == n1 or n2 → return node
3. Recursively find LCA in left and right subtrees
4. If both left and right returned non-NULL → current node is LCA
5. Else return non-NULL child
6. Time Complexity: O(n) → each node visited once
7. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Find Lowest Common Ancestor (LCA)
// ----------------------
TreeNode* LCA(TreeNode* root, int n1, int n2) {
    if(root == nullptr) return nullptr;           // empty tree

    if(root->val == n1 || root->val == n2)        // current node is n1 or n2
        return root;

    TreeNode* leftLCA = LCA(root->left, n1, n2);   // search left subtree
    TreeNode* rightLCA = LCA(root->right, n1, n2); // search right subtree

    if(leftLCA && rightLCA) return root;          // n1 and n2 found in different subtrees

    return (leftLCA != nullptr) ? leftLCA : rightLCA; // return non-null child
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    cout << "LCA of 4 and 5: " << LCA(root,4,5)->val << endl;
    cout << "LCA of 4 and 3: " << LCA(root,4,3)->val << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

LCA(4,5):
Visit 1 → search left 2 → search left 4 → found 4
search right 5 → found 5
Both left and right non-null → LCA = 2

LCA(4,3):
Visit 1 → search left 2 → search left 4 → found 4
search right 3 → found 3
Both left and right non-null → LCA = 1

Final Output:
LCA of 4 and 5: 2
LCA of 4 and 3: 1

```

---

## **Question: | 18 | Zig-Zag / Spiral Traversal | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, print its nodes in **Zig-Zag / Spiral Order**:

- Level 0 → left to right
- Level 1 → right to left
- Level 2 → left to right
- and so on.

Example:
Input: 1
/ \
 2 3
/ \ / \
 4 5 6 7
Output: 1 3 2 4 5 6 7

---

APPROACH (Two methods):

1. Using queue + flag:
   a. Perform level order traversal using queue
   b. Use a flag to reverse level order for alternate levels
   c. Time Complexity: O(n)
   d. Space Complexity: O(n)

2. Using two stacks:
   a. Use s1 for left->right, s2 for right->left
   b. Pop from s1 → push children into s2 in order left->right
   c. Pop from s2 → push children into s1 in order right->left
   d. Continue until both stacks empty
   e. Time Complexity: O(n)
   f. Space Complexity: O(n)

**Code:**

```cpp
#include <iostream>
#include <stack>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Zig-Zag Traversal (Two Stacks)
// ----------------------
void zigZagTraversal(TreeNode* root) {
    if(root == nullptr) return;

    stack<TreeNode*> currentLevel;  // stack for current level
    stack<TreeNode*> nextLevel;     // stack for next level

    currentLevel.push(root);
    bool leftToRight = true;        // direction flag

    while(!currentLevel.empty()) {
        TreeNode* node = currentLevel.top();
        currentLevel.pop();
        cout << node->val << " ";   // print current node

        // push children in proper order based on direction
        if(leftToRight) {
            if(node->left) nextLevel.push(node->left);
            if(node->right) nextLevel.push(node->right);
        } else {
            if(node->right) nextLevel.push(node->right);
            if(node->left) nextLevel.push(node->left);
        }

        if(currentLevel.empty()) {  // end of current level
            leftToRight = !leftToRight;   // flip direction
            swap(currentLevel, nextLevel); // move to next level
        }
    }
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \ / \
    //    4  5 6  7
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    cout << "Zig-Zag Traversal: ";
    zigZagTraversal(root);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Step:
Level 0: stack=[1], leftToRight=true → print 1, push 2(left),3(right) → nextLevel=[2,3]
Swap stacks → leftToRight=false

Level 1: stack=[2,3], leftToRight=false
Pop 3 → print 3, push right 7, left 6 → nextLevel=[7,6]
Pop 2 → print 2, push right 5, left 4 → nextLevel=[7,6,5,4]
Swap stacks → leftToRight=true

Level 2: stack=[7,6,5,4], leftToRight=true
Pop 4,5,6,7 → print 4 5 6 7 → nextLevel empty

Final Output:
Zig-Zag Traversal: 1 3 2 4 5 6 7

```

---

## **Question: | 19 | Boundary Traversal | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, print the **boundary nodes** in anti-clockwise direction:

1. Root
2. Left boundary (excluding leaf nodes)
3. Leaf nodes (left to right)
4. Right boundary (excluding leaf nodes, printed bottom-up)

Example:
Input: 1
/ \
 2 3
/ \ / \
 4 5 6 7
Output: 1 2 4 5 6 7 3

---

APPROACH:

1. Print root node
2. Print left boundary (excluding leaves):
   - Traverse left child if exists, else right child
   - Stop before leaf
3. Print all leaf nodes (inorder traversal):
   - Print nodes with no children
4. Print right boundary (excluding leaves) in bottom-up:
   - Traverse right child if exists, else left child
   - Store nodes in stack or recursive call to print bottom-up
5. Time Complexity: O(n) → each node visited once
6. Space Complexity: O(h) → recursion stack or stack for right boundary

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Helper: Print left boundary (excluding leaves)
void printLeftBoundary(TreeNode* node) {
    while(node) {
        if(node->left || node->right) cout << node->val << " "; // print if not leaf
        if(node->left) node = node->left;
        else node = node->right;
    }
}

// ----------------------
// Helper: Print leaf nodes (inorder)
void printLeaves(TreeNode* node) {
    if(node == nullptr) return;
    printLeaves(node->left);
    if(node->left==nullptr && node->right==nullptr) cout << node->val << " ";
    printLeaves(node->right);
}

// ----------------------
// Helper: Print right boundary (excluding leaves) bottom-up
void printRightBoundary(TreeNode* node) {
    vector<int> temp;
    while(node) {
        if(node->left || node->right) temp.push_back(node->val); // store non-leaf
        if(node->right) node = node->right;
        else node = node->left;
    }
    // print in reverse
    for(int i = temp.size()-1; i >= 0; i--) cout << temp[i] << " ";
}

// ----------------------
// Boundary Traversal
// ----------------------
void boundaryTraversal(TreeNode* root) {
    if(root == nullptr) return;

    cout << root->val << " ";                 // print root

    printLeftBoundary(root->left);           // left boundary
    printLeaves(root->left);                 // left subtree leaves
    printLeaves(root->right);                // right subtree leaves
    printRightBoundary(root->right);         // right boundary bottom-up
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \ / \
    //    4  5 6  7
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    cout << "Boundary Traversal: ";
    boundaryTraversal(root);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Step:
Print root: 1
Left boundary: 2 (4 is leaf, not included)
Leaves: 4 5 6 7
Right boundary (bottom-up): 3
Boundary Traversal sequence: 1 2 4 5 6 7 3

Final Output:
Boundary Traversal: 1 2 4 5 6 7 3

```

---

## **Question: | 21 | Top View of BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, print the **top view** of the tree:

- Top view is the set of nodes visible when the tree is viewed from above.
- For each horizontal distance (HD), print the first node encountered from top to bottom.

Example:
Input: 1
/ \
 2 3
/ \ / \
 4 5 6 7
Output: 4 2 1 3 7

---

APPROACH (BFS + Map):

1. Use BFS with queue storing pairs: (node, horizontal distance)
2. Use map<int,int> to store first node at each HD
3. For each node:
   a. If HD not in map → store node->val
   b. Push left child with HD-1, right child with HD+1
4. After traversal, print map in order of HD
5. Time Complexity: O(n log n) → n nodes + log n for map insertion
6. Space Complexity: O(n) → queue + map

**Code:**

```cpp
PROBLEM STATEMENT:
Given a binary tree, print the **top view** of the tree:
- Top view is the set of nodes visible when the tree is viewed from above.
- For each horizontal distance (HD), print the first node encountered from top to bottom.

Example:
Input:       1
            /   \
           2     3
          / \   / \
         4   5 6   7
Output: 4 2 1 3 7

------------------------------------------------------------
APPROACH (BFS + Map):

1. Use BFS with queue storing pairs: (node, horizontal distance)
2. Use map<int,int> to store first node at each HD
3. For each node:
   a. If HD not in map → store node->val
   b. Push left child with HD-1, right child with HD+1
4. After traversal, print map in order of HD
5. Time Complexity: O(n log n) → n nodes + log n for map insertion
6. Space Complexity: O(n) → queue + map

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Step:
Queue initialized: [(1,0)]
Pop 1 → hd=0 → first node → map[0]=1 → push 2(hd=-1), 3(hd=1)
Pop 2 → hd=-1 → first node → map[-1]=2 → push 4(hd=-2), 5(hd=0)
Pop 3 → hd=1 → first node → map[1]=3 → push 6(hd=0), 7(hd=2)
Pop 4 → hd=-2 → first node → map[-2]=4
Pop 5 → hd=0 → already exists → skip
Pop 6 → hd=0 → already exists → skip
Pop 7 → hd=2 → first node → map[2]=7

Map (HD → Node):
-2 → 4
-1 → 2
0  → 1
1  → 3
2  → 7

Final Output:
Top View: 4 2 1 3 7

```

---

## **Question: | 22 | Bottom View of BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, print the **bottom view** of the tree:

- Bottom view is the set of nodes visible when the tree is viewed from below.
- For each horizontal distance (HD), print the **last node encountered** from top to bottom.

Example:
Input: 1
/ \
 2 3
/ \ / \
 4 5 6 7
Output: 4 2 6 3 7

---

APPROACH (BFS + Map):

1. Use BFS with queue storing pairs: (node, horizontal distance)
2. Use map<int,int> to store **latest node at each HD**
3. For each node:
   a. Overwrite map[HD] = node->val (last node at HD)
   b. Push left child with HD-1, right child with HD+1
4. After traversal, print map in order of HD
5. Time Complexity: O(n log n) → n nodes + log n for map insertion
6. Space Complexity: O(n) → queue + map

**Code:**

```cpp
#include <iostream>
#include <map>
#include <queue>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Bottom View Traversal
// ----------------------
void bottomView(TreeNode* root) {
    if(root == nullptr) return;

    map<int,int> hdMap;                      // HD → latest node value
    queue<pair<TreeNode*, int>> q;           // queue of (node, HD)
    q.push({root, 0});                       // root at HD = 0

    while(!q.empty()) {
        auto p = q.front(); q.pop();
        TreeNode* node = p.first;
        int hd = p.second;

        hdMap[hd] = node->val;               // overwrite for bottom-most node

        if(node->left) q.push({node->left, hd-1});   // left child HD-1
        if(node->right) q.push({node->right, hd+1}); // right child HD+1
    }

    // print bottom view from leftmost HD to rightmost HD
    for(auto &entry : hdMap) {
        cout << entry.second << " ";
    }
    cout << endl;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \ / \
    //    4  5 6  7
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    cout << "Bottom View: ";
    bottomView(root);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Step:
Queue initialized: [(1,0)]
Pop 1 → hd=0 → map[0]=1 → push 2(hd=-1), 3(hd=1)
Pop 2 → hd=-1 → map[-1]=2 → push 4(hd=-2), 5(hd=0)
Pop 3 → hd=1 → map[1]=3 → push 6(hd=0), 7(hd=2)
Pop 4 → hd=-2 → map[-2]=4
Pop 5 → hd=0 → map[0]=5 (overwrite)
Pop 6 → hd=0 → map[0]=6 (overwrite)
Pop 7 → hd=2 → map[2]=7

Map (HD → Node):
-2 → 4
-1 → 2
0  → 6
1  → 3
2  → 7

Final Output:
Bottom View: 4 2 6 3 7

```

---

## **Question: | 23 | Right / Left View of BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, print the nodes visible from the **left** or **right** side:

- **Left View**: First node visible at each level when viewed from left
- **Right View**: First node visible at each level when viewed from right

Example:
Input: 1
/ \
 2 3
/ \ / \
 4 5 6 7

Left View Output: 1 2 4
Right View Output: 1 3 7

---

APPROACH (BFS / Level Order):

1. Perform level order traversal using a queue
2. For left view:
   a. Print the **first node** of each level
3. For right view:
   a. Print the **last node** of each level
4. Time Complexity: O(n) → each node visited once
5. Space Complexity: O(n) → queue

**Code:**

```cpp
#include <iostream>
#include <queue>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Left View of Binary Tree
// ----------------------
void leftView(TreeNode* root) {
    if(!root) return;

    queue<TreeNode*> q;
    q.push(root);

    cout << "Left View: ";
    while(!q.empty()) {
        int sz = q.size();             // number of nodes at current level
        for(int i=0; i<sz; i++) {
            TreeNode* node = q.front(); q.pop();
            if(i==0) cout << node->val << " ";  // first node at level → left view
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    cout << endl;
}

// ----------------------
// Right View of Binary Tree
// ----------------------
void rightView(TreeNode* root) {
    if(!root) return;

    queue<TreeNode*> q;
    q.push(root);

    cout << "Right View: ";
    while(!q.empty()) {
        int sz = q.size();             // number of nodes at current level
        for(int i=0; i<sz; i++) {
            TreeNode* node = q.front(); q.pop();
            if(i==sz-1) cout << node->val << " ";  // last node at level → right view
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    cout << endl;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \ / \
    //    4  5 6  7
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    leftView(root);
    rightView(root);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Left View:
Level 0 → first node 1
Level 1 → first node 2
Level 2 → first node 4
Output: 1 2 4

Right View:
Level 0 → last node 1
Level 1 → last node 3
Level 2 → last node 7
Output: 1 3 7

```

---

## **Question: | 24 | Maximum Width of BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, find the **maximum width**:

- Width of a level = number of nodes at that level
- Maximum width = maximum among all levels

Example:
Input: 1
/ \
 2 3
/ \ \
 4 5 7
Output: 3 (Level 2 has nodes 4,5,7)

---

APPROACH (BFS / Level Order):

1. Perform level order traversal using a queue
2. For each level, count the number of nodes (size of queue)
3. Update maxWidth if current level size > maxWidth
4. Time Complexity: O(n) → each node visited once
5. Space Complexity: O(n) → queue

**Code:**

```cpp
#include <iostream>
#include <queue>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Maximum Width of Binary Tree
// ----------------------
int maximumWidth(TreeNode* root) {
    if(!root) return 0;

    queue<TreeNode*> q;
    q.push(root);
    int maxWidth = 0;

    while(!q.empty()) {
        int levelSize = q.size();           // number of nodes at current level
        maxWidth = max(maxWidth, levelSize); // update max width

        for(int i=0; i<levelSize; i++) {
            TreeNode* node = q.front(); q.pop();
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }

    return maxWidth;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \     \
    //    4   5     7
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->right = new TreeNode(7);

    cout << "Maximum Width of BT: " << maximumWidth(root) << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \     \
    4   5     7

Step:
Level 0 → queue=[1] → width=1 → maxWidth=1
Level 1 → queue=[2,3] → width=2 → maxWidth=2
Level 2 → queue=[4,5,7] → width=3 → maxWidth=3

Final Output:
Maximum Width of BT: 3

```

---

## **Question: | 25 | Children Sum Property | BT |**

**Approach:**
PROBLEM STATEMENT:
Check if a binary tree satisfies the **children sum property**:

- For every non-leaf node, node value = sum of left child + right child (if present)

Example:
Input: 10
/ \
 8 2
/ \ \
 3 5 2
Output: true (All nodes satisfy the property)

---

APPROACH (Recursive):

1. Base Case:
   - If node is NULL → return true
   - If node is leaf → return true
2. Check left and right child sum (if child is NULL, consider 0)
3. Return true if:
   a. node->val == leftVal + rightVal
   b. left subtree satisfies property
   c. right subtree satisfies property
4. Time Complexity: O(n) → each node visited once
5. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Check Children Sum Property
// ----------------------
bool isChildrenSum(TreeNode* root) {
    if(root == nullptr) return true;               // empty tree satisfies
    if(!root->left && !root->right) return true;   // leaf node satisfies

    int leftVal = (root->left) ? root->left->val : 0;   // left child value or 0
    int rightVal = (root->right) ? root->right->val : 0; // right child value or 0

    // check current node + recursively check children
    return (root->val == leftVal + rightVal) &&
           isChildrenSum(root->left) &&
           isChildrenSum(root->right);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        10
    //       /  \
    //      8    2
    //     / \    \
    //    3   5    2
    TreeNode* root = new TreeNode(10);
    root->left = new TreeNode(8);
    root->right = new TreeNode(2);
    root->left->left = new TreeNode(3);
    root->left->right = new TreeNode(5);
    root->right->right = new TreeNode(2);

    if(isChildrenSum(root))
        cout << "Tree satisfies Children Sum Property" << endl;
    else
        cout << "Tree does NOT satisfy Children Sum Property" << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        10
       /  \
      8    2
     / \    \
    3   5    2

Step:
Node 10 → left=8, right=2 → 10==8+2 → check left & right
Node 8 → left=3, right=5 → 8==3+5 → check left & right
Node 3 → leaf → true
Node 5 → leaf → true
Node 2 → right child=2, left=NULL → 2==0+2 → check left & right
Node 2 → leaf → true

All nodes satisfy property

Final Output:
Tree satisfies Children Sum Property

```

---

## **Question: | 26 | Print nodes at distance K | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, a target node, and an integer K, print all nodes that are at distance K from the target node.

- Distance is measured in edges.

Example:
Input: 1
/ \
 2 3
/ \ / \
 4 5 6 7
Target = 2, K = 1
Output: 4 5 1

---

APPROACH (Recursive + Downward/Upward):

1. Print nodes **downward** from target:
   - If target is null → return
   - If K=0 → print node
   - Recur for left and right with K-1
2. Handle nodes **upward** from target using recursion:
   - Recur left and right to find target
   - Calculate distance from current node to target
   - If distance == K → print current node
   - Else → explore other subtree at distance K - distance - 2
3. Time Complexity: O(n) → each node visited once
4. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Print nodes downward at distance K
// ----------------------
void printDown(TreeNode* node, int K) {
    if(!node) return;
    if(K == 0) { cout << node->val << " "; return; } // K=0 → print
    printDown(node->left, K-1);                       // left subtree
    printDown(node->right, K-1);                      // right subtree
}

// ----------------------
// Print nodes at distance K from target
// Returns distance from node to target, -1 if target not found
// ----------------------
int printNodesAtK(TreeNode* root, TreeNode* target, int K) {
    if(!root) return -1;

    if(root == target) {
        printDown(root, K); // print downward nodes from target
        return 0;           // distance from target to itself = 0
    }

    int dl = printNodesAtK(root->left, target, K);   // search in left subtree
    if(dl != -1) {
        if(dl+1 == K) cout << root->val << " ";       // current node at distance K
        else printDown(root->right, K-dl-2);          // right subtree at remaining distance
        return dl+1;                                  // distance to target
    }

    int dr = printNodesAtK(root->right, target, K);  // search in right subtree
    if(dr != -1) {
        if(dr+1 == K) cout << root->val << " ";       // current node at distance K
        else printDown(root->left, K-dr-2);           // left subtree at remaining distance
        return dr+1;                                  // distance to target
    }

    return -1; // target not found in either subtree
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \ / \
    //    4  5 6  7
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    TreeNode* target = root->left; // node 2
    int K = 1;

    cout << "Nodes at distance " << K << " from node " << target->val << ": ";
    printNodesAtK(root, target, K);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Target: 2, K=1

Step:
1. printDown(2,1):
   K!=0 → recur left=4(K=0), right=5(K=0)
   Output: 4 5

2. Upward:
   parent=1 → distance from target=1
   dl+1=1 → print parent 1

Final Output:
Nodes at distance 1 from node 2: 4 5 1

```

---

## **Question: | 27 | Burn Tree from Node (Min Time) | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree and a target node where fire starts, calculate the **minimum time** required to burn the entire tree.

- Fire spreads to adjacent nodes (parent and children) in 1 unit of time.

Example:
Input: 1
/ \
 2 3
/ \ / \
 4 5 6 7
Target = 2
Output: 3 (Time to burn all nodes)

---

APPROACH (Recursive + Map Parent + BFS):

1. Map each node to its parent for upward traversal.
2. Start BFS from target node:
   - Queue stores nodes burning at current time
   - Track visited nodes to avoid revisiting
3. Increment time after each BFS level
4. Continue until all nodes are burned
5. Time Complexity: O(n) → visit each node once
6. Space Complexity: O(n) → parent map + queue + visited set

**Code:**

```cpp
#include <iostream>
#include <queue>
#include <map>
#include <set>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Map parent nodes
// ----------------------
void mapParents(TreeNode* root, map<TreeNode*, TreeNode*> &parentMap) {
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()) {
        TreeNode* node = q.front(); q.pop();
        if(node->left) {
            parentMap[node->left] = node;
            q.push(node->left);
        }
        if(node->right) {
            parentMap[node->right] = node;
            q.push(node->right);
        }
    }
}

// ----------------------
// Min time to burn tree from target
// ----------------------
int minTimeToBurn(TreeNode* root, TreeNode* target) {
    if(!root) return 0;

    map<TreeNode*, TreeNode*> parentMap;
    mapParents(root, parentMap); // map parents for upward traversal

    set<TreeNode*> visited;
    queue<TreeNode*> q;
    q.push(target);
    visited.insert(target);

    int time = 0;

    while(!q.empty()) {
        int sz = q.size();
        bool burnedNew = false; // flag to check if fire spreads

        for(int i=0; i<sz; i++) {
            TreeNode* node = q.front(); q.pop();

            // check left child
            if(node->left && visited.find(node->left) == visited.end()) {
                q.push(node->left);
                visited.insert(node->left);
                burnedNew = true;
            }
            // check right child
            if(node->right && visited.find(node->right) == visited.end()) {
                q.push(node->right);
                visited.insert(node->right);
                burnedNew = true;
            }
            // check parent
            if(parentMap[node] && visited.find(parentMap[node]) == visited.end()) {
                q.push(parentMap[node]);
                visited.insert(parentMap[node]);
                burnedNew = true;
            }
        }

        if(burnedNew) time++; // increase time only if fire spreads
    }

    return time;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \ / \
    //    4  5 6  7
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    TreeNode* target = root->left; // node 2

    cout << "Minimum time to burn tree from node " << target->val << ": "
         << minTimeToBurn(root, target) << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Target: 2

Step (BFS levels):
Time 0 → Node burning: 2
Time 1 → Nodes: 4,5,1
Time 2 → Nodes: 3
Time 3 → Nodes: 6,7

All nodes burned in 3 units of time

Final Output:
Minimum time to burn tree from node 2: 3

```

---

## **Question: | 28 | Count nodes in COMPLETE BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a **complete binary tree**, count the total number of nodes efficiently.

- Complete BT: All levels completely filled except possibly the last, which is filled from left to right.

Example:
Input: 1
/ \
 2 3
/ \ /
4 5 6
Output: 6

---

APPROACH (Optimal - O(log^2 n)):

1. Compute height of leftmost path (leftHeight) and rightmost path (rightHeight)
2. If leftHeight == rightHeight → tree is perfect → nodes = 2^h - 1
3. Else → recursively count nodes in left and right subtrees
4. Brute Force: Traverse all nodes → O(n)
5. Optimal: Use height property → O(log^2 n)
6. Time Complexity: O(log^2 n)
7. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
#include <cmath>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Compute height along leftmost path
// ----------------------
int leftHeight(TreeNode* node) {
    int h = 0;
    while(node) {
        h++;
        node = node->left;
    }
    return h;
}

// ----------------------
// Compute height along rightmost path
// ----------------------
int rightHeight(TreeNode* node) {
    int h = 0;
    while(node) {
        h++;
        node = node->right;
    }
    return h;
}

// ----------------------
// Count nodes in Complete BT
// ----------------------
int countNodes(TreeNode* root) {
    if(!root) return 0;

    int lh = leftHeight(root);
    int rh = rightHeight(root);

    if(lh == rh) return pow(2, lh) - 1; // perfect tree → nodes = 2^h -1

    // else recursively count left and right subtrees
    return 1 + countNodes(root->left) + countNodes(root->right);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \  /
    //    4  5 6
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);

    cout << "Total nodes in complete BT: " << countNodes(root) << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \  /
    4  5 6

Step:
Node 1 → leftHeight=3, rightHeight=3? No → recursively count left/right
Left subtree (2) → leftHeight=2, rightHeight=2 → perfect → nodes=3
Right subtree (3) → leftHeight=2, rightHeight=2 → perfect → nodes=2
Total = 1 + 3 + 2 = 6

Final Output:
Total nodes in complete BT: 6

```

---

## **Question: | 29 | Construct Unique BT (requirements) | BT |**

**Approach:**
PROBLEM STATEMENT:
Construct a **binary tree** from given traversal information:

- Common scenarios:
  1. **Preorder + Inorder**
  2. **Postorder + Inorder**
- The tree must be **unique** if these traversals are given correctly.

Example:
Input: Preorder = [1,2,4,5,3,6,7], Inorder = [4,2,5,1,6,3,7]  
Output: Constructed BT:
1
/ \
 2 3
/ \ / \
 4 5 6 7

---

APPROACH (Recursive):

1. Preorder → root always first element
2. Find root index in inorder array → separates left and right subtree
3. Recursively build left and right subtrees
4. Postorder variant: root at last element
5. Base Case: if start > end → return NULL
6. Time Complexity: O(n) → each node processed once + O(n) for index lookup
   - Can optimize index lookup using hashmap → O(1)
7. Space Complexity: O(n) → recursion stack + hashmap

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Recursive helper to build tree
// ----------------------
TreeNode* buildTreeHelper(vector<int>& preorder, int preStart, int preEnd,
                          vector<int>& inorder, int inStart, int inEnd,
                          unordered_map<int,int>& inMap) {
    if(preStart > preEnd || inStart > inEnd) return nullptr; // base case

    int rootVal = preorder[preStart];           // root from preorder
    TreeNode* root = new TreeNode(rootVal);

    int inRootIndex = inMap[rootVal];           // index in inorder
    int numsLeft = inRootIndex - inStart;      // number of nodes in left subtree

    // build left subtree
    root->left = buildTreeHelper(preorder, preStart+1, preStart+numsLeft,
                                 inorder, inStart, inRootIndex-1, inMap);

    // build right subtree
    root->right = buildTreeHelper(preorder, preStart+numsLeft+1, preEnd,
                                  inorder, inRootIndex+1, inEnd, inMap);

    return root;
}

// ----------------------
// Construct Binary Tree from preorder + inorder
// ----------------------
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    unordered_map<int,int> inMap;
    for(int i=0;i<inorder.size();i++) inMap[inorder[i]] = i; // value → index map
    return buildTreeHelper(preorder, 0, preorder.size()-1,
                           inorder, 0, inorder.size()-1, inMap);
}

// ----------------------
// Inorder print to verify
// ----------------------
void printInorder(TreeNode* root) {
    if(!root) return;
    printInorder(root->left);
    cout << root->val << " ";
    printInorder(root->right);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    vector<int> preorder = {1,2,4,5,3,6,7};
    vector<int> inorder =  {4,2,5,1,6,3,7};

    TreeNode* root = buildTree(preorder, inorder);

    cout << "Inorder of constructed tree: ";
    printInorder(root);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Preorder: 1 2 4 5 3 6 7
Inorder:  4 2 5 1 6 3 7

Step:
Root = 1 (preorder[0])
In inorder: index of 1 = 3
Left subtree inorder = 4,2,5 → preorder=2,4,5 → build left
Right subtree inorder = 6,3,7 → preorder=3,6,7 → build right

Recursive construction continues until all nodes processed.

Final Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Inorder Verification Output:
4 2 5 1 6 3 7

```

---

## **Question: | 30 | Construct BT from Preorder + Inorder | BT |**

**Approach:**
PROBLEM STATEMENT:
Given two arrays representing the **preorder** and **inorder** traversal of a binary tree, construct the **original binary tree**.

Example:
Input: Preorder = [1,2,4,5,3,6,7], Inorder = [4,2,5,1,6,3,7]  
Output: Constructed BT:
1
/ \
 2 3
/ \ / \
 4 5 6 7

---

APPROACH (Recursive + HashMap):

1. Preorder → root is always first element
2. Find root index in inorder → separates left and right subtree
3. Recursively build left and right subtrees
4. Base Case: if start > end → return NULL
5. Optimize: store inorder value→index in hashmap for O(1) lookup
6. Time Complexity: O(n) → each node visited once
7. Space Complexity: O(n) → recursion stack + hashmap

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Recursive helper to construct tree
// ----------------------
TreeNode* buildTreeHelper(vector<int>& preorder, int preStart, int preEnd,
                          vector<int>& inorder, int inStart, int inEnd,
                          unordered_map<int,int>& inMap) {
    if(preStart > preEnd || inStart > inEnd) return nullptr; // base case

    int rootVal = preorder[preStart];           // root from preorder
    TreeNode* root = new TreeNode(rootVal);

    int inRootIndex = inMap[rootVal];           // index of root in inorder
    int leftNodes = inRootIndex - inStart;     // number of nodes in left subtree

    // recursively build left subtree
    root->left = buildTreeHelper(preorder, preStart+1, preStart+leftNodes,
                                 inorder, inStart, inRootIndex-1, inMap);

    // recursively build right subtree
    root->right = buildTreeHelper(preorder, preStart+leftNodes+1, preEnd,
                                  inorder, inRootIndex+1, inEnd, inMap);

    return root;
}

// ----------------------
// Construct BT from preorder + inorder
// ----------------------
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    unordered_map<int,int> inMap;               // value → index map for inorder
    for(int i=0;i<inorder.size();i++) inMap[inorder[i]] = i;
    return buildTreeHelper(preorder, 0, preorder.size()-1,
                           inorder, 0, inorder.size()-1, inMap);
}

// ----------------------
// Inorder print to verify
// ----------------------
void printInorder(TreeNode* root) {
    if(!root) return;
    printInorder(root->left);
    cout << root->val << " ";
    printInorder(root->right);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    vector<int> preorder = {1,2,4,5,3,6,7};
    vector<int> inorder  = {4,2,5,1,6,3,7};

    TreeNode* root = buildTree(preorder, inorder);

    cout << "Inorder of constructed tree: ";
    printInorder(root);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Preorder: 1 2 4 5 3 6 7
Inorder:  4 2 5 1 6 3 7

Step:
Root = 1 (preorder[0])
In inorder: index of 1 = 3
Left subtree inorder = 4,2,5 → preorder=2,4,5 → build left
Right subtree inorder = 6,3,7 → preorder=3,6,7 → build right

Recursive construction continues for all nodes.

Final Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Verification (Inorder):
4 2 5 1 6 3 7

```

---

## **Question: | 31 | Construct BT from Postorder + Inorder | BT |**

**Approach:**
PROBLEM STATEMENT:
Given two arrays representing the **postorder** and **inorder** traversal of a binary tree, construct the **original binary tree**.

Example:
Input: Postorder = [4,5,2,6,7,3,1], Inorder = [4,2,5,1,6,3,7]  
Output: Constructed BT:
1
/ \
 2 3
/ \ / \
 4 5 6 7

---

APPROACH (Recursive + HashMap):

1. Postorder → root is always last element
2. Find root index in inorder → separates left and right subtree
3. Recursively build left and right subtrees
4. Base Case: if start > end → return NULL
5. Optimize: store inorder value→index in hashmap for O(1) lookup
6. Time Complexity: O(n) → each node visited once
7. Space Complexity: O(n) → recursion stack + hashmap

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Recursive helper to construct tree
// ----------------------
TreeNode* buildTreeHelper(vector<int>& postorder, int postStart, int postEnd,
                          vector<int>& inorder, int inStart, int inEnd,
                          unordered_map<int,int>& inMap) {
    if(postStart > postEnd || inStart > inEnd) return nullptr; // base case

    int rootVal = postorder[postEnd];           // root from postorder
    TreeNode* root = new TreeNode(rootVal);

    int inRootIndex = inMap[rootVal];           // index of root in inorder
    int leftNodes = inRootIndex - inStart;     // number of nodes in left subtree

    // recursively build left subtree
    root->left = buildTreeHelper(postorder, postStart, postStart+leftNodes-1,
                                 inorder, inStart, inRootIndex-1, inMap);

    // recursively build right subtree
    root->right = buildTreeHelper(postorder, postStart+leftNodes, postEnd-1,
                                  inorder, inRootIndex+1, inEnd, inMap);

    return root;
}

// ----------------------
// Construct BT from postorder + inorder
// ----------------------
TreeNode* buildTree(vector<int>& postorder, vector<int>& inorder) {
    unordered_map<int,int> inMap;               // value → index map for inorder
    for(int i=0;i<inorder.size();i++) inMap[inorder[i]] = i;
    return buildTreeHelper(postorder, 0, postorder.size()-1,
                           inorder, 0, inorder.size()-1, inMap);
}

// ----------------------
// Inorder print to verify
// ----------------------
void printInorder(TreeNode* root) {
    if(!root) return;
    printInorder(root->left);
    cout << root->val << " ";
    printInorder(root->right);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    vector<int> postorder = {4,5,2,6,7,3,1};
    vector<int> inorder   = {4,2,5,1,6,3,7};

    TreeNode* root = buildTree(postorder, inorder);

    cout << "Inorder of constructed tree: ";
    printInorder(root);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Postorder: 4 5 2 6 7 3 1
Inorder:   4 2 5 1 6 3 7

Step:
Root = 1 (postorder[last])
In inorder: index of 1 = 3
Left subtree inorder = 4,2,5 → postorder=4,5,2 → build left
Right subtree inorder = 6,3,7 → postorder=6,7,3 → build right

Recursive construction continues for all nodes.

Final Tree:
        1
       / \
      2   3
     / \ / \
    4  5 6  7

Verification (Inorder):
4 2 5 1 6 3 7

```

---

## **Question: | 32 | Serialize / Deserialize BT | BT |**

**Approach:**
PROBLEM STATEMENT:
Implement functions to **serialize** a binary tree into a string and **deserialize** it back to the original tree.

- Serialize: Convert BT into a string (e.g., BFS with null markers)
- Deserialize: Reconstruct BT from the string

Example:
Input Tree:
1
/ \
 2 3
/ \
 4 5

Serialized string (BFS): "1 2 3 N N 4 5 N N N N"
Deserialize → reconstruct the same BT

---

APPROACH (BFS with Null Markers):

1. Serialize:
   - Use level-order traversal (queue)
   - Push node values; use "N" for nulls
2. Deserialize:
   - Read values sequentially
   - Reconstruct tree level by level using queue
3. Time Complexity: O(n) → each node visited once
4. Space Complexity: O(n) → for queue and serialized string

**Code:**

```cpp
PROBLEM STATEMENT:
Implement functions to **serialize** a binary tree into a string and **deserialize** it back to the original tree.

- Serialize: Convert BT into a string (e.g., BFS with null markers)
- Deserialize: Reconstruct BT from the string

Example:
Input Tree:
        1
       / \
      2   3
         / \
        4   5

Serialized string (BFS): "1 2 3 N N 4 5 N N N N"
Deserialize → reconstruct the same BT

------------------------------------------------------------
APPROACH (BFS with Null Markers):

1. Serialize:
   - Use level-order traversal (queue)
   - Push node values; use "N" for nulls
2. Deserialize:
   - Read values sequentially
   - Reconstruct tree level by level using queue
3. Time Complexity: O(n) → each node visited once
4. Space Complexity: O(n) → for queue and serialized string

// End of code
```

**Dry Run:**

```cpp
Original Tree:
        1
       / \
      2   3
         / \
        4   5

Serialize (BFS):
Queue order: 1 → 2,3 → N,N,4,5 → N,N,N,N
Serialized string: "1 2 3 N N 4 5 N N N N"

Deserialize:
Read 1 → root
Read 2 → left child of 1
Read 3 → right child of 1
Read N → left child of 2 (null)
Read N → right child of 2 (null)
Read 4 → left child of 3
Read 5 → right child of 3
Remaining N → null children

Inorder of deserialized tree:
2 1 4 3 5

```

---

## **Question: | 33 | Flatten BT to Linked List | BT |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, flatten it **in-place** to a linked list using **right pointers**.

- The linked list should follow **preorder traversal**.

Example:
Input: 1
/ \
 2 5
/ \ \
 3 4 6
Output (Right-skewed):
1 → 2 → 3 → 4 → 5 → 6

---

APPROACH (Recursive / Iterative):

1. Recursive:
   - Flatten left and right subtrees
   - Move left subtree to right
   - Append original right subtree at end of new right
2. Iterative (Morris-like):
   - For each node, if left exists:
     - Find rightmost node of left
     - Connect original right to rightmost.right
     - Move left to right
     - Set left = NULL
   - Move to right
3. Time Complexity: O(n)
4. Space Complexity: O(h) recursive stack or O(1) iterative

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Flatten BT to linked list (in-place)
// ----------------------
void flatten(TreeNode* root) {
    TreeNode* curr = root;

    while(curr) {
        if(curr->left) {
            // find rightmost node of left subtree
            TreeNode* rightMost = curr->left;
            while(rightMost->right) rightMost = rightMost->right;

            // attach original right subtree to rightMost.right
            rightMost->right = curr->right;

            // move left subtree to right
            curr->right = curr->left;
            curr->left = nullptr; // set left to null
        }
        curr = curr->right; // move to next node
    }
}

// ----------------------
// Print flattened linked list
// ----------------------
void printList(TreeNode* root) {
    while(root) {
        cout << root->val << " ";
        root = root->right;
    }
    cout << endl;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   5
    //     / \   \
    //    3   4   6
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(5);
    root->left->left = new TreeNode(3);
    root->left->right = new TreeNode(4);
    root->right->right = new TreeNode(6);

    flatten(root);

    cout << "Flattened linked list: ";
    printList(root);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Original Tree:
        1
       / \
      2   5
     / \   \
    3   4   6

Step (Iterative):
Curr = 1, left exists → rightMost=4
Attach 1.right (5) to 4.right
Move left (2) to right → 1.right = 2, 1.left=null
Curr = 2, left exists → rightMost=4
Attach 2.right (original 4) → already flattened
Continue moving curr=3 → 4 → 5 → 6

Flattened linked list:
1 2 3 4 5 6

```

---

## **Question: | 34 | Morris Traversal (Inorder / Preorder) | BT |**

**Approach:**
PROBLEM STATEMENT:
Perform **inorder** and **preorder** traversal of a binary tree **without using recursion or stack**.

- Use **threaded binary tree concept** (Morris Traversal)
- Time Complexity: O(n)
- Space Complexity: O(1)

Example:
Input:
1
/ \
 2 3
/ \
 4 5

Inorder: 4 2 5 1 3
Preorder: 1 2 4 5 3

---

APPROACH (Morris Traversal):

1. Initialize current = root
2. While current != NULL:
   a. If current.left == NULL: - Visit current (for preorder/inorder) - Move current = current.right
   b. Else: - Find predecessor (rightmost node in left subtree) - If predecessor.right == NULL: - For preorder: visit current now - Set predecessor.right = current (create thread) - Move current = current.left - Else: - Remove thread (predecessor.right = NULL) - For inorder: visit current now - Move current = current.right
3. Time Complexity: O(n) → each edge visited at most twice
4. Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of Binary Tree Node
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Morris Inorder Traversal
// ----------------------
void morrisInorder(TreeNode* root) {
    TreeNode* curr = root;
    while(curr) {
        if(!curr->left) {
            cout << curr->val << " ";      // visit node
            curr = curr->right;
        } else {
            TreeNode* pred = curr->left;
            while(pred->right && pred->right != curr)
                pred = pred->right;

            if(!pred->right) {
                pred->right = curr;        // create thread
                curr = curr->left;
            } else {
                pred->right = nullptr;     // remove thread
                cout << curr->val << " "; // visit node
                curr = curr->right;
            }
        }
    }
    cout << endl;
}

// ----------------------
// Morris Preorder Traversal
// ----------------------
void morrisPreorder(TreeNode* root) {
    TreeNode* curr = root;
    while(curr) {
        if(!curr->left) {
            cout << curr->val << " ";      // visit node
            curr = curr->right;
        } else {
            TreeNode* pred = curr->left;
            while(pred->right && pred->right != curr)
                pred = pred->right;

            if(!pred->right) {
                cout << curr->val << " ";  // visit node before threading
                pred->right = curr;        // create thread
                curr = curr->left;
            } else {
                pred->right = nullptr;     // remove thread
                curr = curr->right;
            }
        }
    }
    cout << endl;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Construct tree:
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    cout << "Morris Inorder: ";
    morrisInorder(root);

    cout << "Morris Preorder: ";
    morrisPreorder(root);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree:
        1
       / \
      2   3
     / \
    4   5

Morris Inorder Traversal Steps:
curr=1 → left exists → pred=5 → pred.right=NULL → thread → move left=2
curr=2 → left exists → pred=5 → thread → move left=4
curr=4 → left NULL → visit=4 → move right=NULL → back to thread=2 → visit=2
curr=2 → right thread removed → move right=5 → left NULL → visit=5
curr=1 → back to thread → visit=1 → move right=3 → left NULL → visit=3

Morris Inorder Output:
4 2 5 1 3

Morris Preorder Traversal Steps:
curr=1 → left exists → pred=5 → thread → visit=1 → move left=2
curr=2 → left exists → pred=5 → thread → visit=2 → move left=4
curr=4 → left NULL → visit=4 → move right=NULL → back to thread=2 → move right=5 → visit=5
curr=1 → back to thread → move right=3 → visit=3

Morris Preorder Output:
1 2 4 5 3

```

---

## **Question: | 35 | Introduction to BST | BST |**

**Approach:**
PROBLEM STATEMENT:
A **Binary Search Tree (BST)** is a binary tree with the following properties:

1. Left subtree of a node contains only nodes with values **less than** the node’s value.
2. Right subtree of a node contains only nodes with values **greater than** the node’s value.
3. Both left and right subtrees must also be BSTs.
4. No duplicate nodes (for simplicity).

Example:
Insert: 50, 30, 20, 40, 70, 60, 80

BST Structure:
50
/ \
 30 70
/ \ / \
 20 40 60 80

---

APPROACH:

1. **Insertion** (Recursive):
   - If root is NULL → create new node
   - If value < root → insert in left subtree
   - Else → insert in right subtree
2. **Search**:
   - If root is NULL → not found
   - If value == root → found
   - If value < root → search left
   - Else → search right
3. **Inorder Traversal**:
   - Left → Root → Right → gives **sorted order**
4. Time Complexity:
   - Average: O(log n)
   - Worst-case (skewed): O(n)
5. Space Complexity: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of BST Node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Insert a value into BST
// ----------------------
TreeNode* insertBST(TreeNode* root, int val) {
    if(!root) return new TreeNode(val); // empty tree → create node

    if(val < root->val)
        root->left = insertBST(root->left, val);   // insert in left subtree
    else
        root->right = insertBST(root->right, val); // insert in right subtree

    return root; // return unchanged root
}

// ----------------------
// Search a value in BST
// ----------------------
bool searchBST(TreeNode* root, int val) {
    if(!root) return false;          // not found
    if(root->val == val) return true; // found
    if(val < root->val) return searchBST(root->left, val);
    return searchBST(root->right, val);
}

// ----------------------
// Inorder traversal of BST
// ----------------------
void inorder(TreeNode* root) {
    if(!root) return;
    inorder(root->left);          // visit left subtree
    cout << root->val << " ";     // visit root
    inorder(root->right);         // visit right subtree
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    TreeNode* root = nullptr;

    // Insert nodes
    root = insertBST(root, 50);
    root = insertBST(root, 30);
    root = insertBST(root, 20);
    root = insertBST(root, 40);
    root = insertBST(root, 70);
    root = insertBST(root, 60);
    root = insertBST(root, 80);

    cout << "Inorder of BST (sorted): ";
    inorder(root);
    cout << endl;

    // Search
    cout << "Search 40: " << (searchBST(root, 40) ? "Found" : "Not Found") << endl;
    cout << "Search 25: " << (searchBST(root, 25) ? "Found" : "Not Found") << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Insert Sequence: 50,30,20,40,70,60,80

BST Structure:
        50
       /  \
     30    70
    / \    / \
  20  40  60 80

Inorder Traversal → sorted order:
20 30 40 50 60 70 80

Search 40 → Found
Search 25 → Not Found

```

---

## **Question: | 36 | Search in BST | BST |**

**Approach:**
PROBLEM STATEMENT:
Given a Binary Search Tree (BST) and a value, determine whether the value exists in the BST.

Properties of BST:

1. Left subtree < root
2. Right subtree > root
3. Both subtrees are also BSTs

Example:
BST:
50
/ \
 30 70
/ \ / \
 20 40 60 80

Search 60 → Found
Search 25 → Not Found

---

APPROACH:

1. Recursive Search:

   - If root is NULL → return false
   - If root->val == key → return true
   - If key < root->val → search in left subtree
   - Else → search in right subtree

2. Iterative Search:

   - Start from root
   - Move left or right based on comparison until found or NULL

3. Time Complexity:
   - Average: O(log n)
   - Worst-case (skewed): O(n)
4. Space Complexity:
   - Recursive: O(h)
   - Iterative: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of BST Node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Recursive BST Search
// ----------------------
bool searchBST(TreeNode* root, int key) {
    if(!root) return false;            // base case: empty tree → not found
    if(root->val == key) return true;  // found key
    if(key < root->val) return searchBST(root->left, key);  // search left
    return searchBST(root->right, key);                        // search right
}

// ----------------------
// Iterative BST Search
// ----------------------
bool searchBSTIter(TreeNode* root, int key) {
    TreeNode* curr = root;
    while(curr) {
        if(curr->val == key) return true;  // found
        else if(key < curr->val) curr = curr->left; // move left
        else curr = curr->right;                   // move right
    }
    return false; // not found
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    TreeNode* root = new TreeNode(50);
    root->left = new TreeNode(30);
    root->right = new TreeNode(70);
    root->left->left = new TreeNode(20);
    root->left->right = new TreeNode(40);
    root->right->left = new TreeNode(60);
    root->right->right = new TreeNode(80);

    // Test searches
    cout << "Recursive Search 60: " << (searchBST(root, 60) ? "Found" : "Not Found") << endl;
    cout << "Recursive Search 25: " << (searchBST(root, 25) ? "Found" : "Not Found") << endl;

    cout << "Iterative Search 40: " << (searchBSTIter(root, 40) ? "Found" : "Not Found") << endl;
    cout << "Iterative Search 90: " << (searchBSTIter(root, 90) ? "Found" : "Not Found") << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST:
        50
       /  \
     30    70
    / \    / \
  20  40  60 80

Recursive Search 60:
50 → 60 > 50 → move right → 70
70 → 60 < 70 → move left → 60
60 → match → Found

Recursive Search 25:
50 → 25 < 50 → left=30
30 → 25 < 30 → left=20
20 → 25 > 20 → right=NULL → Not Found

Iterative Search 40:
50 → 40 < 50 → left=30
30 → 40 > 30 → right=40 → Found

Iterative Search 90:
50 → 90 > 50 → right=70
70 → 90 > 70 → right=80
80 → 90 > 80 → right=NULL → Not Found

Output:
Recursive Search 60: Found
Recursive Search 25: Not Found
Iterative Search 40: Found
Iterative Search 90: Not Found

```

---

## **Question: | 37 | Ceil in BST | BST |**

**Approach:**
PROBLEM STATEMENT:
Given a BST and a key, find the **Ceil** of the key.

- Ceil: **smallest node value in BST greater than or equal to key**.
- If no such value exists, return -1.

Example:
BST:
50
/ \
 30 70
/ \ / \
 20 40 60 80

Key = 65 → Ceil = 70
Key = 25 → Ceil = 30
Key = 85 → Ceil = -1

---

APPROACH:

1. Start from root.
2. If root == NULL → return -1 (not found)
3. If root->val == key → return root->val (exact match)
4. If key < root->val:
   - Current node is a potential ceil
   - Move to left subtree to find smaller ceil
5. If key > root->val:
   - Move to right subtree (all left values < key cannot be ceil)
6. Keep track of potential ceil while traversing.
7. Time Complexity: O(h) → h = height of BST
8. Space Complexity: O(1) iterative, O(h) recursive

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of BST Node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Find Ceil in BST (Iterative)
// ----------------------
int ceilBST(TreeNode* root, int key) {
    int ceil = -1;               // store potential ceil
    TreeNode* curr = root;

    while(curr) {
        if(curr->val == key) {
            return curr->val;    // exact match → ceil = key
        } else if(curr->val > key) {
            ceil = curr->val;    // potential ceil
            curr = curr->left;   // go left to find smaller ceil
        } else {
            curr = curr->right;  // move right → value too small
        }
    }

    return ceil;                 // return final ceil or -1
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    TreeNode* root = new TreeNode(50);
    root->left = new TreeNode(30);
    root->right = new TreeNode(70);
    root->left->left = new TreeNode(20);
    root->left->right = new TreeNode(40);
    root->right->left = new TreeNode(60);
    root->right->right = new TreeNode(80);

    int keys[] = {65, 25, 85, 40};
    for(int key : keys) {
        cout << "Ceil of " << key << ": " << ceilBST(root, key) << endl;
    }

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST:
        50
       /  \
     30    70
    / \    / \
  20  40  60 80

Key = 65:
50 → 65>50 → move right=70
70 → 65<70 → potential ceil=70 → move left=60
60 → 65>60 → move right=NULL
Ceil = 70

Key = 25:
50 → 25<50 → potential ceil=50 → move left=30
30 → 25<30 → potential ceil=30 → move left=20
20 → 25>20 → move right=NULL
Ceil = 30

Key = 85:
50 → 85>50 → right=70
70 → 85>70 → right=80
80 → 85>80 → right=NULL
Ceil = -1

Key = 40:
50 → 40<50 → potential ceil=50 → move left=30
30 → 40>30 → move right=40
40 → exact match → Ceil=40

Output:
Ceil of 65: 70
Ceil of 25: 30
Ceil of 85: -1
Ceil of 40: 40

```

---

## **Question: | 38 | Floor in BST | BST |**

**Approach:**
PROBLEM STATEMENT:
Given a BST and a key, find the **Floor** of the key.

- Floor: **largest node value in BST less than or equal to key**.
- If no such value exists, return -1.

Example:
BST:
50
/ \
 30 70
/ \ / \
 20 40 60 80

Key = 65 → Floor = 60
Key = 25 → Floor = 20
Key = 15 → Floor = -1

---

APPROACH:

1. Start from root.
2. If root == NULL → return -1 (not found)
3. If root->val == key → return root->val (exact match)
4. If key > root->val:
   - Current node is a potential floor
   - Move to right subtree to find larger floor <= key
5. If key < root->val:
   - Move to left subtree (all right values > key cannot be floor)
6. Keep track of potential floor while traversing.
7. Time Complexity: O(h) → h = height of BST
8. Space Complexity: O(1) iterative, O(h) recursive

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of BST Node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Find Floor in BST (Iterative)
// ----------------------
int floorBST(TreeNode* root, int key) {
    int floor = -1;               // store potential floor
    TreeNode* curr = root;

    while(curr) {
        if(curr->val == key) {
            return curr->val;     // exact match → floor = key
        } else if(curr->val < key) {
            floor = curr->val;    // potential floor
            curr = curr->right;   // move right to find larger floor <= key
        } else {
            curr = curr->left;    // move left → value too large
        }
    }

    return floor;                 // return final floor or -1
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    TreeNode* root = new TreeNode(50);
    root->left = new TreeNode(30);
    root->right = new TreeNode(70);
    root->left->left = new TreeNode(20);
    root->left->right = new TreeNode(40);
    root->right->left = new TreeNode(60);
    root->right->right = new TreeNode(80);

    int keys[] = {65, 25, 15, 40};
    for(int key : keys) {
        cout << "Floor of " << key << ": " << floorBST(root, key) << endl;
    }

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST:
        50
       /  \
     30    70
    / \    / \
  20  40  60 80

Key = 65:
50 → 65>50 → potential floor=50 → move right=70
70 → 65<70 → move left=60
60 → 65>60 → potential floor=60 → right=NULL
Floor = 60

Key = 25:
50 → 25<50 → left=30
30 → 25<30 → left=20
20 → 25>20 → potential floor=20 → right=NULL
Floor = 20

Key = 15:
50 → 15<50 → left=30
30 → 15<30 → left=20
20 → 15<20 → left=NULL
Floor = -1

Key = 40:
50 → 40<50 → left=30
30 → 40>30 → potential floor=30 → right=40
40 → exact match → Floor=40

Output:
Floor of 65: 60
Floor of 25: 20
Floor of 15: -1
Floor of 40: 40

```

---

## **Question: | 39 | Insert Node in BST | BST |**

**Approach:**
PROBLEM STATEMENT:
Given a BST and a value, insert the value into the BST such that the BST property is maintained.

- Do not allow duplicates (for simplicity).

Example:
Insert 25 into BST:
50
/ \
 30 70
/ \ / \
 20 40 60 80

After insertion:
50
/ \
 30 70
/ \ / \
 20 40 60 80
/
25

---

APPROACH:

1. Recursive:
   - If root is NULL → create new node
   - If value < root->val → insert in left subtree
   - If value > root->val → insert in right subtree
2. Iterative:
   - Start from root
   - Traverse left/right until finding NULL position
   - Insert node there
3. Time Complexity: O(h) → h = height of BST
4. Space Complexity: O(h) recursive, O(1) iterative

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of BST Node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Insert Node into BST (Recursive)
// ----------------------
TreeNode* insertBST(TreeNode* root, int val) {
    if(!root) return new TreeNode(val); // empty tree → create node

    if(val < root->val)
        root->left = insertBST(root->left, val);   // insert in left subtree
    else if(val > root->val)
        root->right = insertBST(root->right, val); // insert in right subtree
    // if val == root->val → ignore (no duplicates)

    return root; // return unchanged root
}

// ----------------------
// Inorder traversal (sorted order)
// ----------------------
void inorder(TreeNode* root) {
    if(!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    TreeNode* root = new TreeNode(50);
    root->left = new TreeNode(30);
    root->right = new TreeNode(70);
    root->left->left = new TreeNode(20);
    root->left->right = new TreeNode(40);
    root->right->left = new TreeNode(60);
    root->right->right = new TreeNode(80);

    cout << "Inorder before insertion: ";
    inorder(root);
    cout << endl;

    // Insert new node
    root = insertBST(root, 25);

    cout << "Inorder after inserting 25: ";
    inorder(root);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST before insertion (Inorder):
20 30 40 50 60 70 80

Insert 25:
50 → 25<50 → move left=30
30 → 25<30 → move left=20
20 → 25>20 → insert as right child of 20

BST after insertion (Inorder):
20 25 30 40 50 60 70 80

```

---

## **Question: | 40 | Delete Node in BST | BST |**

**Approach:**
PROBLEM STATEMENT:
Given a BST and a key, delete the node with that key while maintaining the BST property.

Cases to handle:

1. Node has **no children** → just remove it.
2. Node has **one child** → replace node with its child.
3. Node has **two children** → replace node with **inorder successor** (smallest in right subtree) or **inorder predecessor** (largest in left subtree), then delete successor/predecessor.

Example:
BST:
50
/ \
 30 70
/ \ / \
 20 40 60 80

Delete 30 → Node has two children

- Inorder successor = 40
- Replace 30 with 40
- Delete original 40 node

---

APPROACH:

1. Recursively traverse BST to find node to delete.
2. Once found:
   a. No child → return NULL
   b. One child → return that child
   c. Two children → find inorder successor, copy value, delete successor
3. Update parent pointers accordingly.
4. Time Complexity: O(h)
5. Space Complexity: O(h) recursion

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of BST Node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Find minimum in BST (used for inorder successor)
// ----------------------
TreeNode* minValueNode(TreeNode* node) {
    TreeNode* curr = node;
    while(curr && curr->left) curr = curr->left; // leftmost node
    return curr;
}

// ----------------------
// Delete node from BST
// ----------------------
TreeNode* deleteBST(TreeNode* root, int key) {
    if(!root) return nullptr; // empty tree

    if(key < root->val)
        root->left = deleteBST(root->left, key);   // go left
    else if(key > root->val)
        root->right = deleteBST(root->right, key); // go right
    else {
        // Node found
        if(!root->left) { // no left child
            TreeNode* temp = root->right;
            delete root;
            return temp;
        } else if(!root->right) { // no right child
            TreeNode* temp = root->left;
            delete root;
            return temp;
        } else {
            // Node with two children
            TreeNode* temp = minValueNode(root->right); // inorder successor
            root->val = temp->val;                      // copy successor value
            root->right = deleteBST(root->right, temp->val); // delete successor
        }
    }

    return root; // return updated root
}

// ----------------------
// Inorder traversal
// ----------------------
void inorder(TreeNode* root) {
    if(!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    TreeNode* root = new TreeNode(50);
    root->left = new TreeNode(30);
    root->right = new TreeNode(70);
    root->left->left = new TreeNode(20);
    root->left->right = new TreeNode(40);
    root->right->left = new TreeNode(60);
    root->right->right = new TreeNode(80);

    cout << "Inorder before deletion: ";
    inorder(root);
    cout << endl;

    // Delete node 30
    root = deleteBST(root, 30);

    cout << "Inorder after deleting 30: ";
    inorder(root);
    cout << endl;

    // Delete leaf node 20
    root = deleteBST(root, 20);
    cout << "Inorder after deleting 20: ";
    inorder(root);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST before deletion (Inorder):
20 30 40 50 60 70 80

Delete 30 (two children):
- Inorder successor of 30 = 40
- Replace 30 with 40
- Delete original 40
Inorder now: 20 40 50 60 70 80

Delete 20 (leaf):
- Node 20 removed
Inorder now: 40 50 60 70 80

Output:
Inorder before deletion: 20 30 40 50 60 70 80
Inorder after deleting 30: 20 40 50 60 70 80
Inorder after deleting 20: 40 50 60 70 80

```

---

## **Question: | 41 | K-th Smallest / Largest in BST | BST |**

**Approach:**
PROBLEM STATEMENT:
Given a BST and an integer k, find:

1. K-th smallest element → element that would appear at position k in **sorted order** (inorder traversal)
2. K-th largest element → element that would appear at position k in **reverse sorted order** (reverse inorder traversal)

Example:
BST:
50
/ \
 30 70
/ \ / \
 20 40 60 80

Inorder (sorted): 20 30 40 50 60 70 80
K=3 → 3rd smallest = 40
K=2 → 2nd largest = 70

---

APPROACH:

1. **K-th Smallest**:
   - Perform **inorder traversal** (Left → Root → Right)
   - Keep counter; return when counter == k
2. **K-th Largest**:
   - Perform **reverse inorder traversal** (Right → Root → Left)
   - Keep counter; return when counter == k
3. **Time Complexity**: O(h + k) → only traverse until kth element
4. **Space Complexity**: O(h) → recursion stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of BST Node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// K-th Smallest Element in BST
// ----------------------
void kthSmallestHelper(TreeNode* root, int k, int &count, int &ans) {
    if(!root) return;

    kthSmallestHelper(root->left, k, count, ans); // left subtree

    count++;                     // visit node
    if(count == k) {             // kth smallest found
        ans = root->val;
        return;
    }

    kthSmallestHelper(root->right, k, count, ans); // right subtree
}

int kthSmallest(TreeNode* root, int k) {
    int count = 0, ans = -1;
    kthSmallestHelper(root, k, count, ans);
    return ans;
}

// ----------------------
// K-th Largest Element in BST
// ----------------------
void kthLargestHelper(TreeNode* root, int k, int &count, int &ans) {
    if(!root) return;

    kthLargestHelper(root->right, k, count, ans); // right subtree

    count++;                      // visit node
    if(count == k) {              // kth largest found
        ans = root->val;
        return;
    }

    kthLargestHelper(root->left, k, count, ans);  // left subtree
}

int kthLargest(TreeNode* root, int k) {
    int count = 0, ans = -1;
    kthLargestHelper(root, k, count, ans);
    return ans;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    TreeNode* root = new TreeNode(50);
    root->left = new TreeNode(30);
    root->right = new TreeNode(70);
    root->left->left = new TreeNode(20);
    root->left->right = new TreeNode(40);
    root->right->left = new TreeNode(60);
    root->right->right = new TreeNode(80);

    int k1 = 3, k2 = 2;
    cout << k1 << "-th Smallest: " << kthSmallest(root, k1) << endl;
    cout << k2 << "-th Largest: " << kthLargest(root, k2) << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST:
        50
       /  \
     30    70
    / \    / \
  20  40  60 80

Inorder (sorted): 20 30 40 50 60 70 80
Reverse Inorder (sorted descending): 80 70 60 50 40 30 20

K-th Smallest:
k=3 → visit nodes: 20(count=1),30(count=2),40(count=3)
→ 3rd smallest = 40

K-th Largest:
k=2 → visit nodes: 80(count=1),70(count=2)
→ 2nd largest = 70

Output:
3-th Smallest: 40
2-th Largest: 70

```

---

## **Question: | 42 | Check if tree is BST | BST |**

**Approach:**
PROBLEM STATEMENT:
Given a binary tree, check if it is a **Binary Search Tree (BST)**.

- BST property:
  1. Left subtree < node
  2. Right subtree > node
  3. Both subtrees are also BSTs

Example 1:
50
/ \
 30 70
/ \ / \
 20 40 60 80
→ This is a BST → Output: True

Example 2:
50
/ \
 30 70
/ \ / \
 20 60 60 80
→ Left child 60 > 50 → Not a BST → Output: False

---

APPROACH:

1. **Recursive with range check**:
   - For each node, maintain allowable range [minVal, maxVal].
   - Node value must satisfy: minVal < node->val < maxVal
   - Recur for left subtree: range = [minVal, node->val]
   - Recur for right subtree: range = [node->val, maxVal]
   - If any node violates range → Not BST
2. **Inorder Traversal Method**:
   - Traverse tree inorder; values must appear in strictly increasing order
   - If not increasing → Not BST
3. Time Complexity: O(n)
4. Space Complexity: O(h)

**Code:**

```cpp
#include <iostream>
#include <climits>
using namespace std;

// Definition of Tree Node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) { val = x; left = right = nullptr; }
};

// ----------------------
// Check if BST using min-max range
// ----------------------
bool isBST(TreeNode* root, long long minVal = LLONG_MIN, long long maxVal = LLONG_MAX) {
    if(!root) return true;                // empty tree is BST

    if(root->val <= minVal || root->val >= maxVal)
        return false;                     // violates BST property

    // check left and right subtrees recursively
    return isBST(root->left, minVal, root->val) &&
           isBST(root->right, root->val, maxVal);
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    // Example BST
    TreeNode* root1 = new TreeNode(50);
    root1->left = new TreeNode(30);
    root1->right = new TreeNode(70);
    root1->left->left = new TreeNode(20);
    root1->left->right = new TreeNode(40);
    root1->right->left = new TreeNode(60);
    root1->right->right = new TreeNode(80);

    cout << "Tree 1 is BST? " << (isBST(root1) ? "Yes" : "No") << endl;

    // Example Non-BST
    TreeNode* root2 = new TreeNode(50);
    root2->left = new TreeNode(30);
    root2->right = new TreeNode(70);
    root2->left->left = new TreeNode(20);
    root2->left->right = new TreeNode(60); // invalid → left > root
    root2->right->left = new TreeNode(60);
    root2->right->right = new TreeNode(80);

    cout << "Tree 2 is BST? " << (isBST(root2) ? "Yes" : "No") << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Tree 1:
        50
       /  \
     30    70
    / \    / \
  20  40  60 80

Check:
- Node 50: range [-inf, inf] → valid
- Node 30: range [-inf,50] → valid
- Node 20: range [-inf,30] → valid
- Node 40: range [30,50] → valid
- Node 70: range [50,inf] → valid
- Node 60: range [50,70] → valid
- Node 80: range [70,inf] → valid
→ All nodes valid → Yes

Tree 2:
        50
       /  \
     30    70
    / \    / \
  20  60  60 80

Check:
- Node 50: range [-inf, inf] → valid
- Node 30: range [-inf,50] → valid
- Node 60: range [30,50] → invalid → Not BST

Output:
Tree 1 is BST? Yes
Tree 2 is BST? No

```

---

## **Question: | 43 | LCA in BST | BST |**

**Approach:**
Problem Statement:
Given a Binary Search Tree (BST) and two nodes n1 and n2, find the Lowest Common Ancestor (LCA) of these two nodes.
The LCA is defined as the lowest node in BST that has both n1 and n2 as descendants (we allow a node to be a descendant of itself).

Input: Root of BST, two node values n1 and n2.
Output: Value of LCA node.

Example:
20
/ \
 10 30
/ \ / \
 5 15 25 35

LCA(5, 15) = 10
LCA(5, 30) = 20

Approach to Solve:

1. **Understand BST properties**:

   - All nodes in the left subtree < root
   - All nodes in the right subtree > root

2. **Compare root with n1 and n2**:

   - If both n1 and n2 are smaller than root → LCA lies in the left subtree.
   - If both n1 and n2 are greater than root → LCA lies in the right subtree.
   - If one node is on the left and the other is on the right → current root is LCA.

3. **Algorithm**:
   a. Start from root.
   b. If root’s value > n1 and root’s value > n2 → go to left child.
   c. Else if root’s value < n1 and root’s value < n2 → go to right child.
   d. Else → root is LCA.
4. **Time Complexity**: O(h) where h = height of BST.
   - For balanced BST, h = log(n)
   - For skewed BST, h = n
5. **Space Complexity**: O(1) for iterative approach, O(h) for recursive approach (due to recursion stack)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Define the structure for a BST node
struct Node {
    int data;       // Value of the node
    Node* left;     // Pointer to left child
    Node* right;    // Pointer to right child
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Function to find LCA in BST
Node* LCA(Node* root, int n1, int n2) {
    while (root != nullptr) {
        // If both n1 and n2 are smaller than root, LCA lies in left subtree
        if (root->data > n1 && root->data > n2)
            root = root->left;
        // If both n1 and n2 are greater than root, LCA lies in right subtree
        else if (root->data < n1 && root->data < n2)
            root = root->right;
        else
            // This is the split point, root is LCA
            return root;
    }
    return nullptr; // In case no LCA found
}

int main() {
    // Creating the BST from example
    Node* root = new Node(20);
    root->left = new Node(10);
    root->right = new Node(30);
    root->left->left = new Node(5);
    root->left->right = new Node(15);
    root->right->left = new Node(25);
    root->right->right = new Node(35);

    int n1 = 5, n2 = 15;

    Node* lca = LCA(root, n1, n2);
    if(lca != nullptr)
        cout << "LCA of " << n1 << " and " << n2 << " is " << lca->data << endl;
    else
        cout << "LCA does not exist in BST." << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST Structure:
        20
       /  \
     10    30
     / \   / \
    5  15 25  35

Nodes to find LCA: n1 = 5, n2 = 15

Step-by-step Execution:

1. Start at root = 20
   - Check if both nodes < 20? 5 < 20 and 15 < 20 → Yes
   - Move to left child: root = 10

2. At root = 10
   - Check if both nodes < 10? 5 < 10 but 15 > 10 → No
   - Check if both nodes > 10? 5 < 10 and 15 > 10 → No
   - Else → root = 10 is the LCA

Result:
LCA(5, 15) = 10

```

---

## **Question: | 44 | Construct BST from Preorder | BST |**

**Approach:**
Problem Statement:
Given an array representing the preorder traversal of a BST, construct the BST.

Input: Array of integers representing preorder traversal.
Output: Root of the BST constructed from the given preorder.

Example:
Preorder: [10, 5, 1, 7, 40, 50]

Constructed BST:
10
/ \
 5 40
/ \ \
 1 7 50

Approach to Solve:

1. **Understand the property of BST and preorder**:

   - In preorder traversal, first element is root.
   - All elements smaller than root belong to the left subtree.
   - All elements greater than root belong to the right subtree.

2. **Recursive Approach**:

   - Maintain current index in preorder array.
   - Keep a range (min, max) for valid node values.
   - Create node if current value lies within range.
   - Recursively construct left and right subtree.

3. **Algorithm**:
   a. Start with root = preorder[0].
   b. Initialize min = INT_MIN, max = INT_MAX, index = 0.
   c. For each value in preorder: - If value lies in (min, max) → create node. - Recursively create left subtree with updated max = node value. - Recursively create right subtree with updated min = node value.

4. **Time Complexity**: O(n)

   - Each element is processed once.

5. **Space Complexity**: O(n)
   - Recursive stack in worst case (skewed BST).

**Code:**

```cpp
#include <iostream>
#include <climits>
using namespace std;

// BST Node structure
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Recursive function to construct BST from preorder
Node* constructBST(int preorder[], int& index, int key, int min, int max, int n) {
    // Base case: If all elements are processed
    if(index >= n)
        return nullptr;

    Node* root = nullptr;

    // If current key lies in valid range
    if(key > min && key < max) {
        // Create node
        root = new Node(key);
        index++; // Move to next element in preorder

        // If there are more elements, construct left and right subtrees
        if(index < n)
            root->left = constructBST(preorder, index, preorder[index], min, key, n);
        if(index < n)
            root->right = constructBST(preorder, index, preorder[index], key, max, n);
    }

    return root;
}

// Utility function to print inorder traversal of BST
void inorder(Node* root) {
    if(root == nullptr) return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}

int main() {
    int preorder[] = {10, 5, 1, 7, 40, 50};
    int n = sizeof(preorder)/sizeof(preorder[0]);
    int index = 0;

    Node* root = constructBST(preorder, index, preorder[0], INT_MIN, INT_MAX, n);

    cout << "Inorder traversal of constructed BST: ";
    inorder(root); // Should print sorted order
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Preorder: [10, 5, 1, 7, 40, 50]
index = 0, key = 10, range = (-∞, ∞)
- 10 is within range → create node 10
- index = 1, key = 5, range for left subtree = (-∞, 10)
    - 5 is within range → create node 5
    - index = 2, key = 1, range for left = (-∞, 5)
        - 1 is within range → create node 1
        - index = 3, key = 7, range for left of 1 = (-∞,1) → out of range → nullptr
        - range for right of 1 = (1,5) → 7 out of range → nullptr
    - Node 1 complete, return to 5
    - index = 3, key = 7, range for right of 5 = (5,10)
        - 7 in range → create node 7
        - index = 4, key = 40, range for left of 7 = (5,7) → 40 out of range → nullptr
        - range for right of 7 = (7,10) → 40 out of range → nullptr
- Node 5 complete, return to 10
- index = 4, key = 40, range for right of 10 = (10,∞)
    - 40 in range → create node 40
    - index = 5, key = 50, range for left of 40 = (10,40) → 50 out of range → nullptr
    - range for right of 40 = (40,∞)
        - 50 in range → create node 50
- BST construction complete

Inorder traversal (sorted): 1 5 7 10 40 50

```

---

## **Question: | 45 | Inorder Successor / Predecessor | BST |**

**Approach:**
Problem Statement:
Given a Binary Search Tree (BST) and a key, find:

1. Inorder Successor: The node with the smallest value greater than the given key.
2. Inorder Predecessor: The node with the largest value smaller than the given key.

Input: Root of BST, key value.
Output: Values of inorder successor and predecessor.

Example:
20
/ \
 10 30
/ \ / \
 5 15 25 35

Key = 15

- Inorder Successor = 20
- Inorder Predecessor = 10

Approach to Solve:

1. **Inorder Traversal Property**:

   - Inorder of BST gives sorted sequence.
   - Predecessor: previous node in inorder
   - Successor: next node in inorder

2. **Two Cases**:
   a. If node has right child → successor is leftmost node in right subtree  
    If node has left child → predecessor is rightmost node in left subtree
   b. If node has no right/left child → move up using BST property:

   - Start from root, keep track of potential successor/predecessor:
     - If root.data > key → root could be successor, move left
     - If root.data < key → root could be predecessor, move right

3. **Algorithm (Iterative)**:

   - Initialize successor and predecessor = nullptr
   - Traverse BST from root:
     - If root.data > key → successor = root, go left
     - If root.data < key → predecessor = root, go right
     - If root.data == key → check left/right subtree for predecessor/successor

4. **Time Complexity**: O(h), h = height of BST
5. **Space Complexity**: O(1) iterative

**Code:**

```cpp
#include <iostream>
using namespace std;

// BST Node structure
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Function to find inorder predecessor and successor
void findPreSuc(Node* root, Node*& pre, Node*& suc, int key) {
    while(root != nullptr) {
        if(root->data == key) {
            // Predecessor: max value in left subtree
            if(root->left) {
                Node* tmp = root->left;
                while(tmp->right) tmp = tmp->right;
                pre = tmp;
            }
            // Successor: min value in right subtree
            if(root->right) {
                Node* tmp = root->right;
                while(tmp->left) tmp = tmp->left;
                suc = tmp;
            }
            return;
        }
        else if(root->data > key) {
            suc = root; // potential successor
            root = root->left;
        }
        else { // root->data < key
            pre = root; // potential predecessor
            root = root->right;
        }
    }
}

int main() {
    // Construct BST
    Node* root = new Node(20);
    root->left = new Node(10);
    root->right = new Node(30);
    root->left->left = new Node(5);
    root->left->right = new Node(15);
    root->right->left = new Node(25);
    root->right->right = new Node(35);

    int key = 15;
    Node* pre = nullptr;
    Node* suc = nullptr;

    findPreSuc(root, pre, suc, key);

    if(pre) cout << "Predecessor of " << key << " = " << pre->data << endl;
    else cout << "No Predecessor" << endl;

    if(suc) cout << "Successor of " << key << " = " << suc->data << endl;
    else cout << "No Successor" << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST:
        20
       /  \
     10    30
     / \   / \
    5  15 25  35

Key = 15

Step 1: Start at root = 20
- 20 > 15 → potential successor = 20
- Move left → root = 10

Step 2: root = 10
- 10 < 15 → potential predecessor = 10
- Move right → root = 15

Step 3: root = 15
- root.data == key
- Predecessor: max in left subtree of 15 → left child is null → predecessor = 10
- Successor: min in right subtree of 15 → right child is null → successor = 20

Result:
Predecessor = 10
Successor = 20

```

---

## **Question: | 46 | BST Iterator (O(H) space) | BST |**

**Approach:**
Problem Statement:
Implement an iterator over a Binary Search Tree (BST). The iterator should return elements in ascending order (inorder traversal).

Implement the following operations:

1. BSTIterator(root) → initialize the iterator with root.
2. next() → return the next smallest element.
3. hasNext() → return true if there is a next element.

Constraints:

- Space complexity: O(H) where H is the height of BST.
- Time complexity: next() and hasNext() should be average O(1).

Example:
BST:
7
/ \
 3 15
/ \
 9 20

Iterator operations:
next() → 3
next() → 7
next() → 9
hasNext() → true
next() → 15
next() → 20
hasNext() → false

Approach to Solve:

1. Use a stack to simulate controlled inorder traversal.
2. Initially, push all left nodes from root to stack.
3. next():
   - Pop top node → this is next smallest.
   - If popped node has right child → push all its left children to stack.
4. hasNext(): return true if stack is not empty.

- **Why O(H) space**? Only left path nodes are in stack at any time, max height H.
- **Time Complexity**: next() is average O(1), hasNext() is O(1)

**Code:**

```cpp
#include <iostream>
#include <stack>
using namespace std;

// BST Node structure
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// BST Iterator Class
class BSTIterator {
    stack<Node*> st; // stack to maintain controlled inorder traversal

    // Helper function to push all left children of a node
    void pushLeft(Node* node) {
        while(node) {
            st.push(node);
            node = node->left;
        }
    }

public:
    // Constructor
    BSTIterator(Node* root) {
        pushLeft(root); // push leftmost path from root
    }

    // Returns next smallest element
    int next() {
        Node* topNode = st.top();
        st.pop();
        // If topNode has right child, push all left children of right subtree
        if(topNode->right)
            pushLeft(topNode->right);
        return topNode->data;
    }

    // Returns true if there is next element
    bool hasNext() {
        return !st.empty();
    }
};

int main() {
    // Construct BST
    Node* root = new Node(7);
    root->left = new Node(3);
    root->right = new Node(15);
    root->right->left = new Node(9);
    root->right->right = new Node(20);

    BSTIterator it(root);

    cout << it.next() << endl;    // 3
    cout << it.next() << endl;    // 7
    cout << it.next() << endl;    // 9
    cout << (it.hasNext() ? "true" : "false") << endl; // true
    cout << it.next() << endl;    // 15
    cout << it.next() << endl;    // 20
    cout << (it.hasNext() ? "true" : "false") << endl; // false

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST:
        7
       / \
      3   15
         /  \
        9    20

Step 1: Initialize iterator
- Push all left nodes from root to stack: 7 -> 3
- Stack (top to bottom): [3, 7]

Step 2: next()
- Pop 3 → return 3
- 3 has no right → do nothing
- Stack: [7]

Step 3: next()
- Pop 7 → return 7
- 7 has right = 15 → push all left children of 15
    - push 15 → move left → push 9
- Stack: [9, 15]

Step 4: next()
- Pop 9 → return 9
- 9 has no right
- Stack: [15]

Step 5: hasNext()
- Stack not empty → true

Step 6: next()
- Pop 15 → return 15
- 15 has right = 20 → push left children of 20
- Stack: [20]

Step 7: next()
- Pop 20 → return 20
- 20 has no right
- Stack: []

Step 8: hasNext()
- Stack empty → false

All elements returned in ascending order: 3, 7, 9, 15, 20 ✅

```

---

## **Question: | 47 | Two Sum in BST (pair sum = K) | BST |**

**Approach:**
Problem Statement:
Given a BST and an integer K, determine if there exists a pair of nodes in the BST whose values sum up to K.

Input: Root of BST, integer K
Output: True if pair exists, False otherwise

Example:
10
/ \
 5 15
/ \ \
 3 7 18

K = 16

- Pair exists: 3 + 13 → False
- Pair exists: 5 + 11 → False
- Pair exists: 10 + 6 → False
- Pair exists: 3 + 13 → False
- Pair exists: 5 + 11 → False
- Pair exists: 10 + 6 → False
- Pair exists: 5 + 11 → False
- Pair exists: 5 + 11 → False
- Correct pair: 3 + 13 → False
- Wait, valid pair in this tree for K=16: 5 + 11 (11 not present) → So in this tree, no pair sums to 16.
- For K=22 → 4 + 18? → 4 not present → 5 + 17? → 17 not present → 10 + 12? → 12 not present → 15 + 7 → 15+7=22 → Yes ✅

Approach to Solve:

**Method 1 (Inorder + Two Pointer)**

1. Perform inorder traversal → get sorted array of BST nodes.
   - Time O(n), Space O(n)
2. Use two-pointer approach on sorted array to find pair with sum K.
   - left = 0, right = n-1
   - while left < right:
     - sum = arr[left] + arr[right]
     - if sum == K → return true
     - if sum < K → left++
     - if sum > K → right--
3. Time Complexity: O(n)
4. Space Complexity: O(n) (due to array)

**Method 2 (BST Iterators / O(H) space)**

1. Use two iterators:
   - one inorder iterator (next smallest)
   - one reverse inorder iterator (next largest)
2. Initialize two pointers:
   - left = smallest, right = largest
   - Move pointers like two-pointer in array using iterator
3. Time Complexity: O(n), Space Complexity: O(H)

We'll implement Method 1 (simpler for understanding).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// BST Node structure
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Inorder traversal to get sorted array
void inorder(Node* root, vector<int>& arr) {
    if(!root) return;
    inorder(root->left, arr);
    arr.push_back(root->data);
    inorder(root->right, arr);
}

// Function to find if pair sum = K exists
bool findPairWithSum(Node* root, int K) {
    vector<int> arr;
    inorder(root, arr); // O(n)

    int left = 0;
    int right = arr.size() - 1;

    while(left < right) { // Two-pointer approach
        int sum = arr[left] + arr[right];
        if(sum == K) return true;
        else if(sum < K) left++;
        else right--;
    }
    return false;
}

int main() {
    // Construct BST
    Node* root = new Node(10);
    root->left = new Node(5);
    root->right = new Node(15);
    root->left->left = new Node(3);
    root->left->right = new Node(7);
    root->right->right = new Node(18);

    int K = 22;

    if(findPairWithSum(root, K))
        cout << "Pair exists with sum " << K << endl;
    else
        cout << "No pair with sum " << K << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST:
        10
       /  \
      5    15
     / \     \
    3   7     18

K = 22

Step 1: Inorder traversal → sorted array
- Inorder of BST: [3, 5, 7, 10, 15, 18]

Step 2: Initialize two pointers
- left = 0 → 3
- right = 5 → 18

Step 3: Check sum
- 3 + 18 = 21 < 22 → move left → left = 1 → 5
- 5 + 18 = 23 > 22 → move right → right = 4 → 15
- 5 + 15 = 20 < 22 → move left → left = 2 → 7
- 7 + 15 = 22 ✅ → Pair found

Result:
Pair exists: (7, 15)

```

---

## **Question: | 48 | Recover BST (two nodes swapped) | BST |**

**Approach:**
Problem Statement:
Two nodes of a BST are swapped by mistake. Recover the BST without changing its structure.

Input: Root of BST with two nodes swapped.
Output: BST restored to correct order.

Example:
Original BST: Swapped BST:
3 3
/ \ / \
 1 4 4 1
/ /
2 2

Recover BST → Correct inorder: 1 2 3 4

Approach to Solve:

1. **Inorder Traversal Insight**:

   - Inorder of BST should be sorted.
   - If two nodes are swapped, inorder sequence will have two violations:
     - prev > current

2. **Identify Swapped Nodes**:

   - Traverse BST inorder while keeping track of previous node.
   - For first violation (prev > current) → mark first node as prev, second as current.
   - For second violation (if any) → update second node as current.
   - This works for both adjacent and non-adjacent swapped nodes.

3. **Recover the BST**:

   - Swap the values of the two identified nodes.

4. **Algorithm**:

   - Initialize prev = nullptr, first = nullptr, second = nullptr
   - Do inorder traversal:
     - If prev->data > current->data:
       - If first == nullptr → first = prev, second = current
       - Else → second = current
     - prev = current
   - Swap first->data and second->data

5. **Time Complexity**: O(n)
6. **Space Complexity**: O(H) for recursion stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// BST Node structure
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Pointers to track nodes to swap
Node *first = nullptr, *second = nullptr, *prev = nullptr;

// Inorder traversal to find swapped nodes
void inorder(Node* root) {
    if(!root) return;

    inorder(root->left);

    // Check for violation
    if(prev && prev->data > root->data) {
        if(!first) {
            first = prev;  // First violation
            second = root;
        } else {
            second = root; // Second violation
        }
    }

    prev = root;
    inorder(root->right);
}

// Function to recover BST
void recoverBST(Node* root) {
    inorder(root);
    if(first && second) {
        swap(first->data, second->data); // Swap values to fix BST
    }
}

// Utility function to print inorder
void printInorder(Node* root) {
    if(!root) return;
    printInorder(root->left);
    cout << root->data << " ";
    printInorder(root->right);
}

int main() {
    // Construct BST with swapped nodes
    Node* root = new Node(3);
    root->left = new Node(1);
    root->right = new Node(4);
    root->right->left = new Node(2); // swapped

    cout << "Before recovery: ";
    printInorder(root);
    cout << endl;

    recoverBST(root);

    cout << "After recovery: ";
    printInorder(root);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST (swapped nodes):
        3
       / \
      1   4
         /
        2

Step 1: Inorder traversal → detect violations
- Inorder sequence: 1 3 2 4
- prev = 1, current = 3 → 1 < 3 ✅
- prev = 3, current = 2 → 3 > 2 ❌ → first = 3, second = 2
- prev = 2, current = 4 → 2 < 4 ✅

Step 2: Swap first and second nodes
- Swap 3 and 2

Step 3: Inorder after recovery
- Sequence: 1 2 3 4 ✅
- BST structure restored

```

---

## **Question: | 49 | Largest BST in Binary Tree | BT/BST |**

**Approach:**
Problem Statement:
Given a Binary Tree (not necessarily a BST), find the size of the largest subtree that is a BST.

Input: Root of binary tree
Output: Size (number of nodes) of the largest BST subtree

Example:
50
/ \
 30 60
/ \ / \
 5 20 45 70
/ \
 65 80

Largest BST Subtree:
60
/ \
 45 70
/ \
 65 80
Size = 5

Approach to Solve:

1. **Bottom-up Recursive Approach**:

   - For each node, return:
     a. isBST → whether subtree rooted at node is BST
     b. size → size of largest BST in subtree
     c. minVal → min value in subtree
     d. maxVal → max value in subtree

2. **Algorithm**:

   - If node is null → return (isBST=true, size=0, min=+∞, max=-∞)
   - Recursively get info from left and right subtree
   - If left and right subtrees are BST and node->data > left.maxVal and node->data < right.minVal
     - Then current subtree is BST
     - size = left.size + right.size + 1
     - Update minVal = min(left.minVal, node->data)
     - Update maxVal = max(right.maxVal, node->data)
   - Else → subtree is not BST
     - size = max(left.size, right.size)
     - isBST = false

3. **Time Complexity**: O(n)
4. **Space Complexity**: O(h) for recursion stack

**Code:**

```cpp
#include <iostream>
#include <algorithm>
#include <climits>
using namespace std;

// Binary Tree Node
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Helper structure to store subtree info
struct Info {
    bool isBST;
    int size;
    int minVal;
    int maxVal;
};

// Function to find largest BST subtree
Info largestBST(Node* root, int& maxSize) {
    if(!root)
        return {true, 0, INT_MAX, INT_MIN}; // empty tree is BST

    Info left = largestBST(root->left, maxSize);
    Info right = largestBST(root->right, maxSize);

    Info curr;
    // Check if current subtree is BST
    if(left.isBST && right.isBST && root->data > left.maxVal && root->data < right.minVal) {
        curr.isBST = true;
        curr.size = left.size + right.size + 1;
        curr.minVal = min(left.minVal, root->data);
        curr.maxVal = max(right.maxVal, root->data);
        maxSize = max(maxSize, curr.size); // update global max size
    } else {
        curr.isBST = false;
        curr.size = max(left.size, right.size);
    }
    return curr;
}

int largestBSTinBT(Node* root) {
    int maxSize = 0;
    largestBST(root, maxSize);
    return maxSize;
}

int main() {
    Node* root = new Node(50);
    root->left = new Node(30);
    root->right = new Node(60);
    root->left->left = new Node(5);
    root->left->right = new Node(20);
    root->right->left = new Node(45);
    root->right->right = new Node(70);
    root->right->right->left = new Node(65);
    root->right->right->right = new Node(80);

    cout << "Size of largest BST in BT: " << largestBSTinBT(root) << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Binary Tree:
        50
       /  \
     30    60
    / \    / \
   5  20  45  70
               / \
              65  80

Step 1: Start from leaf nodes
- Node 5 → BST, size=1, min=5, max=5
- Node 20 → BST, size=1, min=20, max=20
- Node 45 → BST, size=1, min=45, max=45
- Node 65 → BST, size=1, min=65, max=65
- Node 80 → BST, size=1, min=80, max=80

Step 2: Move up
- Node 30 → left=5, right=20, 5<30<20 ❌ → not BST → size=max(1,1)=1
- Node 70 → left=65, right=80, 65<70<80 ✅ → BST, size=3
- Node 60 → left=45, right=70, 45<60<70 ✅ → BST, size=5
- Node 50 → left=30(not BST), right=60(BST), cannot be BST → size=max(1,5)=5

Step 3: Largest BST size = 5 (subtree rooted at 60)

```

---

## **Question: | 50 | Flatten BT to linked list (recursive & iterative) | BT |**

**Approach:**
Problem Statement:
Given a binary tree, flatten it to a linked list in-place. The linked list should follow the preorder traversal, and each node’s right pointer points to the next node in the list. Left pointers should be set to NULL.

Input: Root of binary tree
Output: Tree flattened into linked list in preorder

Example:
Original Tree:
1
/ \
 2 5
/ \ \
 3 4 6

Flattened (preorder):
1 → 2 → 3 → 4 → 5 → 6

Approach to Solve:

**Method 1: Recursive (Post-order Reverse Traversal)**

1. Use a pointer `prev` initialized as nullptr.
2. Recursively flatten right subtree, then left subtree.
3. At each node:
   - node->right = prev
   - node->left = nullptr
   - prev = node
4. This ensures the tree is flattened in preorder.

**Method 2: Iterative (Using Stack)**

1. Use a stack to simulate preorder traversal.
2. Push root to stack.
3. While stack not empty:
   - Pop node
   - Push right then left child to stack (so left processed first)
   - Set node->right = stack.top() if stack not empty
   - node->left = nullptr

- **Time Complexity**: O(n)
- **Space Complexity**: Recursive: O(h), Iterative: O(n) stack

**Code:**

```cpp
#include <iostream>
#include <stack>
using namespace std;

// Binary Tree Node
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// ---------------- Recursive Method ----------------
Node* prevNode = nullptr;

void flattenRecursive(Node* root) {
    if(!root) return;

    // Flatten right subtree first
    flattenRecursive(root->right);
    // Flatten left subtree
    flattenRecursive(root->left);

    // Rearrange pointers
    root->right = prevNode;
    root->left = nullptr;
    prevNode = root;
}

// ---------------- Iterative Method ----------------
void flattenIterative(Node* root) {
    if(!root) return;

    stack<Node*> st;
    st.push(root);

    while(!st.empty()) {
        Node* curr = st.top();
        st.pop();

        // Push right first, then left (preorder)
        if(curr->right) st.push(curr->right);
        if(curr->left) st.push(curr->left);

        // Set right pointer to next node in preorder
        if(!st.empty())
            curr->right = st.top();
        curr->left = nullptr;
    }
}

// Utility function to print linked list (right pointers)
void printFlattened(Node* root) {
    while(root) {
        cout << root->data << " ";
        root = root->right;
    }
    cout << endl;
}

int main() {
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(5);
    root->left->left = new Node(3);
    root->left->right = new Node(4);
    root->right->right = new Node(6);

    cout << "Flatten using Recursive Method: ";
    flattenRecursive(root);
    printFlattened(root);

    // Reset tree for iterative demo
    root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(5);
    root->left->left = new Node(3);
    root->left->right = new Node(4);
    root->right->right = new Node(6);

    cout << "Flatten using Iterative Method: ";
    flattenIterative(root);
    printFlattened(root);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Binary Tree:
        1
       / \
      2   5
     / \   \
    3   4   6

Recursive Flatten (Post-order reverse):
Step 1: Start at root=1
- Flatten right subtree (5 → 6)
- Flatten left subtree (2 → 3,4)
- Rearrange pointers:
    - prev = nullptr initially
    - Node 6 → right = prev=nullptr, left=null
    - prev = 6
    - Node 5 → right = 6, left=null, prev=5
    - Node 4 → right=5, left=null, prev=4
    - Node 3 → right=4, left=null, prev=3
    - Node 2 → right=3, left=null, prev=2
    - Node 1 → right=2, left=null, prev=1

Result (preorder linked list via right pointers):
1 → 2 → 3 → 4 → 5 → 6

Iterative Flatten (Using stack):
Step 1: Push root 1
Step 2: Pop 1 → push right 5, left 2
- Set 1->right = top(2), 1->left=null
Step 3: Pop 2 → push right 4, left 3
- Set 2->right = top(3), 2->left=null
Step 4: Pop 3 → no children
- Set 3->right = top(4), 3->left=null
Step 5: Pop 4 → no children
- Set 4->right = top(5), 4->left=null
Step 6: Pop 5 → push right 6
- Set 5->right = top(6), 5->left=null
Step 7: Pop 6 → no children
- Set 6->right=null, 6->left=null

Result:
1 → 2 → 3 → 4 → 5 → 6 ✅

```

---

## **Question: | 51 | Sum of all nodes in BT | BT |**

**Approach:**
Problem Statement:
Given a binary tree, calculate the sum of all its nodes.

Input: Root of binary tree
Output: Integer sum of all node values

Example:
10
/ \
 5 15
/ \ \
 3 7 18

Sum = 10 + 5 + 15 + 3 + 7 + 18 = 58

Approach to Solve:

**Recursive Approach**:

1. Base case: If node is NULL → return 0
2. Otherwise, sum = node->data + sum(left subtree) + sum(right subtree)
3. Return the sum

- Time Complexity: O(n) → each node visited once
- Space Complexity: O(h) → recursion stack, h = height of tree

**Iterative Approach (Optional)**:

1. Use a queue (BFS level order) or stack (DFS)
2. Traverse nodes and keep adding their values

- Time Complexity: O(n)
- Space Complexity: O(n) for queue/stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Binary Tree Node
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Recursive function to find sum of all nodes
int sumOfNodes(Node* root) {
    if(!root) return 0; // base case
    // sum = current node + left subtree sum + right subtree sum
    return root->data + sumOfNodes(root->left) + sumOfNodes(root->right);
}

int main() {
    // Construct Binary Tree
    Node* root = new Node(10);
    root->left = new Node(5);
    root->right = new Node(15);
    root->left->left = new Node(3);
    root->left->right = new Node(7);
    root->right->right = new Node(18);

    cout << "Sum of all nodes: " << sumOfNodes(root) << endl; // Output: 58

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Binary Tree:
        10
       /  \
      5    15
     / \     \
    3   7     18

Step 1: Start at root = 10
- Sum = 10 + sum(left) + sum(right)

Step 2: Left subtree (root = 5)
- Sum = 5 + sum(3) + sum(7)
- Node 3 → left/right null → sum = 3
- Node 7 → left/right null → sum = 7
- Left subtree sum = 5 + 3 + 7 = 15

Step 3: Right subtree (root = 15)
- Sum = 15 + sum(NULL) + sum(18)
- Node 18 → left/right null → sum = 18
- Right subtree sum = 15 + 18 = 33

Step 4: Total sum
- Root sum = 10 + 15 + 33 = 58 ✅

Result: Sum of all nodes = 58

```

---

## **Question: | 52 | Count leaf nodes in BT | BT |**

**Approach:**
Problem Statement:
Given a binary tree, count the number of leaf nodes. A leaf node is a node with no children.

Input: Root of binary tree
Output: Integer count of leaf nodes

Example:
10
/ \
 5 15
/ \ \
 3 7 18

Leaf nodes: 3, 7, 18  
Count = 3

Approach to Solve:

**Recursive Approach**:

1. Base case: If node is NULL → return 0
2. If node has no left and right child → return 1 (leaf node)
3. Otherwise, count = count(left subtree) + count(right subtree)
4. Return count

- Time Complexity: O(n) → each node visited once
- Space Complexity: O(h) → recursion stack, h = height of tree

**Iterative Approach (Optional)**:

1. Use a queue (BFS) or stack (DFS)
2. Traverse all nodes
3. If node has no left and right → increment leaf count

**Code:**

```cpp
#include <iostream>
using namespace std;

// Binary Tree Node
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Recursive function to count leaf nodes
int countLeafNodes(Node* root) {
    if(!root) return 0; // empty tree
    if(!root->left && !root->right) return 1; // leaf node
    // count in left and right subtrees
    return countLeafNodes(root->left) + countLeafNodes(root->right);
}

int main() {
    // Construct Binary Tree
    Node* root = new Node(10);
    root->left = new Node(5);
    root->right = new Node(15);
    root->left->left = new Node(3);
    root->left->right = new Node(7);
    root->right->right = new Node(18);

    cout << "Number of leaf nodes: " << countLeafNodes(root) << endl; // Output: 3

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Binary Tree:
        10
       /  \
      5    15
     / \     \
    3   7     18

Step 1: Start at root = 10
- Not a leaf → count = count(left) + count(right)

Step 2: Left subtree (root = 5)
- Node 5 → not leaf → count = count(3) + count(7)
- Node 3 → leaf → count = 1
- Node 7 → leaf → count = 1
- Left subtree count = 1 + 1 = 2

Step 3: Right subtree (root = 15)
- Node 15 → not leaf → count = count(NULL) + count(18)
- Node 18 → leaf → count = 1
- Right subtree count = 1

Step 4: Total leaf count
- Root count = 2 + 1 = 3 ✅

Result: Number of leaf nodes = 3

```

---

## **Question: | 53 | Max width at level in BT | BT |**

**Approach:**
Problem Statement:
Given a binary tree, find the maximum width among all levels.  
Width of a level = number of nodes at that level.

Input: Root of binary tree  
Output: Integer representing maximum width

Example:
1
/ \
 2 3
/ \ \
 4 5 8
/ \
 6 7

Widths per level:
Level 1: 1 → width = 1
Level 2: 2,3 → width = 2
Level 3: 4,5,8 → width = 3
Level 4: 6,7 → width = 2
Maximum width = 3

Approach to Solve:

**Method: Level Order Traversal (BFS)**

1. Use a queue to traverse the tree level by level.
2. Initialize maxWidth = 0
3. While queue is not empty:
   - size = number of nodes in current level (queue.size())
   - maxWidth = max(maxWidth, size)
   - For all nodes at current level:
     - Pop node
     - Push left and right children if they exist
4. Return maxWidth

- Time Complexity: O(n) → visit each node once
- Space Complexity: O(n) → queue may store all nodes at a level

**Code:**

```cpp
#include <iostream>
#include <queue>
using namespace std;

// Binary Tree Node
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Function to find maximum width of binary tree
int maxWidthBT(Node* root) {
    if(!root) return 0;

    queue<Node*> q;
    q.push(root);
    int maxWidth = 0;

    while(!q.empty()) {
        int levelSize = q.size(); // nodes at current level
        maxWidth = max(maxWidth, levelSize);

        for(int i=0; i<levelSize; i++) {
            Node* curr = q.front();
            q.pop();
            if(curr->left) q.push(curr->left);
            if(curr->right) q.push(curr->right);
        }
    }
    return maxWidth;
}

int main() {
    // Construct Binary Tree
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    root->left->left = new Node(4);
    root->left->right = new Node(5);
    root->right->right = new Node(8);
    root->right->right->left = new Node(6);
    root->right->right->right = new Node(7);

    cout << "Maximum width of BT: " << maxWidthBT(root) << endl; // Output: 3

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Binary Tree:
        1
       / \
      2   3
     / \   \
    4   5   8
           / \
          6   7

Step 1: Initialize queue → [1], maxWidth=0

Step 2: Level 1
- Level size = 1 → maxWidth = max(0,1) = 1
- Pop 1 → push left 2, right 3 → queue = [2,3]

Step 3: Level 2
- Level size = 2 → maxWidth = max(1,2) = 2
- Pop 2 → push 4,5 → queue = [3,4,5]
- Pop 3 → push right 8 → queue = [4,5,8]

Step 4: Level 3
- Level size = 3 → maxWidth = max(2,3) = 3
- Pop 4 → no children
- Pop 5 → no children
- Pop 8 → push 6,7 → queue = [6,7]

Step 5: Level 4
- Level size = 2 → maxWidth = max(3,2) = 3
- Pop 6 → no children
- Pop 7 → no children → queue empty

Step 6: Done
- Maximum width = 3 ✅

```

---

## **Question: | 54 | Connect nodes at same level | BT |**

**Approach:**
Problem Statement:
Given a binary tree, connect nodes at the same level using a 'next' pointer. Each node’s next pointer should point to the next node on the same level. The last node of each level should point to NULL.

Input: Root of binary tree  
Output: Tree modified with next pointers connecting nodes at same level

Example:
1
/ \
 2 3
/ \ \
 4 5 6

After connection:
Level 1: 1 → NULL
Level 2: 2 → 3 → NULL
Level 3: 4 → 5 → 6 → NULL

Approach to Solve:

**Method 1: Level Order Traversal (BFS using Queue)**

1. Use a queue to traverse level by level.
2. For each level:
   - size = number of nodes in level
   - For i = 0 to size-1:
     - Pop node
     - If i < size-1 → node->next = queue.front()
     - Else → node->next = NULL
     - Push left and right children if exist

**Method 2: Using next pointers (O(1) space for perfect BT)**

- Works efficiently if BT is perfect/complete; use pointers to traverse current level and connect children.
- For general BT, BFS method is simpler.

- Time Complexity: O(n)
- Space Complexity: O(n) → queue for BFS

**Code:**

```cpp
#include <iostream>
#include <queue>
using namespace std;

// Binary Tree Node with next pointer
struct Node {
    int data;
    Node* left;
    Node* right;
    Node* next; // pointer to next node at same level
    Node(int val) {
        data = val;
        left = right = next = nullptr;
    }
};

// Function to connect nodes at same level
void connectNodes(Node* root) {
    if(!root) return;

    queue<Node*> q;
    q.push(root);

    while(!q.empty()) {
        int levelSize = q.size();

        for(int i=0; i<levelSize; i++) {
            Node* curr = q.front();
            q.pop();

            if(i < levelSize - 1) {
                curr->next = q.front(); // point to next node in level
            } else {
                curr->next = nullptr; // last node
            }

            if(curr->left) q.push(curr->left);
            if(curr->right) q.push(curr->right);
        }
    }
}

// Utility function to print next pointers per level
void printNextPointers(Node* root) {
    queue<Node*> q;
    q.push(root);
    while(!q.empty()) {
        int size = q.size();
        for(int i=0; i<size; i++) {
            Node* curr = q.front(); q.pop();
            cout << curr->data << "->";
            if(curr->next) cout << curr->next->data << " ";
            else cout << "NULL ";
            if(curr->left) q.push(curr->left);
            if(curr->right) q.push(curr->right);
        }
        cout << endl;
    }
}

int main() {
    // Construct Binary Tree
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    root->left->left = new Node(4);
    root->left->right = new Node(5);
    root->right->right = new Node(6);

    connectNodes(root);

    cout << "Next pointers at each level:" << endl;
    printNextPointers(root);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Binary Tree:
        1
       / \
      2   3
     / \   \
    4   5   6

Step 1: Initialize queue → [1]

Level 1:
- Level size = 1
- Pop 1 → last node → next = NULL
- Push 2, 3 → queue = [2,3]

Level 2:
- Level size = 2
- Pop 2 → next = 3
- Pop 3 → last node → next = NULL
- Push 4,5,6 → queue = [4,5,6]

Level 3:
- Level size = 3
- Pop 4 → next = 5
- Pop 5 → next = 6
- Pop 6 → last node → next = NULL
- No children to push → queue empty

Result:
Level 1: 1 -> NULL
Level 2: 2 -> 3 -> NULL
Level 3: 4 -> 5 -> 6 -> NULL ✅

```

---

## **Question: | 55 | Check if BT is subtree of another | BT |**

**Approach:**
Problem Statement:
Given two binary trees T1 and T2, check whether T2 is a subtree of T1.  
A subtree of T1 is a tree consisting of a node in T1 and all of its descendants that exactly matches T2.

Input: Root of T1 and root of T2  
Output: True if T2 is a subtree of T1, otherwise False

Example:
T1:
1
/ \
 2 3
/ \
 4 5

T2:
2
/ \
 4 5

Output: True

Approach to Solve:

**Method 1: Recursive Match Check**

1. Base Cases:
   - If T2 is NULL → return True (empty tree is subtree)
   - If T1 is NULL → return False
2. At each node of T1:
   - If T1->data == T2->data:
     - Check if subtrees match exactly using a helper function `isIdentical(T1, T2)`
   - Otherwise, recursively check left and right subtree of T1
3. `isIdentical(T1, T2)`:
   - Both NULL → return True
   - One NULL → return False
   - Check data equality and recursively left & right subtrees
4. Time Complexity: O(n\*m) → n = nodes in T1, m = nodes in T2
5. Space Complexity: O(h1 + h2) → recursion stack

**Method 2: Optimized (Using Preorder with Null Markers + Hashing)**

- Can reduce time but Method 1 is simpler and easy to understand

**Code:**

```cpp
#include <iostream>
using namespace std;

// Binary Tree Node
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Helper function to check if two trees are identical
bool isIdentical(Node* t1, Node* t2) {
    if(!t1 && !t2) return true; // both NULL
    if(!t1 || !t2) return false; // one NULL
    if(t1->data != t2->data) return false;

    // recursively check left and right
    return isIdentical(t1->left, t2->left) && isIdentical(t1->right, t2->right);
}

// Main function to check if t2 is subtree of t1
bool isSubtree(Node* t1, Node* t2) {
    if(!t2) return true; // empty tree is subtree
    if(!t1) return false; // t1 empty but t2 not

    if(t1->data == t2->data && isIdentical(t1, t2)) return true;

    // recursively check left and right
    return isSubtree(t1->left, t2) || isSubtree(t1->right, t2);
}

int main() {
    // Construct T1
    Node* T1 = new Node(1);
    T1->left = new Node(2);
    T1->right = new Node(3);
    T1->left->left = new Node(4);
    T1->left->right = new Node(5);

    // Construct T2
    Node* T2 = new Node(2);
    T2->left = new Node(4);
    T2->right = new Node(5);

    if(isSubtree(T1, T2))
        cout << "T2 is a subtree of T1" << endl;
    else
        cout << "T2 is NOT a subtree of T1" << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
T1:
        1
       / \
      2   3
     / \
    4   5

T2:
      2
     / \
    4   5

Step 1: Start at root of T1 = 1
- 1 != 2 → check left and right

Step 2: Left child of T1 = 2
- 2 == 2 → check isIdentical(T1=2, T2=2)

Step 3: isIdentical check
- Node 2 == Node 2 → check left
- Node 4 == Node 4 → check left/right → both NULL ✅
- Node 5 == Node 5 → check left/right → both NULL ✅
- All match → return True

Step 4: isSubtree → returns True

Result: T2 is a subtree of T1 ✅

```

---

## **Question: | 56 | Serialize BT (level order) | BT |**

**Approach:**
Problem Statement:
Serialize a binary tree into a string (or list) using level order traversal. Include NULL markers for missing children so that the tree can be reconstructed later.

Input: Root of binary tree  
Output: Serialized string or list representing the tree

Example:
Binary Tree:
1
/ \
 2 3
/ \
 4 5

Serialized (level order with nulls): [1,2,3,null,null,4,5]

Approach to Solve:

**Method: Level Order Traversal**

1. Use a queue to traverse the tree level by level.
2. Initialize an empty list/vector `res`.
3. Push root into the queue.
4. While queue not empty:
   - Pop node
   - If node is not NULL:
     - Add node->data to res
     - Push left and right children (even if NULL)
   - Else:
     - Add a marker (like -1 or NULL) to res
5. Return the serialized list/vector

**Time Complexity**: O(n) → each node visited once  
**Space Complexity**: O(n) → queue + result list

**Code:**

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

// Binary Tree Node
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Serialize function using level order traversal
vector<int> serialize(Node* root) {
    vector<int> res;
    if(!root) return res;

    queue<Node*> q;
    q.push(root);

    while(!q.empty()) {
        Node* curr = q.front();
        q.pop();

        if(curr) {
            res.push_back(curr->data);
            q.push(curr->left);
            q.push(curr->right);
        } else {
            res.push_back(-1); // use -1 as NULL marker
        }
    }
    return res;
}

// Utility function to print serialized vector
void printSerialized(vector<int>& res) {
    for(int x : res) {
        if(x == -1) cout << "null ";
        else cout << x << " ";
    }
    cout << endl;
}

int main() {
    // Construct Binary Tree
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    root->right->left = new Node(4);
    root->right->right = new Node(5);

    vector<int> serialized = serialize(root);
    cout << "Serialized Tree (level order): ";
    printSerialized(serialized);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Binary Tree:
        1
       / \
      2   3
         / \
        4   5

Step 1: Initialize queue → [1], res = []

Step 2: Pop 1 → not NULL
- Add 1 to res → res=[1]
- Push left 2, right 3 → queue=[2,3]

Step 3: Pop 2 → not NULL
- Add 2 → res=[1,2]
- Push left NULL, right NULL → queue=[3,NULL,NULL]

Step 4: Pop 3 → not NULL
- Add 3 → res=[1,2,3]
- Push left 4, right 5 → queue=[NULL,NULL,4,5]

Step 5: Pop NULL → add -1 → res=[1,2,3,-1]

Step 6: Pop NULL → add -1 → res=[1,2,3,-1,-1]

Step 7: Pop 4 → add 4 → res=[1,2,3,-1,-1,4]
- Push NULL,NULL → queue=[5,NULL,NULL]

Step 8: Pop 5 → add 5 → res=[1,2,3,-1,-1,4,5]
- Push NULL,NULL → queue=[NULL,NULL,NULL,NULL]

Step 9: Pop remaining NULLs → add -1 each → final res=[1,2,3,-1,-1,4,5,-1,-1,-1,-1]

Result: Serialized tree = [1,2,3,null,null,4,5,null,null,null,null] ✅

```

---

## **Question: | 57 | Construct BT from level order + inorder | BT |**

**Approach:**
Problem Statement:
Given the level order and inorder traversals of a binary tree, construct the original binary tree.

Input:

- Level order: array representing nodes in level order
- Inorder: array representing nodes in inorder

Output: Root of the reconstructed binary tree

Example:
Level order: [1, 2, 3, 4, 5, 6, 7]  
Inorder: [4, 2, 5, 1, 6, 3, 7]

Constructed Tree:
1
/ \
 2 3
/ \ / \
 4 5 6 7

Approach to Solve:

1. **Observation**:

   - Inorder helps identify left and right subtree boundaries.
   - Level order helps pick root of subtree first among remaining nodes.

2. **Algorithm**:

   - Start with root = levelOrder[0]
   - Find root in inorder → index splits inorder into left and right subtree
   - For left and right subtree:
     - Filter level order array for elements present in left and right inorder subarrays
     - Recursively construct left and right subtree

3. **Key Points**:

   - Filtering level order ensures correct node sequence for each subtree
   - Base case: inorder empty → return NULL

4. **Time Complexity**: O(n^2) in worst case (due to filtering level order)
5. **Space Complexity**: O(n) for recursion stack + arrays

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;

// Binary Tree Node
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Helper function to filter level order for subtree nodes
vector<int> filterLevelOrder(vector<int>& levelOrder, unordered_set<int>& inorderSet) {
    vector<int> filtered;
    for(int val : levelOrder) {
        if(inorderSet.count(val)) filtered.push_back(val);
    }
    return filtered;
}

// Recursive function to build tree
Node* buildTree(vector<int>& inorder, vector<int>& levelOrder) {
    if(inorder.empty()) return nullptr;

    int rootVal = levelOrder[0]; // first node in level order
    Node* root = new Node(rootVal);

    // Find root index in inorder
    int rootIndex = 0;
    for(int i=0; i<inorder.size(); i++) {
        if(inorder[i] == rootVal) {
            rootIndex = i;
            break;
        }
    }

    // Split inorder into left and right
    vector<int> leftInorder(inorder.begin(), inorder.begin()+rootIndex);
    vector<int> rightInorder(inorder.begin()+rootIndex+1, inorder.end());

    // Create sets for filtering level order
    unordered_set<int> leftSet(leftInorder.begin(), leftInorder.end());
    unordered_set<int> rightSet(rightInorder.begin(), rightInorder.end());

    // Filter level order for left and right subtrees
    vector<int> leftLevel = filterLevelOrder(levelOrder, leftSet);
    vector<int> rightLevel = filterLevelOrder(levelOrder, rightSet);

    // Recursively build left and right
    root->left = buildTree(leftInorder, leftLevel);
    root->right = buildTree(rightInorder, rightLevel);

    return root;
}

// Utility function to print inorder (for verification)
void printInorder(Node* root) {
    if(!root) return;
    printInorder(root->left);
    cout << root->data << " ";
    printInorder(root->right);
}

int main() {
    vector<int> inorder = {4,2,5,1,6,3,7};
    vector<int> levelOrder = {1,2,3,4,5,6,7};

    Node* root = buildTree(inorder, levelOrder);

    cout << "Inorder of constructed tree: ";
    printInorder(root); // Should match original inorder
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Level order: [1,2,3,4,5,6,7]
Inorder:     [4,2,5,1,6,3,7]

Step 1: Root = 1 (levelOrder[0])
- Find 1 in inorder → index=3
- Left inorder = [4,2,5], Right inorder = [6,3,7]

Step 2: Filter level order for left subtree
- levelOrder = [1,2,3,4,5,6,7]
- LeftSet = {4,2,5} → filtered = [2,4,5]
- Build left subtree with inorder=[4,2,5], levelOrder=[2,4,5]

Step 3: Left Subtree root = 2
- RootIndex in leftInorder = 1
- Left inorder = [4], Right inorder = [5]
- Filter left level = [4], right level = [5]
- Recursively build left=4, right=5

Step 4: Filter level order for right subtree
- RightSet = {6,3,7} → filtered = [3,6,7]
- Build right subtree with inorder=[6,3,7], levelOrder=[3,6,7]
- Root = 3
- RootIndex=1 → left=[6], right=[7]
- Build left=6, right=7

Step 5: Tree constructed:
        1
       / \
      2   3
     / \  / \
    4  5 6  7 ✅

```

---

## **Question: | 58 | Count number of unique BSTs for N nodes | BST |**

**Approach:**
Problem Statement:
Given an integer N, count the number of structurally unique Binary Search Trees (BSTs) that can be formed with nodes valued from 1 to N.

Input: Integer N  
Output: Number of unique BSTs

Example:
N = 3  
Possible BSTs: 5  
1 3 3 2 1
\ / / / \ \
 3 2 1 1 3 2
/ / \ \
2 1 2 3

Approach to Solve:

**Method 1: Recursive (Catalan number)**

1. If n == 0 or n == 1 → return 1 (empty tree or single node)
2. For each node i from 1 to n:
   - Count left subtrees = count(i-1)
   - Count right subtrees = count(n-i)
   - Multiply left \* right and add to total
3. Return total

**Method 2: Dynamic Programming (Optimal)**

1. Let dp[i] = number of unique BSTs with i nodes
2. Base cases: dp[0] = 1, dp[1] = 1
3. For i = 2 to N:
   - dp[i] = sum(dp[j] \* dp[i-1-j]) for j = 0 to i-1
4. Return dp[N]

- Time Complexity: O(N^2)
- Space Complexity: O(N)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to count number of unique BSTs using Dynamic Programming
int countUniqueBST(int n) {
    // dp[i] will store number of unique BSTs with i nodes
    vector<int> dp(n + 1, 0);

    // Base cases
    dp[0] = 1; // empty tree
    dp[1] = 1; // tree with one node

    // Fill dp array for 2 to n nodes
    for(int i = 2; i <= n; i++) {
        // Consider each node as root
        for(int j = 0; j < i; j++) {
            // Number of left subtrees = dp[j]
            // Number of right subtrees = dp[i-1-j]
            dp[i] += dp[j] * dp[i-1-j];
        }
    }

    // Return total number of unique BSTs with n nodes
    return dp[n];
}

int main() {
    int N;
    cout << "Enter number of nodes N: ";
    cin >> N;

    int totalBST = countUniqueBST(N);

    cout << "Number of unique BSTs with " << N << " nodes = " << totalBST << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: N = 3

Step 1: Initialize dp array: dp[0]=1, dp[1]=1

Step 2: i = 2
- j=0 → left=dp[0]=1, right=dp[1]=1 → dp[2]+=1*1=1
- j=1 → left=dp[1]=1, right=dp[0]=1 → dp[2]+=1*1=2
dp[2] = 2

Step 3: i = 3
- j=0 → left=dp[0]=1, right=dp[2]=2 → dp[3]+=1*2=2
- j=1 → left=dp[1]=1, right=dp[1]=1 → dp[3]+=1*1=3
- j=2 → left=dp[2]=2, right=dp[0]=1 → dp[3]+=2*1=5
dp[3] = 5

Result: Number of unique BSTs = 5 ✅

```

---

## **Question: | 59 | Flatten BST to sorted DLL | BST |**

**Approach:**
Problem Statement:
Given a Binary Search Tree (BST), flatten it into a sorted Doubly Linked List (DLL) in-place.

- The left pointer should act as previous in DLL
- The right pointer should act as next in DLL
- The DLL should be in sorted order

Input: Root of BST  
Output: Head of sorted DLL

Example:
BST:
4
/ \
 2 5
/ \
 1 3

Sorted DLL: 1 <-> 2 <-> 3 <-> 4 <-> 5

Approach to Solve:

**Method: Inorder Traversal (Recursive)**

1. Inorder traversal of BST gives nodes in sorted order.
2. Maintain a pointer `prev` to the previous node in DLL.
3. For each node during traversal:
   - If prev is NULL → this is the head of DLL
   - Else → link prev->right = curr, curr->left = prev
   - Update prev = curr
4. Return head of DLL after traversal

- Time Complexity: O(n) → each node visited once
- Space Complexity: O(h) → recursion stack, h = height of BST

**Code:**

```cpp
#include <iostream>
using namespace std;

// BST Node structure
struct Node {
    int data;
    Node* left;  // acts as 'prev' in DLL
    Node* right; // acts as 'next' in DLL
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Helper function to perform inorder traversal and link nodes
void flattenBSTtoDLLHelper(Node* root, Node*& head, Node*& prev) {
    if(!root) return; // base case: empty node

    // Recursively process left subtree
    flattenBSTtoDLLHelper(root->left, head, prev);

    // Process current node
    if(prev == nullptr) {
        // This is the leftmost node, becomes head of DLL
        head = root;
    } else {
        // Link previous node with current node
        prev->right = root; // prev->next = curr
        root->left = prev;  // curr->prev = prev
    }
    prev = root; // Update prev to current node

    // Recursively process right subtree
    flattenBSTtoDLLHelper(root->right, head, prev);
}

// Main function to flatten BST to DLL
Node* flattenBSTtoDLL(Node* root) {
    Node* head = nullptr; // Head of DLL
    Node* prev = nullptr; // Previous node in DLL
    flattenBSTtoDLLHelper(root, head, prev);
    return head;
}

// Utility function to print DLL from head to end
void printDLL(Node* head) {
    Node* curr = head;
    while(curr) {
        cout << curr->data;
        if(curr->right) cout << " <-> ";
        curr = curr->right;
    }
    cout << endl;
}

int main() {
    // Construct BST
    Node* root = new Node(4);
    root->left = new Node(2);
    root->right = new Node(5);
    root->left->left = new Node(1);
    root->left->right = new Node(3);

    // Flatten BST to DLL
    Node* head = flattenBSTtoDLL(root);

    cout << "Flattened DLL: ";
    printDLL(head); // Output: 1 <-> 2 <-> 3 <-> 4 <-> 5

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
BST:
        4
       / \
      2   5
     / \
    1   3

Step 1: Start inorder traversal at root=4

Left subtree of 4:
- Node 2
    Left of 2: Node 1
        Left NULL → return
        Process 1:
            prev=NULL → head=1
            prev=1
        Right NULL → return
    Process 2:
        prev=1 → link 1->right=2, 2->left=1
        prev=2
    Right of 2: Node 3
        Left NULL → return
        Process 3:
            prev=2 → link 2->right=3, 3->left=2
            prev=3
        Right NULL → return

Process 4:
- prev=3 → link 3->right=4, 4->left=3
- prev=4

Right of 4: Node 5
- Left NULL → return
- Process 5:
    prev=4 → link 4->right=5, 5->left=4
- Right NULL → return

DLL formed:
1 <-> 2 <-> 3 <-> 4 <-> 5 ✅

```

---

## **Question: | 60 | Convert BT to BST (preserve structure) | BT/BST |**

**Approach:**
Problem Statement:
Given a Binary Tree (BT), convert it into a Binary Search Tree (BST) while **preserving the original structure** of the tree.

- Only the **values** of the nodes can change, structure (shape) must remain same.

Input: Root of BT  
Output: Root of BST with same structure but BST property satisfied

Example:
BT:
10
/ \
 30 15
/ \
 20 5

BST (same structure):
15
/ \
 10 20
/ \
 5 30

Approach to Solve:

**Step 1: Extract all node values**

1. Do an inorder traversal of BT and store all node values in a list/vector.
2. Example: inorder(BT) → [20,30,10,15,5]

**Step 2: Sort the node values**

1. Sort the extracted values to get values in ascending order.
2. Example: [5,10,15,20,30]

**Step 3: Replace node values using inorder traversal**

1. Do another inorder traversal of BT.
2. At each node, replace the value with the next element from the sorted list.
3. This ensures BST property while structure remains same.

- Time Complexity: O(n log n) → for sorting
- Space Complexity: O(n) → for storing node values

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Binary Tree Node
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Step 1: Inorder traversal to collect node values
void storeInorder(Node* root, vector<int>& values) {
    if(!root) return;
    storeInorder(root->left, values); // traverse left subtree
    values.push_back(root->data);     // store current node value
    storeInorder(root->right, values);// traverse right subtree
}

// Step 2: Inorder traversal to replace node values with sorted values
void arrayToBST(Node* root, vector<int>& values, int& index) {
    if(!root) return;
    arrayToBST(root->left, values, index);   // left subtree
    root->data = values[index];              // replace value
    index++;                                 // move to next value
    arrayToBST(root->right, values, index);  // right subtree
}

// Utility function to print inorder (to verify BST)
void printInorder(Node* root) {
    if(!root) return;
    printInorder(root->left);
    cout << root->data << " ";
    printInorder(root->right);
}

int main() {
    // Construct Binary Tree
    Node* root = new Node(10);
    root->left = new Node(30);
    root->right = new Node(15);
    root->left->left = new Node(20);
    root->right->right = new Node(5);

    // Step 1: Extract values
    vector<int> values;
    storeInorder(root, values);

    // Step 2: Sort values
    sort(values.begin(), values.end());

    // Step 3: Replace values using inorder traversal
    int index = 0;
    arrayToBST(root, values, index);

    // Print inorder of new BST
    cout << "Inorder of converted BST: ";
    printInorder(root); // Output should be sorted: 5 10 15 20 30
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Original BT:
        10
       /  \
      30   15
     /      \
    20       5

Step 1: Inorder traversal → [20, 30, 10, 15, 5]

Step 2: Sort values → [5, 10, 15, 20, 30]

Step 3: Replace node values during inorder traversal
- Node 20 → 5
- Node 30 → 10
- Node 10 → 15
- Node 15 → 20
- Node 5  → 30

Resulting BST (same structure):
        15
       /  \
      10   20
     /      \
    5        30

Inorder traversal of BST: 5 10 15 20 30 ✅

```

---
