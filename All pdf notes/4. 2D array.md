## **Question: Take input & print a 2D matrix.**

**Approach:**
We want to take input of a matrix from the user and print it.

Step 1: Ask the user for the number of rows and columns.

Step 2: Use a 2D array to store values.

Step 3: Fill the matrix using nested loops.

Step 4: Print the matrix in row–column format using nested loops.

**Code:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;

    // Step 1: Take input for number of rows and columns
    cout << "Enter number of rows: ";
    cin >> n;
    cout << "Enter number of columns: ";
    cin >> m;

    // Step 2: Declare a 2D array of size n x m
    // Note: This works in most compilers (Variable Length Array)
    int matrix[n][m];

    // Step 3: Take input for matrix elements
    cout << "Enter elements of the matrix:\n";
    for (int i = 0; i < n; i++) {          // Loop for rows
        for (int j = 0; j < m; j++) {      // Loop for columns
            cin >> matrix[i][j];           // Store input in matrix
        }
    }

    // Step 4: Print the matrix
    cout << "The matrix is:\n";
    for (int i = 0; i < n; i++) {          // Loop for rows
        for (int j = 0; j < m; j++) {      // Loop for columns
            cout << matrix[i][j] << " ";   // Print element with space
        }
        cout << endl;                      // New line after each row
    }

    return 0; // End of program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input:
n = 2, m = 3
Matrix elements = 1 2 3 4 5 6

Step 1: User enters n=2, m=3
Step 2: matrix[2][3] declared
Step 3: Filling values:
   i=0 -> j=0 → matrix[0][0]=1
           j=1 → matrix[0][1]=2
           j=2 → matrix[0][2]=3
   i=1 -> j=0 → matrix[1][0]=4
           j=1 → matrix[1][1]=5
           j=2 → matrix[1][2]=6

Step 4: Printing row by row
Output:
1 2 3
4 5 6

```

---

## **Question: Print matrix row-wise.**

**Approach:**
We need to print a 2D matrix row by row.

First, take input for rows and columns.

Then take input for each element of the matrix.

Finally, traverse row by row and print all elements in each row before moving to the next row.

This is the natural way of printing a matrix (row-major order).

**Code:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;

    // Step 1: Take input for number of rows and columns
    cout << "Enter number of rows: ";
    cin >> n;
    cout << "Enter number of columns: ";
    cin >> m;

    // Step 2: Declare 2D array
    int matrix[n][m];

    // Step 3: Take input for matrix elements
    cout << "Enter elements of the matrix:\n";
    for (int i = 0; i < n; i++) {              // Loop over rows
        for (int j = 0; j < m; j++) {          // Loop over columns
            cin >> matrix[i][j];               // Store each element
        }
    }

    // Step 4: Print the matrix row by row
    cout << "Matrix printed row-wise:\n";
    for (int i = 0; i < n; i++) {              // Outer loop for rows
        for (int j = 0; j < m; j++) {          // Inner loop for columns
            cout << matrix[i][j] << " ";       // Print element in same row
        }
        cout << endl;                          // After each row, move to next line
    }

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input:
n = 3, m = 3
Matrix elements =
1 2 3
4 5 6
7 8 9

Step 1: User enters n=3, m=3
Step 2: matrix[3][3] declared
Step 3: Filling values row by row:
   Row 0: 1, 2, 3
   Row 1: 4, 5, 6
   Row 2: 7, 8, 9
Step 4: Printing row by row:
Output:
1 2 3
4 5 6
7 8 9

```

---

## **Question: Print matrix column-wise.**

**Approach:**
We need to print a 2D matrix column by column instead of row by row.

Step 1: Take input for number of rows n and columns m.

Step 2: Fill the matrix with input elements.

Step 3: Traverse the matrix column by column and print all elements in each column before moving to the next column.

This is also called column-major order printing.

**Code:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;

    // Step 1: Take input for number of rows and columns
    cout << "Enter number of rows: ";
    cin >> n;
    cout << "Enter number of columns: ";
    cin >> m;

    // Step 2: Declare a 2D array
    int matrix[n][m];

    // Step 3: Take input for matrix elements
    cout << "Enter elements of the matrix:\n";
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = 0; j < m; j++) {       // Loop over columns
            cin >> matrix[i][j];            // Store element
        }
    }

    // Step 4: Print the matrix column by column
    cout << "Matrix printed column-wise:\n";
    for (int j = 0; j < m; j++) {           // Loop over columns first
        for (int i = 0; i < n; i++) {       // Loop over rows next
            cout << matrix[i][j] << " ";    // Print elements of current column
        }
        cout << endl;                        // New line after each column
    }

    return 0; // End of program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input:
n = 3, m = 3
Matrix elements:
1 2 3
4 5 6
7 8 9

Step 1: n=3, m=3
Step 2: matrix[3][3] declared
Step 3: Filling values:
   matrix[0][0]=1, matrix[0][1]=2, matrix[0][2]=3
   matrix[1][0]=4, matrix[1][1]=5, matrix[1][2]=6
   matrix[2][0]=7, matrix[2][1]=8, matrix[2][2]=9

Step 4: Printing column by column:
Column 0: 1 4 7
Column 1: 2 5 8
Column 2: 3 6 9

Output:
1 4 7
2 5 8
3 6 9

```

---

## **Question: Find sum of all elements in matrix.**

**Approach:**
Take input for number of rows n and columns m.

Fill the matrix with elements using nested loops.

Initialize a variable sum to 0.

Traverse the matrix row by row (or column by column) and add each element to sum.

Print the total sum.

**Code:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;

    // Step 1: Take input for number of rows and columns
    cout << "Enter number of rows: ";
    cin >> n;
    cout << "Enter number of columns: ";
    cin >> m;

    // Step 2: Declare a 2D array
    int matrix[n][m];

    // Step 3: Take input for matrix elements
    cout << "Enter elements of the matrix:\n";
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = 0; j < m; j++) {       // Loop over columns
            cin >> matrix[i][j];            // Store element
        }
    }

    // Step 4: Initialize sum variable
    int sum = 0;

    // Step 5: Traverse matrix and add elements to sum
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = 0; j < m; j++) {       // Loop over columns
            sum += matrix[i][j];            // Add current element to sum
        }
    }

    // Step 6: Print the total sum
    cout << "Sum of all elements in the matrix: " << sum << endl;

    return 0; // End of program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input:
n = 2, m = 3
Matrix elements:
1 2 3
4 5 6

Step 1: n=2, m=3
Step 2: matrix[2][3] declared
Step 3: Filling values:
   matrix[0][0]=1, matrix[0][1]=2, matrix[0][2]=3
   matrix[1][0]=4, matrix[1][1]=5, matrix[1][2]=6
Step 4: sum = 0
Step 5: Adding elements:
   sum += 1 → sum=1
   sum += 2 → sum=3
   sum += 3 → sum=6
   sum += 4 → sum=10
   sum += 5 → sum=15
   sum += 6 → sum=21
Step 6: Print sum
Output:
Sum of all elements in the matrix: 21

```

---

## **Question: Find sum of each row.**

**Approach:**
We need to find the sum of elements in each row of a 2D matrix.
Approach:

Take input for number of rows n and columns m.

Fill the matrix using nested loops.

Traverse each row, initialize a rowSum variable to 0, and add all elements of that row.

Print the sum of each row after traversing it.

**Code:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;

    // Step 1: Take input for number of rows and columns
    cout << "Enter number of rows: ";
    cin >> n;
    cout << "Enter number of columns: ";
    cin >> m;

    // Step 2: Declare 2D array
    int matrix[n][m];

    // Step 3: Take input for matrix elements
    cout << "Enter elements of the matrix:\n";
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = 0; j < m; j++) {       // Loop over columns
            cin >> matrix[i][j];            // Store element
        }
    }

    // Step 4: Calculate sum of each row
    cout << "Sum of each row:\n";
    for (int i = 0; i < n; i++) {           // Loop over rows
        int rowSum = 0;                      // Initialize row sum
        for (int j = 0; j < m; j++) {       // Loop over columns
            rowSum += matrix[i][j];         // Add element to row sum
        }
        cout << "Row " << i+1 << ": " << rowSum << endl; // Print sum of current row
    }

    return 0; // End of program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input:
n = 3, m = 3
Matrix elements:
1 2 3
4 5 6
7 8 9

Step 1: n=3, m=3
Step 2: matrix[3][3] declared
Step 3: Filling values:
   Row 0 → 1 2 3
   Row 1 → 4 5 6
   Row 2 → 7 8 9

Step 4: Calculating row sums:
   Row 0 sum = 1+2+3 = 6
   Row 1 sum = 4+5+6 = 15
   Row 2 sum = 7+8+9 = 24

Output:
Row 1: 6
Row 2: 15
Row 3: 24

```

---

## **Question: Find sum of each column.**

**Approach:**
Take input for the number of rows n and columns m.

Fill the matrix using nested loops.

Traverse each column, initialize a colSum variable to 0, and add all elements of that column.

Print the sum of each column after traversing it.

**Code:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;

    // Step 1: Take input for number of rows and columns
    cout << "Enter number of rows: ";
    cin >> n;
    cout << "Enter number of columns: ";
    cin >> m;

    // Step 2: Declare 2D array
    int matrix[n][m];

    // Step 3: Take input for matrix elements
    cout << "Enter elements of the matrix:\n";
    for (int i = 0; i < n; i++) {          // Loop over rows
        for (int j = 0; j < m; j++) {      // Loop over columns
            cin >> matrix[i][j];           // Store element
        }
    }

    // Step 4: Calculate sum of each column
    cout << "Sum of each column:\n";
    for (int j = 0; j < m; j++) {          // Loop over columns
        int colSum = 0;                     // Initialize column sum
        for (int i = 0; i < n; i++) {      // Loop over rows
            colSum += matrix[i][j];        // Add element to column sum
        }
        cout << "Column " << j+1 << ": " << colSum << endl; // Print sum of current column
    }

    return 0; // End of program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input:
n = 3, m = 3
Matrix elements:
1 2 3
4 5 6
7 8 9

Step 1: n=3, m=3
Step 2: matrix[3][3] declared
Step 3: Filling values:
   Row 0 → 1 2 3
   Row 1 → 4 5 6
   Row 2 → 7 8 9

Step 4: Calculating column sums:
   Column 0 sum = 1+4+7 = 12
   Column 1 sum = 2+5+8 = 15
   Column 2 sum = 3+6+9 = 18

Output:
Column 1: 12
Column 2: 15
Column 3: 18

```

---

## **Question: Find maximum element and its position.**

**Approach:**
Take input for number of rows n and columns m.

Fill the matrix with input elements.

Initialize maxElement with the first element of the matrix and maxRow, maxCol with its position (0,0).

Traverse the matrix using nested loops.

If a current element is greater than maxElement, update maxElement and store its position.

Print the maximum element and its position.

**Code:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;

    // Step 1: Input number of rows and columns
    cout << "Enter number of rows: ";
    cin >> n;
    cout << "Enter number of columns: ";
    cin >> m;

    // Step 2: Declare 2D array
    int matrix[n][m];

    // Step 3: Input matrix elements
    cout << "Enter elements of the matrix:\n";
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = 0; j < m; j++) {       // Loop over columns
            cin >> matrix[i][j];            // Store element
        }
    }

    // Step 4: Initialize maximum element and its position
    int maxElement = matrix[0][0];          // Assume first element is maximum
    int maxRow = 0, maxCol = 0;

    // Step 5: Traverse matrix to find maximum element
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = 0; j < m; j++) {       // Loop over columns
            if (matrix[i][j] > maxElement) { // If current element is greater
                maxElement = matrix[i][j];   // Update maximum
                maxRow = i;                  // Update row position
                maxCol = j;                  // Update column position
            }
        }
    }

    // Step 6: Print maximum element and its position
    cout << "Maximum element: " << maxElement << endl;
    cout << "Position: Row " << maxRow+1 << ", Column " << maxCol+1 << endl;

    return 0; // End of program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input:
n = 3, m = 3
Matrix elements:
1 7 3
4 5 6
9 2 8

Step 1: n=3, m=3
Step 2: matrix[3][3] declared
Step 3: Filling values:
   Row 0 → 1 7 3
   Row 1 → 4 5 6
   Row 2 → 9 2 8

Step 4: Initialize maxElement = 1, maxRow = 0, maxCol = 0

Step 5: Traverse matrix:
   matrix[0][1]=7 → greater → maxElement=7, maxRow=0, maxCol=1
   matrix[2][0]=9 → greater → maxElement=9, maxRow=2, maxCol=0

Output:
Maximum element: 9
Position: Row 3, Column 1

```

---

## **Question: Find minimum element and its position.**

**Approach:**
Take input for number of rows n and columns m.

Fill the matrix using nested loops.

Initialize minElement with the first element of the matrix and minRow, minCol with its position (0,0).

Traverse the matrix. If a current element is smaller than minElement, update minElement and its position.

Print the minimum element and its position.

**Code:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;

    // Step 1: Input number of rows and columns
    cout << "Enter number of rows: ";
    cin >> n;
    cout << "Enter number of columns: ";
    cin >> m;

    // Step 2: Declare 2D array
    int matrix[n][m];

    // Step 3: Input matrix elements
    cout << "Enter elements of the matrix:\n";
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = 0; j < m; j++) {       // Loop over columns
            cin >> matrix[i][j];            // Store element
        }
    }

    // Step 4: Initialize minimum element and its position
    int minElement = matrix[0][0];          // Assume first element is minimum
    int minRow = 0, minCol = 0;

    // Step 5: Traverse matrix to find minimum element
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = 0; j < m; j++) {       // Loop over columns
            if (matrix[i][j] < minElement) { // If current element is smaller
                minElement = matrix[i][j];   // Update minimum
                minRow = i;                  // Update row position
                minCol = j;                  // Update column position
            }
        }
    }

    // Step 6: Print minimum element and its position
    cout << "Minimum element: " << minElement << endl;
    cout << "Position: Row " << minRow+1 << ", Column " << minCol+1 << endl;

    return 0; // End of program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input:
n = 3, m = 3
Matrix elements:
1 7 3
4 5 6
9 2 8

Step 1: n=3, m=3
Step 2: matrix[3][3] declared
Step 3: Filling values:
   Row 0 → 1 7 3
   Row 1 → 4 5 6
   Row 2 → 9 2 8

Step 4: Initialize minElement = 1, minRow = 0, minCol = 0

Step 5: Traverse matrix:
   matrix[2][1]=2 → not smaller than 1
   All other elements > 1 → no change

Output:
Minimum element: 1
Position: Row 1, Column 1

```

---

## **Question: Search for a given element (linear search).**

**Approach:**
Traverse the matrix row by row and column by column.

Compare each element with the target value.

If found, return its position (row, column). Otherwise, indicate that the element is not present.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Function to perform linear search in a matrix
pair<int, int> linearSearch(int matrix[][3], int rows, int cols, int target) {
    for (int i = 0; i < rows; i++) {          // Loop over rows
        for (int j = 0; j < cols; j++) {      // Loop over columns
            if (matrix[i][j] == target) {    // Check if element matches target
                return {i, j};               // Return position as pair
            }
        }
    }
    return {-1, -1};                          // Return {-1,-1} if not found
}

int main() {
    // Example 3x3 matrix
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int target = 5; // Element to search

    pair<int,int> pos = linearSearch(matrix, 3, 3, target);

    if (pos.first != -1)
        cout << "Element " << target << " found at Row " << pos.first+1
             << ", Column " << pos.second+1 << endl;
    else
        cout << "Element " << target << " not found in the matrix." << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
4 5 6
7 8 9
Target = 5

Step 1: Check matrix[0][0]=1 → not match
Step 2: Check matrix[0][1]=2 → not match
Step 3: Check matrix[0][2]=3 → not match
Step 4: Check matrix[1][0]=4 → not match
Step 5: Check matrix[1][1]=5 → match found → return (1,1)

Output:
Element 5 found at Row 2, Column 2

```

---

## **Question: Count even and odd numbers in a matrix.**

**Approach:**
Traverse the matrix row by row and column by column.

Check each element using modulo (%) operator:

If element % 2 == 0, it’s even → increment evenCount.

Else, it’s odd → increment oddCount.

Return the counts.

We will create a separate function countEvenOdd for this and call it from main.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Function to count even and odd numbers in a matrix
pair<int, int> countEvenOdd(int matrix[][3], int rows, int cols) {
    int evenCount = 0, oddCount = 0;

    for (int i = 0; i < rows; i++) {          // Loop over rows
        for (int j = 0; j < cols; j++) {      // Loop over columns
            if (matrix[i][j] % 2 == 0)        // Check if even
                evenCount++;
            else
                oddCount++;                   // Else odd
        }
    }

    return {evenCount, oddCount};             // Return counts as pair
}

int main() {
    // Example 3x3 matrix
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    pair<int,int> counts = countEvenOdd(matrix, 3, 3);

    cout << "Even numbers count: " << counts.first << endl;
    cout << "Odd numbers count: " << counts.second << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
4 5 6
7 8 9

Step 1: Initialize evenCount=0, oddCount=0
Step 2: Traverse each element:
   1 → odd → oddCount=1
   2 → even → evenCount=1
   3 → odd → oddCount=2
   4 → even → evenCount=2
   5 → odd → oddCount=3
   6 → even → evenCount=3
   7 → odd → oddCount=4
   8 → even → evenCount=4
   9 → odd → oddCount=5

Output:
Even numbers count: 4
Odd numbers count: 5

```

---

## **Question: Count prime numbers in a matrix.**

**Approach:**
Create a helper function isPrime to check if a number is prime.

Traverse the matrix row by row and column by column.

For each element, use isPrime to check:

If prime, increment primeCount.

Return the total count of prime numbers.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Helper function to check if a number is prime
bool isPrime(int num) {
    if (num < 2) return false;               // Numbers < 2 are not prime
    for (int i = 2; i*i <= num; i++) {      // Check divisibility up to sqrt(num)
        if (num % i == 0)
            return false;                    // Not prime if divisible
    }
    return true;                             // Prime if no divisors found
}

// Function to count prime numbers in a matrix
int countPrimes(int matrix[][3], int rows, int cols) {
    int primeCount = 0;

    for (int i = 0; i < rows; i++) {        // Loop over rows
        for (int j = 0; j < cols; j++) {    // Loop over columns
            if (isPrime(matrix[i][j]))      // Check if element is prime
                primeCount++;
        }
    }

    return primeCount;                       // Return total prime count
}

int main() {
    // Example 3x3 matrix
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int primes = countPrimes(matrix, 3, 3);

    cout << "Number of prime numbers in the matrix: " << primes << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
4 5 6
7 8 9

Step 1: Initialize primeCount = 0
Step 2: Traverse each element and check prime:
   1 → not prime
   2 → prime → primeCount=1
   3 → prime → primeCount=2
   4 → not prime
   5 → prime → primeCount=3
   6 → not prime
   7 → prime → primeCount=4
   8 → not prime
   9 → not prime

Output:
Number of prime numbers in the matrix: 4

```

---

## **Question: Check if a matrix is symmetric.**

**Approach:**
A matrix must be square (rows = columns) to be symmetric.

Traverse only the upper triangle (excluding diagonal) and compare each element with its transpose counterpart.

If any element does not match, the matrix is not symmetric.

Otherwise, it is symmetric.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Function to check if a matrix is symmetric
bool isSymmetric(int matrix[][3], int n) {
    // Check symmetry only for square matrix
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = i+1; j < n; j++) {     // Loop over columns above diagonal
            if (matrix[i][j] != matrix[j][i]) // Compare element with transpose
                return false;               // Not symmetric if mismatch
        }
    }
    return true;                            // Symmetric if all elements match
}

int main() {
    // Example 3x3 matrix
    int matrix[3][3] = {
        {1, 2, 3},
        {2, 4, 5},
        {3, 5, 6}
    };

    if (isSymmetric(matrix, 3))
        cout << "The matrix is symmetric." << endl;
    else
        cout << "The matrix is not symmetric." << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
2 4 5
3 5 6

Step 1: Check elements above diagonal:
   matrix[0][1]=2, matrix[1][0]=2 → match
   matrix[0][2]=3, matrix[2][0]=3 → match
   matrix[1][2]=5, matrix[2][1]=5 → match

Step 2: All elements match their transpose
Output:
The matrix is symmetric.

```

---

## **Question: Transpose of a matrix (using extra matrix).**

**Approach:**
Take a matrix of size n x m.

Create another matrix of size m x n to store the transpose.

Traverse the original matrix and assign transpose[j][i] = matrix[i][j].

Print the transpose matrix.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Function to compute transpose of a matrix using extra matrix
void transposeMatrix(int matrix[][3], int rows, int cols, int transpose[][3]) {
    for (int i = 0; i < rows; i++) {        // Loop over rows
        for (int j = 0; j < cols; j++) {    // Loop over columns
            transpose[j][i] = matrix[i][j]; // Assign element to transpose
        }
    }
}

int main() {
    // Example 3x3 matrix
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int transpose[3][3]; // Extra matrix to store transpose

    transposeMatrix(matrix, 3, 3, transpose);

    cout << "Transpose of the matrix:\n";
    for (int i = 0; i < 3; i++) {          // Loop over rows of transpose
        for (int j = 0; j < 3; j++) {      // Loop over columns of transpose
            cout << transpose[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
4 5 6
7 8 9

Step 1: Initialize transpose[3][3]

Step 2: Assign transpose[j][i] = matrix[i][j]
   transpose[0][0] = 1, transpose[1][0] = 2, transpose[2][0] = 3
   transpose[0][1] = 4, transpose[1][1] = 5, transpose[2][1] = 6
   transpose[0][2] = 7, transpose[1][2] = 8, transpose[2][2] = 9

Step 3: Print transpose
Output:
1 4 7
2 5 8
3 6 9

```

---

## **Question: Transpose of a matrix (in-place, square only).**

**Approach:**
For a square matrix, we can compute the transpose in-place without using extra space:

Swap elements matrix[i][j] with matrix[j][i] for all i < j (only upper triangle excluding diagonal).

This avoids overwriting elements and works only for square matrices.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Function to perform in-place transpose of a square matrix
void transposeInPlace(int matrix[][3], int n) {
    for (int i = 0; i < n; i++) {           // Loop over rows
        for (int j = i+1; j < n; j++) {     // Loop over columns above diagonal
            swap(matrix[i][j], matrix[j][i]); // Swap element with its transpose
        }
    }
}

int main() {
    // Example 3x3 square matrix
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    transposeInPlace(matrix, 3);

    cout << "In-place transpose of the matrix:\n";
    for (int i = 0; i < 3; i++) {          // Loop over rows
        for (int j = 0; j < 3; j++) {      // Loop over columns
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
4 5 6
7 8 9

Step 1: Swap elements above diagonal:
   Swap matrix[0][1]=2 with matrix[1][0]=4 → matrix becomes:
   1 4 3
   2 5 6
   7 8 9

   Swap matrix[0][2]=3 with matrix[2][0]=7 → matrix becomes:
   1 4 7
   2 5 6
   3 8 9

   Swap matrix[1][2]=6 with matrix[2][1]=8 → matrix becomes:
   1 4 7
   2 5 8
   3 6 9

Step 2: Print matrix
Output:
1 4 7
2 5 8
3 6 9

```

---

## **Question: Check if two matrices are equal.**

**Approach:**
Two matrices are equal if:

They have the same dimensions.

Every corresponding element is the same.

Approach:

Traverse both matrices row by row and column by column.

Compare each element.

If any pair of elements is different, the matrices are not equal.

If all elements match, the matrices are equal.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Function to check if two matrices are equal
bool areMatricesEqual(int matrix1[][3], int matrix2[][3], int rows, int cols) {
    for (int i = 0; i < rows; i++) {          // Loop over rows
        for (int j = 0; j < cols; j++) {      // Loop over columns
            if (matrix1[i][j] != matrix2[i][j]) // Compare corresponding elements
                return false;                 // Not equal if mismatch found
        }
    }
    return true;                              // Equal if all elements match
}

int main() {
    // Example 3x3 matrices
    int matrix1[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int matrix2[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    if (areMatricesEqual(matrix1, matrix2, 3, 3))
        cout << "Matrices are equal." << endl;
    else
        cout << "Matrices are not equal." << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix1:
1 2 3
4 5 6
7 8 9

Matrix2:
1 2 3
4 5 6
7 8 9

Step 1: Compare elements row by row:
   matrix1[0][0]=1, matrix2[0][0]=1 → match
   matrix1[0][1]=2, matrix2[0][1]=2 → match
   matrix1[0][2]=3, matrix2[0][2]=3 → match
   matrix1[1][0]=4, matrix2[1][0]=4 → match
   ...
All elements match

Output:
Matrices are equal.

```

---

## **Question: Print boundary elements of a matrix.**

**Approach:**
Print the first row and last row completely.

Print the first and last elements of the middle rows (excluding first and last row).

This ensures only the boundary elements are printed in clockwise order.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Function to print boundary elements of a matrix
void printBoundaryElements(int matrix[][4], int rows, int cols) {
    // Print top row
    for (int j = 0; j < cols; j++)
        cout << matrix[0][j] << " ";

    // Print right column (excluding first and last element)
    for (int i = 1; i < rows-1; i++)
        cout << matrix[i][cols-1] << " ";

    // Print bottom row in reverse
    if (rows > 1) {
        for (int j = cols-1; j >= 0; j--)
            cout << matrix[rows-1][j] << " ";
    }

    // Print left column in reverse (excluding first and last element)
    if (cols > 1) {
        for (int i = rows-2; i >= 1; i--)
            cout << matrix[i][0] << " ";
    }
    cout << endl;
}

int main() {
    // Example 3x4 matrix
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9,10,11,12}
    };

    cout << "Boundary elements of the matrix:\n";
    printBoundaryElements(matrix, 3, 4);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1  2  3  4
5  6  7  8
9 10 11 12

Step 1: Print top row → 1 2 3 4
Step 2: Print right column → 8
Step 3: Print bottom row in reverse → 12 11 10 9
Step 4: Print left column in reverse → 5

Output (clockwise boundary):
1 2 3 4 8 12 11 10 9 5

```

---

## **Question: Print main diagonal elements.**

**Approach:**
The main diagonal of a matrix consists of elements where row index = column index.
Approach:

Traverse the matrix from top-left to bottom-right.

Print elements matrix[i][i] for all valid i (up to min(rows, cols)).

We will use vectors and a separate function printMainDiagonal.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to print main diagonal elements of a matrix
void printMainDiagonal(const vector<vector<int>>& matrix) {
    int n = matrix.size();                   // Number of rows
    int m = matrix[0].size();                // Number of columns
    int limit = min(n, m);                   // Limit for diagonal

    cout << "Main diagonal elements: ";
    for (int i = 0; i < limit; i++) {
        cout << matrix[i][i] << " ";        // Print element where row = column
    }
    cout << endl;
}

int main() {
    // Example 3x3 matrix using vector
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    printMainDiagonal(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
4 5 6
7 8 9

Step 1: n=3, m=3, limit=min(3,3)=3
Step 2: Loop i from 0 to 2:
   i=0 → matrix[0][0]=1
   i=1 → matrix[1][1]=5
   i=2 → matrix[2][2]=9

Output:
Main diagonal elements: 1 5 9

```

---

## **Question: Print secondary diagonal elements.**

**Approach:**
The secondary diagonal of a matrix consists of elements where row index + column index = number of columns - 1.
Approach:

Traverse each row i.

Print element at column j = cols - 1 - i for each row.

Works for both square and rectangular matrices if you limit iterations correctly.

We will use vectors and a separate function printSecondaryDiagonal.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to print secondary diagonal elements of a matrix
void printSecondaryDiagonal(const vector<vector<int>>& matrix) {
    int n = matrix.size();                   // Number of rows
    int m = matrix[0].size();                // Number of columns
    int limit = min(n, m);                   // Limit for diagonal

    cout << "Secondary diagonal elements: ";
    for (int i = 0; i < limit; i++) {
        cout << matrix[i][m-1-i] << " ";    // Element at (i, cols-1-i)
    }
    cout << endl;
}

int main() {
    // Example 3x3 matrix using vector
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    printSecondaryDiagonal(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
4 5 6
7 8 9

Step 1: n=3, m=3, limit=min(3,3)=3
Step 2: Loop i from 0 to 2:
   i=0 → matrix[0][2]=3
   i=1 → matrix[1][1]=5
   i=2 → matrix[2][0]=7

Output:
Secondary diagonal elements: 3 5 7

```

---

## **Question: Print both diagonals (X-shape).**

**Approach:**
Traverse each row i.

For each row, print elements at:

Main diagonal: matrix[i][i]

Secondary diagonal: matrix[i][cols-1-i]

Avoid printing the same element twice if the matrix size is odd (center element).

We will use vectors and a separate function printBothDiagonals.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to print both diagonals of a matrix
void printBothDiagonals(const vector<vector<int>>& matrix) {
    int n = matrix.size();                   // Number of rows
    int m = matrix[0].size();                // Number of columns
    int limit = min(n, m);                   // Limit for diagonals

    cout << "Diagonals (X-shape) elements: ";
    for (int i = 0; i < limit; i++) {
        cout << matrix[i][i] << " ";        // Main diagonal
        if (i != m-1-i)                      // Avoid duplicate for center element
            cout << matrix[i][m-1-i] << " "; // Secondary diagonal
    }
    cout << endl;
}

int main() {
    // Example 3x3 matrix using vector
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    printBothDiagonals(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
4 5 6
7 8 9

Step 1: n=3, m=3, limit=min(3,3)=3
Step 2: Loop i from 0 to 2:
   i=0 → main=matrix[0][0]=1, secondary=matrix[0][2]=3
   i=1 → main=matrix[1][1]=5, secondary=matrix[1][1]=5 → skip duplicate
   i=2 → main=matrix[2][2]=9, secondary=matrix[2][0]=7

Output:
Diagonals (X-shape) elements: 1 3 5 9 7

```

---

## **Question: Print matrix in spiral order all type. **

**Approach:**
Maintain four boundaries: top, bottom, left, right.

Traverse the matrix layer by layer:

Top row: left → right

Right column: top+1 → bottom

Bottom row: right-1 → left (if top != bottom)

Left column: bottom-1 → top+1 (if left != right)

After printing a layer, shrink boundaries and repeat until all elements are printed.

We will use vectors and a separate function printSpiralOrder.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to print matrix in spiral order
void printSpiralOrder(const vector<vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    int top = 0, bottom = rows-1, left = 0, right = cols-1;

    cout << "Spiral order: ";
    while (top <= bottom && left <= right) {
        // Print top row
        for (int j = left; j <= right; j++)
            cout << matrix[top][j] << " ";
        top++;

        // Print right column
        for (int i = top; i <= bottom; i++)
            cout << matrix[i][right] << " ";
        right--;

        // Print bottom row if not already traversed
        if (top <= bottom) {
            for (int j = right; j >= left; j--)
                cout << matrix[bottom][j] << " ";
            bottom--;
        }

        // Print left column if not already traversed
        if (left <= right) {
            for (int i = bottom; i >= top; i--)
                cout << matrix[i][left] << " ";
            left++;
        }
    }
    cout << endl;
}

int main() {
    // Example 3x4 matrix using vector
    vector<vector<int>> matrix = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9,10,11,12}
    };

    printSpiralOrder(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1  2  3  4
5  6  7  8
9 10 11 12

Step 1: top=0, bottom=2, left=0, right=3
Step 2: Print top row → 1 2 3 4
Step 3: Print right column → 8 12
Step 4: Print bottom row → 11 10 9
Step 5: Print left column → 5
Step 6: Shrink boundaries: top=1, bottom=1, left=1, right=2
Step 7: Print top row → 6 7

Output:
Spiral order: 1 2 3 4 8 12 11 10 9 5 6 7

```

---

## **Question: Snake pattern traversal.**

**Approach:**
In snake pattern traversal, the matrix is traversed row by row:

Even-indexed rows (0,2,4,…) → left to right

Odd-indexed rows (1,3,5,…) → right to left

Approach:

Loop over each row i.

If i is even, traverse columns 0 → cols-1.

If i is odd, traverse columns cols-1 → 0.

Print elements in this order.

Time Complexity (T): O(m\*n) — every element is visited once.
Space Complexity (S): O(1) — no extra space required.

We will use vectors and a separate function snakePatternTraversal.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to print matrix in snake pattern
void snakePatternTraversal(const vector<vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();

    cout << "Snake pattern traversal: ";
    for (int i = 0; i < rows; i++) {
        if (i % 2 == 0) { // Even row → left to right
            for (int j = 0; j < cols; j++)
                cout << matrix[i][j] << " ";
        } else {          // Odd row → right to left
            for (int j = cols-1; j >= 0; j--)
                cout << matrix[i][j] << " ";
        }
    }
    cout << endl;
}

int main() {
    // Example 4x4 matrix using vector
    vector<vector<int>> matrix = {
        {1,  2,  3,  4},
        {5,  6,  7,  8},
        {9, 10, 11, 12},
        {13,14, 15,16}
    };

    snakePatternTraversal(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1  2  3  4
5  6  7  8
9 10 11 12
13 14 15 16

Step 1: Row 0 → left to right → 1 2 3 4
Step 2: Row 1 → right to left → 8 7 6 5
Step 3: Row 2 → left to right → 9 10 11 12
Step 4: Row 3 → right to left → 16 15 14 13

Output:
Snake pattern traversal: 1 2 3 4 8 7 6 5 9 10 11 12 16 15 14 13

```

---

## **Question: Wave pattern traversal.**

**Approach:**
In wave pattern traversal, the matrix is traversed column by column:

Even-indexed columns (0,2,4,…) → top to bottom

Odd-indexed columns (1,3,5,…) → bottom to top

Approach:

Loop over each column j.

If j is even, traverse rows 0 → rows-1.

If j is odd, traverse rows rows-1 → 0.

Print elements in this order.

Time Complexity (T): O(m\*n) — every element is visited once.
Space Complexity (S): O(1) — no extra space required.

We will use vectors and a separate function wavePatternTraversal.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to print matrix in wave pattern
void wavePatternTraversal(const vector<vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();

    cout << "Wave pattern traversal: ";
    for (int j = 0; j < cols; j++) {
        if (j % 2 == 0) { // Even column → top to bottom
            for (int i = 0; i < rows; i++)
                cout << matrix[i][j] << " ";
        } else {          // Odd column → bottom to top
            for (int i = rows-1; i >= 0; i--)
                cout << matrix[i][j] << " ";
        }
    }
    cout << endl;
}

int main() {
    // Example 4x4 matrix using vector
    vector<vector<int>> matrix = {
        {1,  2,  3,  4},
        {5,  6,  7,  8},
        {9, 10, 11, 12},
        {13,14, 15,16}
    };

    wavePatternTraversal(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1  2  3  4
5  6  7  8
9 10 11 12
13 14 15 16

Step 1: Column 0 → top to bottom → 1 5 9 13
Step 2: Column 1 → bottom to top → 14 10 6 2
Step 3: Column 2 → top to bottom → 3 7 11 15
Step 4: Column 3 → bottom to top → 16 12 8 4

Output:
Wave pattern traversal: 1 5 9 13 14 10 6 2 3 7 11 15 16 12 8 4

```

---

## **Question: Rotate matrix by 90° clockwise.**

**Approach:**
Transpose the matrix → swap matrix[i][j] with matrix[j][i].

Reverse each row → for clockwise rotation.

This avoids using extra space and is widely used.

Time Complexity (T): O(n²) — visit each element once for transpose and row reversal.

Space Complexity (S): O(1) — in-place rotation.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to rotate square matrix 90 degrees clockwise
void rotate90Clockwise(vector<vector<int>>& matrix) {
    int n = matrix.size();

    // Step 1: Transpose the matrix
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }

    // Step 2: Reverse each row
    for (int i = 0; i < n; i++) {
        int left = 0, right = n-1;
        while (left < right) {
            swap(matrix[i][left], matrix[i][right]);
            left++;
            right--;
        }
    }
}

// Function to print matrix
void printMatrix(const vector<vector<int>>& matrix) {
    for (const auto& row : matrix) {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }
}

int main() {
    // Example 3x3 matrix using vector
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    rotate90Clockwise(matrix);

    cout << "Matrix after 90° clockwise rotation:\n";
    printMatrix(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original Matrix:
1 2 3
4 5 6
7 8 9

Step 1: Transpose:
1 4 7
2 5 8
3 6 9

Step 2: Reverse each row:
7 4 1
8 5 2
9 6 3

Output:
7 4 1
8 5 2
9 6 3

```

---

## **Question: Rotate matrix by 180°.**

**Approach:**
Swap each element with its mirror position across the center:

matrix[i][j] ↔ matrix[rows-1-i][cols-1-j]

Stop when all elements are swapped (only need to traverse half the matrix).

Time Complexity (T): O(m\*n) — every element is visited once.

Space Complexity (S): O(1) — in-place rotation, no extra space.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to rotate matrix 180 degrees in-place
void rotate180(vector<vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();

    for (int i = 0; i < (rows+1)/2; i++) {
        for (int j = 0; j < cols; j++) {
            int ni = rows-1-i;       // mirrored row
            int nj = cols-1-j;       // mirrored column

            // Skip swapping same element in the middle row for odd rows
            if (i == ni && j >= cols/2)
                break;

            swap(matrix[i][j], matrix[ni][nj]);
        }
    }
}

// Function to print matrix
void printMatrix(const vector<vector<int>>& matrix) {
    for (const auto& row : matrix) {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }
}

int main() {
    // Example 3x4 matrix using vector
    vector<vector<int>> matrix = {
        {1,  2,  3,  4},
        {5,  6,  7,  8},
        {9, 10, 11, 12}
    };

    rotate180(matrix);

    cout << "Matrix after 180° rotation:\n";
    printMatrix(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original Matrix:
1  2  3  4
5  6  7  8
9 10 11 12

Step 1: Swap (0,0) ↔ (2,3) → 12
Step 2: Swap (0,1) ↔ (2,2) → 11
Step 3: Swap (0,2) ↔ (2,1) → 10
Step 4: Swap (0,3) ↔ (2,0) → 9
Step 5: Swap (1,0) ↔ (1,3) → 8
Step 6: Swap (1,1) ↔ (1,2) → 7 6 swapped

Result:
12 11 10  9
8   7  6  5
4   3  2  1

```

---

## **Question: Rotate matrix by 270°.**

**Approach:**
Rotating a matrix 270° clockwise is equivalent to 90° anti-clockwise.

Optimal Approach (In-place for square matrix):

Transpose the matrix → swap matrix[i][j] with matrix[j][i].

Reverse each column → for 270° clockwise rotation.

Time Complexity (T): O(n²) — each element is visited for transpose and column reversal.

Space Complexity (S): O(1) — in-place rotation.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to rotate square matrix 270 degrees clockwise (90° anti-clockwise)
void rotate270Clockwise(vector<vector<int>>& matrix) {
    int n = matrix.size();

    // Step 1: Transpose the matrix
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }

    // Step 2: Reverse each column
    for (int j = 0; j < n; j++) {
        int top = 0, bottom = n-1;
        while (top < bottom) {
            swap(matrix[top][j], matrix[bottom][j]);
            top++;
            bottom--;
        }
    }
}

// Function to print matrix
void printMatrix(const vector<vector<int>>& matrix) {
    for (const auto& row : matrix) {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }
}

int main() {
    // Example 3x3 matrix using vector
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    rotate270Clockwise(matrix);

    cout << "Matrix after 270° clockwise rotation:\n";
    printMatrix(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original Matrix:
1 2 3
4 5 6
7 8 9

Step 1: Transpose:
1 4 7
2 5 8
3 6 9

Step 2: Reverse each column:
Column 0: 1 ↔ 3 → 3 2 1
Column 1: 4 ↔ 6 → 6 5 4
Column 2: 7 ↔ 9 → 9 8 7

Result:
3 6 9
2 5 8
1 4 7

```

---

## **Question: Mirror/flip matrix horizontally & vertically.**

**Approach:**
We need to flip a matrix in two ways:

Horizontal Flip → reverse each row (mirror along vertical axis).

Vertical Flip → reverse the order of rows (mirror along horizontal axis).

Optimal Approach:

Horizontal Flip: Traverse each row and reverse it.

Vertical Flip: Swap rows i with rows-1-i.

Time Complexity (T): O(m\*n) — each element visited once.
Space Complexity (S): O(1) — in-place flip.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to flip matrix horizontally (mirror along vertical axis)
void flipHorizontal(vector<vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();

    for (int i = 0; i < rows; i++) {
        int left = 0, right = cols-1;
        while (left < right) {
            swap(matrix[i][left], matrix[i][right]);
            left++;
            right--;
        }
    }
}

// Function to flip matrix vertically (mirror along horizontal axis)
void flipVertical(vector<vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();

    int top = 0, bottom = rows-1;
    while (top < bottom) {
        swap(matrix[top], matrix[bottom]); // Swap entire rows
        top++;
        bottom--;
    }
}

// Function to print matrix
void printMatrix(const vector<vector<int>>& matrix) {
    for (const auto& row : matrix) {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }
}

int main() {
    // Example 3x4 matrix using vector
    vector<vector<int>> matrix = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9,10,11,12}
    };

    // Horizontal flip
    flipHorizontal(matrix);
    cout << "Matrix after horizontal flip:\n";
    printMatrix(matrix);

    // Vertical flip
    flipVertical(matrix);
    cout << "Matrix after vertical flip:\n";
    printMatrix(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original Matrix:
1  2  3  4
5  6  7  8
9 10 11 12

Horizontal Flip (reverse each row):
4 3 2 1
8 7 6 5
12 11 10 9

Vertical Flip (swap rows top-bottom):
12 11 10 9
8  7  6 5
4  3  2 1

```

---

## **Question: Matrix addition.**

**Approach:**
Check if the dimensions of both matrices are equal.

Traverse each element (i,j) and compute result[i][j] = matrix1[i][j] + matrix2[i][j].

Return or print the resulting matrix.

Time Complexity (T): O(m\*n) — every element is visited once.

Space Complexity (S): O(m\*n) — for storing the result matrix.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to add two matrices
vector<vector<int>> addMatrices(const vector<vector<int>>& mat1, const vector<vector<int>>& mat2) {
    int rows = mat1.size();
    int cols = mat1[0].size();

    vector<vector<int>> result(rows, vector<int>(cols, 0));

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            result[i][j] = mat1[i][j] + mat2[i][j]; // Element-wise addition
        }
    }

    return result;
}

// Function to print matrix
void printMatrix(const vector<vector<int>>& matrix) {
    for (const auto& row : matrix) {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }
}

int main() {
    // Example 3x3 matrices using vector
    vector<vector<int>> matrix1 = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    vector<vector<int>> matrix2 = {
        {9, 8, 7},
        {6, 5, 4},
        {3, 2, 1}
    };

    vector<vector<int>> result = addMatrices(matrix1, matrix2);

    cout << "Resultant Matrix after addition:\n";
    printMatrix(result);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix1:
1 2 3
4 5 6
7 8 9

Matrix2:
9 8 7
6 5 4
3 2 1

Step: Add corresponding elements:
1+9=10, 2+8=10, 3+7=10
4+6=10, 5+5=10, 6+4=10
7+3=10, 8+2=10, 9+1=10

Result:
10 10 10
10 10 10
10 10 10

```

---

## **Question: Matrix multiplication (basic method).**

**Approach:**
Check if the number of columns of A equals the number of rows of B (n). If not, multiplication is not possible.

Initialize a result matrix of size m×p with zeros.

Use triple nested loops:

Outer loop: traverse rows of A (i)

Middle loop: traverse columns of B (j)

Inner loop: multiply corresponding elements of row i of A and column j of B, accumulate in result[i][j].

Return or print the result.

Time Complexity (T): O(m*n*p) — three nested loops.

Space Complexity (S): O(m\*p) — for storing the result matrix.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to multiply two matrices (basic method)
vector<vector<int>> multiplyMatrices(const vector<vector<int>>& A, const vector<vector<int>>& B) {
    int m = A.size();             // Rows of A
    int n = A[0].size();          // Columns of A
    int p = B[0].size();          // Columns of B

    // Corner case: Check if multiplication is possible
    if (B.size() != n) {
        cerr << "Error: Number of columns of A must equal number of rows of B.\n";
        return {};
    }

    // Initialize result matrix with zeros
    vector<vector<int>> result(m, vector<int>(p, 0));

    // Triple nested loop to multiply
    for (int i = 0; i < m; i++) {          // For each row of A
        for (int j = 0; j < p; j++) {      // For each column of B
            for (int k = 0; k < n; k++) {  // For each element in row A and column B
                result[i][j] += A[i][k] * B[k][j]; // Multiply and accumulate
            }
        }
    }

    return result;
}

// Function to print matrix
void printMatrix(const vector<vector<int>>& matrix) {
    if (matrix.empty()) { // Check for empty matrix
        cout << "Matrix is empty.\n";
        return;
    }
    for (const auto& row : matrix) {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }
}

int main() {
    // Example matrices
    vector<vector<int>> A = {
        {1, 2, 3},
        {4, 5, 6}
    };

    vector<vector<int>> B = {
        {7, 8},
        {9, 10},
        {11, 12}
    };

    vector<vector<int>> result = multiplyMatrices(A, B);

    cout << "Resultant Matrix after multiplication:\n";
    printMatrix(result);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix A (2x3):
1 2 3
4 5 6

Matrix B (3x2):
7  8
9 10
11 12

Step: Multiply row of A with column of B:
result[0][0] = 1*7 + 2*9 + 3*11 = 58
result[0][1] = 1*8 + 2*10 + 3*12 = 64
result[1][0] = 4*7 + 5*9 + 6*11 = 139
result[1][1] = 4*8 + 5*10 + 6*12 = 154

Output:
58  64
139 154

```

---

## **Question: Multiply a matrix by a scalar.**

**Approach:**
Traverse each element of the matrix.

Multiply it by the scalar and update in-place (or store in a new matrix if needed).

Print or return the resulting matrix.

Time Complexity (T): O(m\*n) — each element is visited once.

Space Complexity (S): O(1) — can be done in-place

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to multiply matrix by a scalar (in-place)
void scalarMultiplyMatrix(vector<vector<int>>& matrix, int scalar) {
    int rows = matrix.size();
    if (rows == 0) return;           // Corner case: empty matrix
    int cols = matrix[0].size();

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] *= scalar;  // Multiply each element by scalar
        }
    }
}

// Function to print matrix
void printMatrix(const vector<vector<int>>& matrix) {
    if (matrix.empty()) {
        cout << "Matrix is empty.\n";
        return;
    }
    for (const auto& row : matrix) {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }
}

int main() {
    // Example 3x3 matrix using vector
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int scalar = 3;

    scalarMultiplyMatrix(matrix, scalar);

    cout << "Matrix after multiplying by " << scalar << ":\n";
    printMatrix(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original Matrix:
1 2 3
4 5 6
7 8 9

Scalar = 3

Step: Multiply each element by 3:
1*3=3, 2*3=6, 3*3=9
4*3=12,5*3=15,6*3=18
7*3=21,8*3=24,9*3=27

Result:
3 6  9
12 15 18
21 24 27

```

---

## **Question: Check if a matrix is an identity matrix.**

**Approach:**
Check if the matrix is square (rows == cols). If not, it cannot be identity.

Traverse each element (i,j) of the matrix:

If i == j → element must be 1.

Else → element must be 0.

If all conditions satisfy, the matrix is identity.

Time Complexity (T): O(n²) — check all elements in an n×n matrix.

Space Complexity (S): O(1) — no extra space needed.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to check if a matrix is identity
bool isIdentityMatrix(const vector<vector<int>>& matrix) {
    int rows = matrix.size();
    if (rows == 0) return false;           // Empty matrix cannot be identity
    int cols = matrix[0].size();

    if (rows != cols) return false;        // Must be square

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (i == j && matrix[i][j] != 1) // Diagonal element must be 1
                return false;
            else if (i != j && matrix[i][j] != 0) // Off-diagonal must be 0
                return false;
        }
    }
    return true;
}

int main() {
    // Example 3x3 matrix using vector
    vector<vector<int>> matrix = {
        {1, 0, 0},
        {0, 1, 0},
        {0, 0, 1}
    };

    if (isIdentityMatrix(matrix))
        cout << "The matrix is an identity matrix.\n";
    else
        cout << "The matrix is NOT an identity matrix.\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 0 0
0 1 0
0 0 1

Step: Check each element
(0,0)=1 ✔, (0,1)=0 ✔, (0,2)=0 ✔
(1,0)=0 ✔, (1,1)=1 ✔, (1,2)=0 ✔
(2,0)=0 ✔, (2,1)=0 ✔, (2,2)=1 ✔

All conditions satisfied → Identity matrix

```

---

## **Question: Check if a matrix is upper triangular.**

**Approach:**
Check if the matrix is square (rows == cols). If not, it cannot be upper triangular.

Traverse each element (i,j) below the main diagonal (i > j):

If any element matrix[i][j] != 0, return false.

If all elements below the diagonal are 0, return true.

Time Complexity (T): O(n²) — in worst case, check all elements of n×n matrix.

Space Complexity (S): O(1) — no extra space needed.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to check if a matrix is upper triangular
bool isUpperTriangularMatrix(const vector<vector<int>>& matrix) {
    int n = matrix.size();
    if (n == 0) return false;           // Empty matrix cannot be upper triangular
    int m = matrix[0].size();

    if (n != m) return false;           // Must be square

    // Check elements below main diagonal
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (matrix[i][j] != 0)
                return false;           // Found non-zero below diagonal
        }
    }
    return true;
}

int main() {
    // Example 3x3 matrix
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {0, 5, 6},
        {0, 0, 9}
    };

    if (isUpperTriangularMatrix(matrix))
        cout << "The matrix is upper triangular.\n";
    else
        cout << "The matrix is NOT upper triangular.\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
0 5 6
0 0 9

Step: Check elements below main diagonal
(1,0)=0 ✔
(2,0)=0 ✔, (2,1)=0 ✔

All elements below diagonal are 0 → Upper triangular

```

---

## **Question: Check if a matrix is lower triangular.**

**Approach:**
Check if the matrix is square (rows == cols). If not, it cannot be lower triangular.

Traverse each element (i,j) above the main diagonal (i < j):

If any element matrix[i][j] != 0, return false.

If all elements above the diagonal are 0, return true.

Time Complexity (T): O(n²) — check relevant elements in n×n matrix.

Space Complexity (S): O(1) — no extra space.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to check if a matrix is lower triangular
bool isLowerTriangularMatrix(const vector<vector<int>>& matrix) {
    int n = matrix.size();
    if (n == 0) return false;            // Empty matrix cannot be lower triangular
    int m = matrix[0].size();

    if (n != m) return false;            // Must be square

    // Check elements above main diagonal
    for (int i = 0; i < n-1; i++) {
        for (int j = i+1; j < n; j++) {
            if (matrix[i][j] != 0)
                return false;            // Found non-zero above diagonal
        }
    }
    return true;
}

int main() {
    // Example 3x3 matrix
    vector<vector<int>> matrix = {
        {1, 0, 0},
        {4, 5, 0},
        {7, 8, 9}
    };

    if (isLowerTriangularMatrix(matrix))
        cout << "The matrix is lower triangular.\n";
    else
        cout << "The matrix is NOT lower triangular.\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 0 0
4 5 0
7 8 9

Step: Check elements above main diagonal
(0,1)=0 ✔, (0,2)=0 ✔
(1,2)=0 ✔

All elements above diagonal are 0 → Lower triangular

```

---

## **Question: Sum of upper triangular elements.**

**Approach:**
Traverse the matrix with nested loops.

For each element (i,j), if j >= i (on or above diagonal), add it to sum.

Return or print the sum.

Time Complexity (T): O(n²) — for n×n matrix.

Space Complexity (S): O(1) — only one variable for sum.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to calculate sum of upper triangular elements
int sumUpperTriangular(const vector<vector<int>>& matrix) {
    int n = matrix.size();
    if (n == 0) return 0;            // Empty matrix, sum = 0
    int m = matrix[0].size();

    if (n != m) {                     // Must be square
        cerr << "Error: Matrix is not square.\n";
        return -1;
    }

    int sum = 0;
    for (int i = 0; i < n; i++) {          // Rows
        for (int j = i; j < n; j++) {      // Columns on/above diagonal
            sum += matrix[i][j];
        }
    }

    return sum;
}

int main() {
    // Example 3x3 matrix
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int result = sumUpperTriangular(matrix);
    if (result != -1)
        cout << "Sum of upper triangular elements: " << result << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 2 3
4 5 6
7 8 9

Step: Sum elements where j >= i
(0,0)=1, (0,1)=2, (0,2)=3 → partial sum=6
(1,1)=5, (1,2)=6 → partial sum=17
(2,2)=9 → final sum=26

Output:
Sum of upper triangular elements: 26

```

---

## **Question: Determinant of a 2×2 matrix.**

**Approach:**
Check if the matrix is 2×2.

Apply the formula det = matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0].

Return or print the determinant.

Time Complexity (T): O(1) — constant time for 2×2.

Space Complexity (S): O(1) — only one variable for determinant.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to calculate determinant of 2x2 matrix
int determinant2x2(const vector<vector<int>>& matrix) {
    if (matrix.size() != 2 || matrix[0].size() != 2) {
        cerr << "Error: Matrix is not 2x2.\n";
        return 0;
    }

    // det = ad - bc
    int det = matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0];
    return det;
}

int main() {
    // Example 2x2 matrix
    vector<vector<int>> matrix = {
        {4, 3},
        {6, 3}
    };

    int det = determinant2x2(matrix);
    cout << "Determinant of the 2x2 matrix: " << det << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
4 3
6 3

Step: det = (4*3) - (3*6) = 12 - 18 = -6

Output:
Determinant of the 2x2 matrix: -6

```

---

## **Question: Check if a matrix is a magic square.**

**Approach:**
A magic square is a square matrix where:

All rows, columns, and both diagonals have the same sum.

Usually contains distinct positive integers, but here we focus on sum property.

Approach:

Check if the matrix is square (rows == cols).

Calculate the sum of the first row as the magicSum.

Check row sums: if any row sum ≠ magicSum, return false.

Check column sums: if any column sum ≠ magicSum, return false.

Check main diagonal sum and secondary diagonal sum: both must equal magicSum.

If all checks pass, matrix is a magic square.

Time Complexity (T): O(n²) — traverse all elements of n×n matrix.

Space Complexity (S): O(1) — only a few variables for sums.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to check if a square matrix is a magic square
bool isMagicSquare(const vector<vector<int>>& matrix) {
    int n = matrix.size();
    if (n == 0) return false;             // Empty matrix cannot be magic
    if (matrix[0].size() != n) return false; // Must be square

    int magicSum = 0;
    for (int j = 0; j < n; j++)          // Sum of first row
        magicSum += matrix[0][j];

    // Check sums of all rows
    for (int i = 1; i < n; i++) {
        int rowSum = 0;
        for (int j = 0; j < n; j++)
            rowSum += matrix[i][j];
        if (rowSum != magicSum)
            return false;
    }

    // Check sums of all columns
    for (int j = 0; j < n; j++) {
        int colSum = 0;
        for (int i = 0; i < n; i++)
            colSum += matrix[i][j];
        if (colSum != magicSum)
            return false;
    }

    // Check main diagonal sum
    int diag1 = 0;
    for (int i = 0; i < n; i++)
        diag1 += matrix[i][i];
    if (diag1 != magicSum)
        return false;

    // Check secondary diagonal sum
    int diag2 = 0;
    for (int i = 0; i < n; i++)
        diag2 += matrix[i][n-1-i];
    if (diag2 != magicSum)
        return false;

    return true; // All checks passed
}

int main() {
    // Example 3x3 magic square
    vector<vector<int>> matrix = {
        {2, 7, 6},
        {9, 5, 1},
        {4, 3, 8}
    };

    if (isMagicSquare(matrix))
        cout << "The matrix is a magic square.\n";
    else
        cout << "The matrix is NOT a magic square.\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
2 7 6
9 5 1
4 3 8

Step:
magicSum = sum of first row = 2+7+6=15

Check rows:

```

---

## **Question: Find saddle point in a matrix.**

**Approach:**
Detailed question & Approach:
A saddle point in a matrix is an element that is:

Minimum in its row

Maximum in its column

Approach:

Traverse each row and find the minimum element in that row.

Check if this minimum element is also the maximum in its column.

If yes, it is a saddle point.

There can be multiple saddle points.

Corner cases:

Empty matrix → no saddle point

Non-square matrix → valid, works for rectangular matrices

Time Complexity (T): O(m\*n²) — for each row, check column max

Space Complexity (S): O(1) — in-place check, no extra space

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find and print saddle points
void findSaddlePoints(const vector<vector<int>>& matrix) {
    int rows = matrix.size();
    if (rows == 0) {
        cout << "Matrix is empty.\n";
        return;
    }
    int cols = matrix[0].size();

    bool found = false;

    for (int i = 0; i < rows; i++) {
        // Find minimum in row i
        int rowMin = matrix[i][0];
        int colIndex = 0; // column index of row minimum
        for (int j = 1; j < cols; j++) {
            if (matrix[i][j] < rowMin) {
                rowMin = matrix[i][j];
                colIndex = j;
            }
        }

        // Check if rowMin is maximum in its column
        bool isSaddle = true;
        for (int k = 0; k < rows; k++) {
            if (matrix[k][colIndex] > rowMin) {
                isSaddle = false;
                break;
            }
        }

        if (isSaddle) {
            cout << "Saddle point at (" << i << "," << colIndex << ") = " << rowMin << endl;
            found = true;
        }
    }

    if (!found)
        cout << "No saddle point found.\n";
}

int main() {
    // Example 3x3 matrix
    vector<vector<int>> matrix = {
        {11, 12, 13},
        {21, 22, 23},
        {31, 32, 33}
    };

    findSaddlePoints(matrix);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
11 12 13
21 22 23
31 32 33

Row 0 min = 11 at col 0
Check column 0: 11,21,31 → 11 is NOT max → Not saddle

Row 1 min = 21 at col 0
Check column 0: 11,21,31 → 21 is NOT max → Not saddle

Row 2 min = 31 at col 0
Check column 0: 11,21,31 → 31 is max → Saddle point found at (2,0)=31

Output:
Saddle point at (2,0) = 31

```

---

## **Question: Row-wise & column-wise sorted matrix search (staircase search).**

**Approach:**
We are given a matrix where:

Each row is sorted in ascending order

Each column is sorted in ascending order

We need to search for a target element efficiently.

Staircase Search Approach:

Start from the top-right corner (i=0, j=cols-1).

While inside the matrix:

If matrix[i][j] == target → found

If matrix[i][j] > target → move left (j--)

If matrix[i][j] < target → move down (i++)

Stop when indices go out of bounds.

Time Complexity (T): O(m+n) — in each step, we move left or down

Space Complexity (S): O(1) — no extra space

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to search target in row-wise & column-wise sorted matrix
bool staircaseSearch(const vector<vector<int>>& matrix, int target) {
    int rows = matrix.size();
    if (rows == 0) return false;      // Empty matrix
    int cols = matrix[0].size();

    int i = 0, j = cols - 1;          // Start from top-right corner

    while (i < rows && j >= 0) {
        if (matrix[i][j] == target) {
            cout << "Element found at (" << i << "," << j << ")\n";
            return true;
        } else if (matrix[i][j] > target) {
            j--; // Move left
        } else {
            i++; // Move down
        }
    }

    cout << "Element not found in the matrix.\n";
    return false;
}

int main() {
    // Example 4x4 row-wise & column-wise sorted matrix
    vector<vector<int>> matrix = {
        {10, 20, 30, 40},
        {15, 25, 35, 45},
        {27, 29, 37, 48},
        {32, 33, 39, 50}
    };

    int target = 29;
    staircaseSearch(matrix, target);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
10 20 30 40
15 25 35 45
27 29 37 48
32 33 39 50

Target = 29
Start at (0,3)=40 → 40>29 → move left
(0,2)=30 → 30>29 → move left
(0,1)=20 → 20<29 → move down
(1,1)=25 → 25<29 → move down
(2,1)=29 → Found

Output: Element found at (2,1)

```

---

## **Question: Binary search in a row-wise sorted matrix.**

**Approach:**
We are given a matrix where each row is sorted in ascending order.
We need to search for a target element efficiently using binary search in each row.

Approach:

Traverse each row of the matrix.

Apply binary search on that row:

Initialize low = 0, high = cols - 1.

While low <= high:

mid = (low + high)/2

If matrix[row][mid] == target → found

If matrix[row][mid] < target → search right (low = mid+1)

If matrix[row][mid] > target → search left (high = mid-1)

If target not found in any row, return not found.

Time Complexity (T): O(m \* log n) → binary search in each of m rows

Space Complexity (S): O(1) → no extra space

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to perform binary search in a single row
bool binarySearchRow(const vector<int>& row, int target, int rowIndex) {
    int low = 0, high = row.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (row[mid] == target) {
            cout << "Element found at (" << rowIndex << "," << mid << ")\n";
            return true;
        } else if (row[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return false;
}

// Function to search target in a row-wise sorted matrix
bool binarySearchRowWise(const vector<vector<int>>& matrix, int target) {
    int rows = matrix.size();
    if (rows == 0) return false;      // Empty matrix
    int cols = matrix[0].size();

    for (int i = 0; i < rows; i++) {
        if (binarySearchRow(matrix[i], target, i))
            return true;
    }

    cout << "Element not found in the matrix.\n";
    return false;
}

int main() {
    // Example 4x4 row-wise sorted matrix
    vector<vector<int>> matrix = {
        {1, 4, 7, 10},
        {2, 5, 8, 11},
        {3, 6, 9, 12},
        {13, 14, 15, 16}
    };

    int target = 9;
    binarySearchRowWise(matrix, target);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1  4  7  10
2  5  8  11
3  6  9  12
13 14 15 16

Target = 9

Row 0: binary search → not found
Row 1: binary search → not found
Row 2: binary search → mid=1(6)<9 → right, mid=2(9)=9 → Found at (2,2)

Output: Element found at (2,2)

```

---

## **Question: Find row with maximum 1s.**

**Approach:**
We are given a binary matrix (0s and 1s) where each row is sorted (0s followed by 1s).
We need to find the row with the maximum number of 1s efficiently.

Optimized Approach (Staircase method):

Start from the top-right corner (i=0, j=cols-1).

Initialize maxRow = -1.

While inside the matrix:

If matrix[i][j] == 1:

Move left (j--) and update maxRow = i.

Else (matrix[i][j] == 0):

Move down (i++).

Continue until indices go out of bounds.

Why efficient:

Each step moves left or down, at most rows + cols steps.

Time Complexity (T): O(rows + cols)

Space Complexity (S): O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find row with maximum 1s
int rowWithMaxOnes(const vector<vector<int>>& matrix) {
    int rows = matrix.size();
    if (rows == 0) return -1;          // Empty matrix
    int cols = matrix[0].size();

    int maxRow = -1;                    // Initialize result
    int i = 0, j = cols - 1;            // Start from top-right corner

    while (i < rows && j >= 0) {
        if (matrix[i][j] == 1) {
            maxRow = i; // update max row
            j--;        // move left
        } else {
            i++;        // move down
        }
    }

    return maxRow;
}

int main() {
    // Example 4x5 binary matrix (row-wise sorted)
    vector<vector<int>> matrix = {
        {0, 0, 0, 1, 1},
        {0, 1, 1, 1, 1},
        {0, 0, 1, 1, 1},
        {0, 0, 0, 0, 1}
    };

    int maxRow = rowWithMaxOnes(matrix);
    if (maxRow != -1)
        cout << "Row with maximum 1s: " << maxRow << endl;
    else
        cout << "Matrix is empty or no 1s found.\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
0 0 0 1 1
0 1 1 1 1
0 0 1 1 1
0 0 0 0 1

Start at (0,4)=1 → move left → maxRow=0, j=3
(0,3)=1 → move left → maxRow=0, j=2
(0,2)=0 → move down i=1
(1,2)=1 → move left → maxRow=1, j=1
(1,1)=1 → move left → maxRow=1, j=0
(1,0)=0 → move down i=2
(2,0)=0 → move down i=3
(3,0)=0 → move down i=4 → exit

Result: maxRow=1

```

---

## **Question: Count zeros in row/column sorted matrix.**

**Approach:**
Detailed question & Approach:
We are given a binary matrix (0s and 1s) where each row and column is sorted in ascending order:

All 0s appear before 1s in each row

All 0s appear before 1s in each column

We need to count total zeros efficiently.

Optimized Approach (Staircase method):

Start from the bottom-left corner (i=rows-1, j=0).

Initialize count = 0.

While inside the matrix:

If matrix[i][j] == 0:

All elements above in the same column are also 0 → add (i+1) to count.

Move right (j++).

Else (matrix[i][j] == 1):

Move up (i--).

Stop when indices go out of bounds.

Why efficient:

Each step moves right or up, at most rows + cols steps.

Time Complexity (T): O(rows + cols)

Space Complexity (S): O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to count zeros in a row & column sorted binary matrix
int countZeros(const vector<vector<int>>& matrix) {
    int rows = matrix.size();
    if (rows == 0) return 0;            // Empty matrix
    int cols = matrix[0].size();

    int count = 0;
    int i = rows - 1, j = 0;            // Start from bottom-left corner

    while (i >= 0 && j < cols) {
        if (matrix[i][j] == 0) {
            count += (i + 1);           // All elements above are zeros
            j++;                        // Move right
        } else {
            i--;                        // Move up
        }
    }

    return count;
}

int main() {
    // Example 4x5 row & column sorted binary matrix
    vector<vector<int>> matrix = {
        {0, 0, 0, 1, 1},
        {0, 0, 1, 1, 1},
        {0, 1, 1, 1, 1},
        {0, 1, 1, 1, 1}
    };

    int totalZeros = countZeros(matrix);
    cout << "Total zeros in the matrix: " << totalZeros << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
0 0 0 1 1
0 0 1 1 1
0 1 1 1 1
0 1 1 1 1

Start at (3,0)=0 → add 4 (i+1), j=1, count=4
(3,1)=1 → move up i=2
(2,1)=1 → move up i=1
(1,1)=0 → add 2 (i+1), j=2, count=6
(1,2)=1 → move up i=0
(0,2)=0 → add 1 (i+1), j=3, count=7
(0,3)=1 → move up i=-1 → exit

Total zeros = 7

```

---

## **Question: Flatten a 2D matrix into 1D and sort.**

**Approach:**
Question: Flatten a 2D Matrix into 1D and Sort

Approach:
We are given a 2D matrix and need to convert it into a 1D array (vector) and sort it.

Steps:

1. Initialize an empty 1D vector.
2. Traverse each row and each column of the 2D matrix:
   - Push each element into the 1D vector.
3. Use a built-in sort function to sort the 1D vector in ascending order.
4. Return or print the sorted 1D array.

Time Complexity: O(m*n*log(m*n)) → traversing m*n elements and sorting them
Space Complexity: O(m\*n) → for the 1D vector

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for sort
using namespace std;

// Function to flatten a 2D matrix into 1D and sort
vector<int> flattenAndSort(const vector<vector<int>>& matrix) {
    vector<int> flat;                 // 1D vector to store elements
    for (int i = 0; i < matrix.size(); i++) {
        for (int j = 0; j < matrix[i].size(); j++) {
            flat.push_back(matrix[i][j]); // push element into 1D vector
        }
    }

    sort(flat.begin(), flat.end());    // sort the vector
    return flat;
}

int main() {
    // Example 2D matrix
    vector<vector<int>> matrix = {
        {3, 1, 4},
        {2, 5, 6},
        {9, 8, 7}
    };

    vector<int> sorted1D = flattenAndSort(matrix);

    cout << "Flattened and sorted 1D array: ";
    for (int num : sorted1D) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
3 1 4
2 5 6
9 8 7

Step 1: Flatten
flat = [3,1,4,2,5,6,9,8,7]

Step 2: Sort
flat = [1,2,3,4,5,6,7,8,9]

Output: Flattened and sorted 1D array: 1 2 3 4 5 6 7 8 9

```

---

## **Question: Title**

**Approach:**
Question: Sort Each Row Individually in a Matrix

Approach:
We are given a 2D matrix and need to sort each row individually in ascending order.

Steps:

1. Traverse each row of the matrix.
2. Apply a built-in sort function on that row.
3. Print or return the updated matrix.

Time Complexity: O(m \* n log n) → sorting each of m rows containing n elements
Space Complexity: O(1) → in-place sorting, no extra space used

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for sort
using namespace std;

// Function to sort each row of the matrix individually
void sortRows(vector<vector<int>>& matrix) {
    for (int i = 0; i < matrix.size(); i++) {
        sort(matrix[i].begin(), matrix[i].end()); // sort row i
    }
}

int main() {
    // Example 3x4 matrix
    vector<vector<int>> matrix = {
        {3, 1, 4, 2},
        {9, 6, 8, 7},
        {5, 0, 2, 1}
    };

    sortRows(matrix);

    cout << "Matrix after sorting each row:\n";
    for (auto &row : matrix) {
        for (int val : row) {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for sort
using namespace std;

// Function to sort each row of the matrix individually
void sortRows(vector<vector<int>>& matrix) {
    for (int i = 0; i < matrix.size(); i++) {
        sort(matrix[i].begin(), matrix[i].end()); // sort row i
    }
}

int main() {
    // Example 3x4 matrix
    vector<vector<int>> matrix = {
        {3, 1, 4, 2},
        {9, 6, 8, 7},
        {5, 0, 2, 1}
    };

    sortRows(matrix);

    cout << "Matrix after sorting each row:\n";
    for (auto &row : matrix) {
        for (int val : row) {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}
// End of code

```

---

## **Question: Sort each column individually.**

**Approach:**
Question: Sort Each Column Individually in a Matrix

Approach:
We are given a 2D matrix and need to sort each column individually in ascending order.

Steps:

1. Determine the number of rows and columns.
2. Traverse each column:
   - Extract all elements of that column into a temporary vector.
   - Sort the temporary vector.
   - Put the sorted elements back into the column.
3. Print or return the updated matrix.

Time Complexity: O(n \* m log m) → sorting each of n columns with m elements
Space Complexity: O(m) → temporary vector to store column elements

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for sort
using namespace std;

// Function to sort each column of the matrix individually
void sortColumns(vector<vector<int>>& matrix) {
    int rows = matrix.size();
    if (rows == 0) return;
    int cols = matrix[0].size();

    for (int j = 0; j < cols; j++) {          // For each column
        vector<int> colElements;
        for (int i = 0; i < rows; i++) {
            colElements.push_back(matrix[i][j]); // Extract column
        }

        sort(colElements.begin(), colElements.end()); // Sort column

        for (int i = 0; i < rows; i++) {
            matrix[i][j] = colElements[i];         // Put back sorted
        }
    }
}

int main() {
    // Example 3x4 matrix
    vector<vector<int>> matrix = {
        {3, 1, 4, 2},
        {9, 6, 8, 7},
        {5, 0, 2, 1}
    };

    sortColumns(matrix);

    cout << "Matrix after sorting each column:\n";
    for (auto &row : matrix) {
        for (int val : row) {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original Matrix:
3 1 4 2
9 6 8 7
5 0 2 1

Step 1: Sort each column
Column 0: 3 9 5 → 3 5 9
Column 1: 1 6 0 → 0 1 6
Column 2: 4 8 2 → 2 4 8
Column 3: 2 7 1 → 1 2 7

Output:
3 0 2 1
5 1 4 2
9 6 8 7

```

---

## **Question: Find median of a row-wise sorted matrix.**

**Approach:**
Question: Find Median of a Row-wise Sorted Matrix

Approach:
We are given a matrix where each row is sorted in ascending order. We need to find the median of all elements in the matrix.

Steps:

1. Flatten the matrix into a 1D array by traversing each row and column.
2. Sort the 1D array.
3. Find the middle element(s):
   - If total elements are odd, median = middle element.
   - If total elements are even, median = average of the two middle elements.
4. Return or print the median.

Time Complexity: O(m*n*log(m*n)) → flatten + sort
Space Complexity: O(m*n) → for flattened array

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Function to find median of a row-wise sorted matrix
double findMedian(const vector<vector<int>>& matrix) {
    vector<int> flat;

    for (auto &row : matrix) {
        for (int val : row) {
            flat.push_back(val); // Flatten the matrix
        }
    }

    sort(flat.begin(), flat.end()); // Sort the 1D array

    int n = flat.size();
    if (n % 2 == 1) {
        return flat[n / 2];       // Odd number of elements
    } else {
        return (flat[n/2 - 1] + flat[n/2]) / 2.0; // Even number
    }
}

int main() {
    // Example 3x3 row-wise sorted matrix
    vector<vector<int>> matrix = {
        {1, 3, 5},
        {2, 6, 9},
        {3, 6, 9}
    };

    double median = findMedian(matrix);
    cout << "Median of the matrix: " << median << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 3 5
2 6 9
3 6 9

Step 1: Flatten
flat = [1,3,5,2,6,9,3,6,9]

Step 2: Sort
flat = [1,2,3,3,5,6,6,9,9]

Step 3: Total elements = 9 (odd)
Median = flat[9/2] = flat[4] = 5

Output: Median of the matrix: 5

```

---

## **Question: Find kth smallest element (basic method using sorting).**

**Approach:**
Question: Find Kth Smallest Element in a Matrix (Basic Method Using Sorting)

Approach:
We are given a matrix (can be any 2D matrix) and need to find the kth smallest element using a basic method.

Steps:

1. Flatten the matrix into a 1D array.
2. Sort the 1D array in ascending order.
3. Return the element at index k-1 (0-based indexing) as the kth smallest element.

Time Complexity: O(m*n*log(m*n)) → flatten + sort
Space Complexity: O(m*n) → for flattened array

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Function to find kth smallest element using basic sort method
int kthSmallest(const vector<vector<int>>& matrix, int k) {
    vector<int> flat;

    for (auto &row : matrix) {
        for (int val : row) {
            flat.push_back(val); // Flatten the matrix
        }
    }

    sort(flat.begin(), flat.end()); // Sort the 1D array

    if (k <= 0 || k > flat.size()) {
        cerr << "Error: k is out of range.\n";
        return -1;
    }

    return flat[k - 1]; // kth smallest
}

int main() {
    // Example 3x3 matrix
    vector<vector<int>> matrix = {
        {1, 5, 9},
        {10, 11, 13},
        {12, 13, 15}
    };

    int k = 8;
    int result = kthSmallest(matrix, k);

    if (result != -1)
        cout << k << "th smallest element: " << result << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 5 9
10 11 13
12 13 15

Step 1: Flatten
flat = [1,5,9,10,11,13,12,13,15]

Step 2: Sort
flat = [1,5,9,10,11,12,13,13,15]

Step 3: k = 8 → kth smallest = flat[7] = 13

Output:
8th smallest element: 13

```

---

## **Question: Find kth largest element (basic method).**

**Approach:**
Question: Find Kth Largest Element in a Matrix (Basic Method Using Sorting)

Approach:
We are given a matrix and need to find the kth largest element using a basic method.

Steps:

1. Flatten the matrix into a 1D array.
2. Sort the 1D array in ascending order.
3. Return the element at index (size - k) as the kth largest element.

Time Complexity: O(m*n*log(m*n)) → flatten + sort
Space Complexity: O(m*n) → for flattened array

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Function to find kth largest element using basic sort method
int kthLargest(const vector<vector<int>>& matrix, int k) {
    vector<int> flat;

    for (auto &row : matrix) {
        for (int val : row) {
            flat.push_back(val); // Flatten the matrix
        }
    }

    sort(flat.begin(), flat.end()); // Sort the 1D array

    int n = flat.size();
    if (k <= 0 || k > n) {
        cerr << "Error: k is out of range.\n";
        return -1;
    }

    return flat[n - k]; // kth largest
}

int main() {
    // Example 3x3 matrix
    vector<vector<int>> matrix = {
        {1, 5, 9},
        {10, 11, 13},
        {12, 13, 15}
    };

    int k = 4;
    int result = kthLargest(matrix, k);

    if (result != -1)
        cout << k << "th largest element: " << result << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 5 9
10 11 13
12 13 15

Step 1: Flatten
flat = [1,5,9,10,11,13,12,13,15]

Step 2: Sort
flat = [1,5,9,10,11,12,13,13,15]

Step 3: k = 4 → kth largest = flat[9 - 4] = flat[5] = 12

Output:
4th largest element: 12

```

---
