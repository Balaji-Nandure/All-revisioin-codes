## **Question: 1 Reverse a string Traversal / swap**

**Approach:**
Question: Reverse a string

Approach:

1. Use two pointers: one at the start, one at the end of the string.
2. Swap the characters at the two pointers.
3. Move start pointer forward and end pointer backward.
4. Repeat until the pointers meet or cross.
   Time Complexity: O(n) – each character is visited once.
   Space Complexity: O(1) – in-place reversal.
   Notes:

- Works for any character string.
- Can also be implemented using built-in functions, but two-pointer method is optimal for interviews.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to reverse a string in-place
void reverseString(string &s) {
    int left = 0;                  // Start pointer
    int right = s.length() - 1;    // End pointer

    while(left < right) {          // Traverse until pointers meet
        swap(s[left], s[right]);  // Swap characters
        left++;                    // Move start forward
        right--;                   // Move end backward
    }
}

int main() {
    string s = "HelloWorld";

    cout << "Original String: " << s << endl;

    reverseString(s);

    cout << "Reversed String: " << s << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "HelloWorld"
left=0, right=9 → swap 'H' and 'd' → delloWorlH
left=1, right=8 → swap 'e' and 'l' → dlloWoreH
left=2, right=7 → swap 'l' and 'r' → drloWolleH
left=3, right=6 → swap 'l' and 'o' → droWlolleH
left=4, right=5 → swap 'o' and 'W' → dlroWolleH
left=5, right=4 → pointers crossed → stop

Final String: "dlroWolleH"

```

---

## **Question: 2 Check if string is palindrome Two-pointer**

**Approach:**
Question: Check if string is palindrome

Approach:

1. Use two pointers: one at the start, one at the end of the string.
2. Compare characters at the two pointers.
3. If characters are equal, move start forward and end backward.
4. If any mismatch is found, the string is not a palindrome.
5. If pointers cross without mismatch, the string is a palindrome.
   Time Complexity: O(n) – each character is visited at most once.
   Space Complexity: O(1) – in-place comparison.
   Notes:

- Works for any string.
- Can be extended to ignore spaces and punctuation if needed.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to check if a string is palindrome
bool isPalindrome(const string &s) {
    int left = 0;                 // Start pointer
    int right = s.length() - 1;   // End pointer

    while(left < right) {         // Traverse until pointers meet
        if(s[left] != s[right])   // Check mismatch
            return false;         // Not a palindrome
        left++;                   // Move start forward
        right--;                  // Move end backward
    }
    return true;                  // All characters matched
}

int main() {
    string s = "racecar";

    cout << "String: " << s << endl;

    if(isPalindrome(s))
        cout << "Palindrome" << endl;
    else
        cout << "Not a palindrome" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "racecar"
left=0, right=6 → s[0]=r, s[6]=r → match → left=1, right=5
left=1, right=5 → s[1]=a, s[5]=a → match → left=2, right=4
left=2, right=4 → s[2]=c, s[4]=c → match → left=3, right=3
Pointers crossed → All matched → Palindrome

```

---

## **Question: 3 Count vowels and consonants Traversal**

**Approach:**
Question: Count vowels and consonants in a string

Approach:

1. Initialize two counters: vowels = 0, consonants = 0.
2. Traverse each character in the string.
3. If the character is a letter:
   a. Check if it is a vowel (a, e, i, o, u, A, E, I, O, U). - If yes, increment vowels. - Else, increment consonants.
4. Ignore non-alphabetic characters.
   Time Complexity: O(n) – each character is visited once.
   Space Complexity: O(1) – only two counters used.
   Notes:

- Works for mixed case letters.
- Can be extended to count digits and special characters if needed.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to count vowels and consonants
void countVowelsConsonants(const string &s, int &vowels, int &consonants) {
    vowels = 0;
    consonants = 0;

    for(char c : s) {                // Traverse each character
        if((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {  // Check if alphabet
            char lowerC = tolower(c);  // Convert to lowercase for uniformity
            if(lowerC == 'a' || lowerC == 'e' || lowerC == 'i' || lowerC == 'o' || lowerC == 'u')
                vowels++;              // Increment vowels
            else
                consonants++;          // Increment consonants
        }
        // Ignore non-alphabetic characters
    }
}

int main() {
    string s = "Hello World!";

    int vowels, consonants;
    countVowelsConsonants(s, vowels, consonants);

    cout << "String: " << s << endl;
    cout << "Vowels: " << vowels << endl;
    cout << "Consonants: " << consonants << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "Hello World!"
Traversal:
H → consonant → consonants=1
e → vowel → vowels=1
l → consonant → consonants=2
l → consonant → consonants=3
o → vowel → vowels=2
' ' → ignore
W → consonant → consonants=4
o → vowel → vowels=3
r → consonant → consonants=5
l → consonant → consonants=6
d → consonant → consonants=7
! → ignore

Final Count: Vowels=3, Consonants=7

```

---

## **Question: 4 Find length of string without built-in function Traversal**

**Approach:**
Question: Find the length of a string without using built-in functions like .length() or .size()

Approach:

1. Initialize a counter variable `length = 0`.
2. Traverse each character of the string until the null character or end is reached.
3. Increment the counter for each character.
4. Return the counter as the length of the string.
   Time Complexity: O(n) – each character is visited once.
   Space Complexity: O(1) – only a single counter used.
   Notes:

- Works for any string.
- Demonstrates understanding of string traversal.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to find length of string without built-in function
int stringLength(const string &s) {
    int length = 0;                  // Initialize counter
    for(char c : s) {                // Traverse each character
        length++;                    // Increment counter
    }
    return length;                   // Return length
}

int main() {
    string s = "HelloWorld";

    int len = stringLength(s);

    cout << "String: " << s << endl;
    cout << "Length: " << len << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "HelloWorld"
Traversal:
H → length=1
e → length=2
l → length=3
l → length=4
o → length=5
W → length=6
o → length=7
r → length=8
l → length=9
d → length=10
Traversal complete

Final Length = 10

```

---

## **Question: 5 Compare two strings lexicographically Traversal / comparison**

**Approach:**
Question: Compare two strings lexicographically without using built-in comparison functions.

Approach:

1. Traverse both strings character by character from start.
2. For each position:
   a. If characters differ, return which string is smaller/greater based on ASCII value.
   b. If characters are same, continue to next character.
3. If all characters match, the shorter string is lexicographically smaller.
   Time Complexity: O(min(n, m)) – traverse until mismatch or end of shorter string.
   Space Complexity: O(1) – no extra space used.
   Notes:

- Lexicographical order compares ASCII values.
- Works for uppercase and lowercase letters (case-sensitive).

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to compare two strings lexicographically
int compareStrings(const string &s1, const string &s2) {
    int n = s1.length();
    int m = s2.length();
    int len = min(n, m);  // Compare up to the shorter string

    for(int i = 0; i < len; i++) {
        if(s1[i] < s2[i])      // s1 is smaller
            return -1;
        else if(s1[i] > s2[i]) // s1 is greater
            return 1;
        // else continue
    }

    // If all matched, shorter string is smaller
    if(n < m) return -1;
    else if(n > m) return 1;
    else return 0;  // Strings are equal
}

int main() {
    string str1 = "apple";
    string str2 = "apricot";

    cout << "String 1: " << str1 << endl;
    cout << "String 2: " << str2 << endl;

    int res = compareStrings(str1, str2);

    if(res == 0) cout << "Strings are equal" << endl;
    else if(res < 0) cout << "String 1 is lexicographically smaller" << endl;
    else cout << "String 1 is lexicographically greater" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
str1 = "apple"
str2 = "apricot"
Compare character by character:
i=0: 'a' vs 'a' → match
i=1: 'p' vs 'p' → match
i=2: 'p' vs 'r' → 'p' < 'r' → String 1 is smaller
Stop comparison

```

---

## **Question: 6 Concatenate two strings without using + Traversal / append**

**Approach:**
Question: Concatenate two strings without using the '+' operator.

Approach:

1. Initialize a result string as a copy of the first string.
2. Traverse each character of the second string.
3. Append each character of the second string to the result string using .push_back() or .append(1 char).
4. Return the concatenated result.
   Time Complexity: O(n + m) – traverse both strings once.
   Space Complexity: O(n + m) – space used for the resulting concatenated string.
   Notes:

- Works for any combination of characters.
- Demonstrates understanding of string traversal and appending.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to concatenate two strings without using '+'
string concatenateStrings(const string &s1, const string &s2) {
    string result = s1;              // Initialize result with first string

    for(char c : s2) {               // Traverse second string
        result.push_back(c);         // Append each character
    }

    return result;                   // Return concatenated string
}

int main() {
    string str1 = "Hello";
    string str2 = "World";

    cout << "String 1: " << str1 << endl;
    cout << "String 2: " << str2 << endl;

    string concatenated = concatenateStrings(str1, str2);

    cout << "Concatenated String: " << concatenated << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
str1 = "Hello"
str2 = "World"
Initialize result = "Hello"
Traverse str2:
  'W' → result = "HelloW"
  'o' → result = "HelloWo"
  'r' → result = "HelloWor"
  'l' → result = "HelloWorl"
  'd' → result = "HelloWorld"
Final concatenated string: "HelloWorld"

```

---

## **Question: 7 Convert string to uppercase / lowercase Traversal**

**Approach:**
Question: Convert a string to uppercase or lowercase without using built-in functions like toupper/tolower (optional use of ASCII arithmetic).

Approach:

1. Traverse each character of the string.
2. For uppercase conversion:
   a. If character is lowercase ('a'-'z'), subtract 32 from ASCII value.
3. For lowercase conversion:
   a. If character is uppercase ('A'-'Z'), add 32 to ASCII value.
4. Update the string in-place or return a new string.
   Time Complexity: O(n) – each character is visited once.
   Space Complexity: O(1) – in-place conversion.
   Notes:

- Works for alphabetic characters.
- Non-alphabetic characters remain unchanged.
- ASCII difference between lowercase and uppercase letters is 32.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to convert string to uppercase
void toUpperCase(string &s) {
    for(char &c : s) {                  // Traverse each character
        if(c >= 'a' && c <= 'z') {      // Check if lowercase
            c = c - ('a' - 'A');        // Convert to uppercase
        }
    }
}

// Function to convert string to lowercase
void toLowerCase(string &s) {
    for(char &c : s) {                  // Traverse each character
        if(c >= 'A' && c <= 'Z') {      // Check if uppercase
            c = c + ('a' - 'A');        // Convert to lowercase
        }
    }
}

int main() {
    string s = "Hello World!";

    cout << "Original String: " << s << endl;

    toUpperCase(s);
    cout << "Uppercase String: " << s << endl;

    toLowerCase(s);
    cout << "Lowercase String: " << s << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original String: "Hello World!"
Convert to Uppercase:
'H' → 'H' (already uppercase)
'e' → 'E'
'l' → 'L'
'l' → 'L'
'o' → 'O'
' ' → ' ' (unchanged)
'W' → 'W'
'o' → 'O'
'r' → 'R'
'l' → 'L'
'd' → 'D'
'!' → '!' (unchanged)
Result: "HELLO WORLD!"

Convert to Lowercase:
'H' → 'h'
'E' → 'e'
'L' → 'l'
'L' → 'l'
'O' → 'o'
' ' → ' ' (unchanged)
'W' → 'w'
'O' → 'o'
'R' → 'r'
'L' → 'l'
'D' → 'd'
'!' → '!' (unchanged)
Result: "hello world!"

```

---

## **Question: 8 Remove all spaces from string Traversal / filtering**

**Approach:**
Question: Remove all spaces from a given string.

Approach:

1. Initialize an empty string `result`.
2. Traverse each character of the input string.
3. If the character is not a space, append it to `result`.
4. Return or update the string with `result`.
   Time Complexity: O(n) – each character is visited once.
   Space Complexity: O(n) – new string used to store filtered characters.
   Notes:

- Can also be done in-place using two pointers to reduce space.
- Works for multiple consecutive spaces as well.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to remove all spaces from string
string removeSpaces(const string &s) {
    string result;                      // Initialize empty result string

    for(char c : s) {                   // Traverse each character
        if(c != ' ') {                  // Check if character is not space
            result.push_back(c);        // Append non-space character
        }
    }

    return result;                      // Return filtered string
}

int main() {
    string s = "H e l l o   W o r l d";

    cout << "Original String: \"" << s << "\"" << endl;

    string noSpaces = removeSpaces(s);

    cout << "String without spaces: \"" << noSpaces << "\"" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original String: "H e l l o   W o r l d"
Traversal:
'H' → append → "H"
' ' → skip
'e' → append → "He"
' ' → skip
'l' → append → "Hel"
'l' → append → "Hell"
'o' → append → "Hello"
' ' → skip
' ' → skip
' ' → skip
'W' → append → "HelloW"
'o' → append → "HelloWo"
'r' → append → "HelloWor"
'l' → append → "HelloWorl"
'd' → append → "HelloWorld"
Result: "HelloWorld"

```

---

## **Question: 9 Reverse words in a sentence Split + reverse**

**Approach:**
Question: Reverse the order of words in a sentence.

Approach:

1. Split the sentence into words using spaces as delimiters.
2. Store the words in a vector or array.
3. Reverse the vector/array of words.
4. Join the words back into a string with spaces.
   Time Complexity: O(n) – traverse each character once for split, then reverse vector.
   Space Complexity: O(n) – to store words.
   Notes:

- Preserves the characters in each word; only word order changes.
- Handles multiple spaces by ignoring empty splits if needed.

**Code:**

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

// Function to reverse words in a sentence
string reverseWords(const string &sentence) {
    vector<string> words;               // Store individual words
    string word;

    for(char c : sentence) {            // Traverse each character
        if(c == ' ') {                  // Word boundary
            if(!word.empty()) {         // Avoid multiple spaces
                words.push_back(word);  // Store word
                word.clear();           // Reset for next word
            }
        } else {
            word.push_back(c);          // Build current word
        }
    }
    if(!word.empty()) {                  // Add last word
        words.push_back(word);
    }

    // Reverse the words
    int left = 0, right = words.size() - 1;
    while(left < right) {
        swap(words[left], words[right]);
        left++;
        right--;
    }

    // Join words into a sentence
    string reversedSentence;
    for(size_t i = 0; i < words.size(); i++) {
        reversedSentence += words[i];
        if(i != words.size() - 1)
            reversedSentence += ' ';
    }

    return reversedSentence;
}

int main() {
    string sentence = "Hello world this is CP";

    cout << "Original Sentence: \"" << sentence << "\"" << endl;

    string reversed = reverseWords(sentence);

    cout << "Reversed Words Sentence: \"" << reversed << "\"" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original Sentence: "Hello world this is CP"
Split words:
words = ["Hello", "world", "this", "is", "CP"]
Reverse words:
words = ["CP", "is", "this", "world", "Hello"]
Join words:
"CP is this world Hello"

```

---

## **Question: 10 Rotate string by k positions Substring + concatenation**

**Approach:**
Question: Rotate a string by k positions.

Approach:

1. For left rotation by k positions:
   a. Take substring from index k to end.
   b. Take substring from index 0 to k-1.
   c. Concatenate them: newString = s[k..end] + s[0..k-1].
2. For right rotation by k positions:
   a. Right rotation by k is equivalent to left rotation by n-k.
3. Handle k > n using k = k % n.
   Time Complexity: O(n) – substring and concatenation traverse string once.
   Space Complexity: O(n) – new string used for rotation.
   Notes:

- Works for any string.
- Can be implemented in-place using reversal method to optimize space.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to rotate string by k positions (left rotation)
string rotateString(const string &s, int k) {
    int n = s.length();
    if(n == 0) return s;          // Empty string check
    k = k % n;                     // Handle k > n

    string rotated = s.substr(k) + s.substr(0, k);  // Concatenate substrings
    return rotated;
}

int main() {
    string s = "HelloWorld";
    int k = 3;  // Rotate left by 3 positions

    cout << "Original String: " << s << endl;

    string rotated = rotateString(s, k);

    cout << "Rotated String by " << k << " positions: " << rotated << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Original String: "HelloWorld"
k = 3
s.substr(k) → s[3..9] = "loWorld"
s.substr(0,k) → s[0..2] = "Hel"
Concatenate → "loWorld" + "Hel" = "loWorldHel"

```

---

## **Question: 11 Naive pattern search Sliding window / comparison**

**Approach:**
Question: Search for all occurrences of a pattern in a text using the naive method.

Approach:

1. Let text length = n, pattern length = m.
2. Traverse text from index 0 to n-m:
   a. For each position, check if substring text[i..i+m-1] matches the pattern.
   b. If all characters match, record the position.
3. Continue for all positions in text.
   Time Complexity: O(n\*m) – for each starting position, compare up to m characters.
   Space Complexity: O(1) – only pointers/counters used.
   Notes:

- Works for small inputs efficiently.
- Simple to implement; not efficient for large text/pattern.

**Code:**

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

// Function to find all occurrences of pattern in text using naive approach
vector<int> naivePatternSearch(const string &text, const string &pattern) {
    vector<int> occurrences;           // Store starting indices of matches
    int n = text.length();
    int m = pattern.length();

    for(int i = 0; i <= n - m; i++) { // Traverse all possible start positions
        bool match = true;
        for(int j = 0; j < m; j++) {  // Compare pattern with substring
            if(text[i + j] != pattern[j]) {
                match = false;
                break;                 // Stop on first mismatch
            }
        }
        if(match) {
            occurrences.push_back(i);  // Record match starting index
        }
    }

    return occurrences;
}

int main() {
    string text = "ABABABCABAB";
    string pattern = "ABAB";

    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;

    vector<int> result = naivePatternSearch(text, pattern);

    cout << "Pattern found at indices: ";
    for(int idx : result) {
        cout << idx << " ";
    }
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Text = "ABABABCABAB", Pattern = "ABAB"
i=0 → text[0..3] = "ABAB" → match → record 0
i=1 → text[1..4] = "BABA" → mismatch
i=2 → text[2..5] = "ABAB" → match → record 2
i=3 → text[3..6] = "BABC" → mismatch
i=4 → text[4..7] = "ABCA" → mismatch
i=5 → text[5..8] = "BCAB" → mismatch
i=6 → text[6..9] = "CABA" → mismatch
i=7 → text[7..10] = "ABAB" → match → record 7

Final Occurrences: 0, 2, 7

```

---

## **Question: 12 KMP algorithm for pattern search Preprocessing LPS array**

**Approach:**
Question: Search for all occurrences of a pattern in a text using the KMP algorithm.

Approach:

1. Preprocess the pattern to create LPS (Longest Prefix Suffix) array:
   - lps[i] = length of the longest proper prefix which is also a suffix for pattern[0..i].
2. Traverse the text using two pointers: i for text, j for pattern.
   a. If text[i] == pattern[j], increment both i and j.
   b. If j reaches pattern length → pattern found → record index → set j = lps[j-1].
   c. If mismatch:
   - If j != 0 → set j = lps[j-1] (use previous info)
   - Else → increment i.
3. Continue until end of text.
   Time Complexity: O(n + m) – each character is visited at most twice.
   Space Complexity: O(m) – LPS array for pattern.
   Notes:

- Efficient for large text/pattern.
- Handles overlapping patterns automatically.

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Function to compute LPS array for pattern
vector<int> computeLPS(const string &pattern) {
    int m = pattern.length();
    vector<int> lps(m, 0);           // Initialize LPS array
    int len = 0;                      // Length of previous longest prefix suffix
    int i = 1;

    while(i < m) {
        if(pattern[i] == pattern[len]) {  // Match
            len++;
            lps[i] = len;
            i++;
        } else {                          // Mismatch
            if(len != 0) {
                len = lps[len - 1];       // Use previous LPS
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }

    return lps;
}

// KMP search function
vector<int> KMPSearch(const string &text, const string &pattern) {
    vector<int> occurrences;
    int n = text.length();
    int m = pattern.length();
    vector<int> lps = computeLPS(pattern);  // Preprocess pattern

    int i = 0;  // text index
    int j = 0;  // pattern index

    while(i < n) {
        if(text[i] == pattern[j]) {
            i++;
            j++;
        }

        if(j == m) {                     // Pattern found
            occurrences.push_back(i - j);
            j = lps[j - 1];              // Continue search for next match
        } else if(i < n && text[i] != pattern[j]) { // Mismatch
            if(j != 0)
                j = lps[j - 1];          // Use LPS to avoid re-comparison
            else
                i++;                     // Move text pointer forward
        }
    }

    return occurrences;
}

int main() {
    string text = "ABABABCABAB";
    string pattern = "ABAB";

    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;

    vector<int> result = KMPSearch(text, pattern);

    cout << "Pattern found at indices: ";
    for(int idx : result)
        cout << idx << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Text = "ABABABCABAB", Pattern = "ABAB"
Compute LPS for pattern "ABAB":
lps[0]=0, lps[1]=0, lps[2]=1, lps[3]=2

KMP Search:
i=0,j=0 → 'A'=='A' → i=1,j=1
i=1,j=1 → 'B'=='B' → i=2,j=2
i=2,j=2 → 'A'=='A' → i=3,j=3
i=3,j=3 → 'B'=='B' → i=4,j=4 → j==4 → match at 0, set j=lps[3]=2
i=4,j=2 → 'A'=='A' → i=5,j=3
i=5,j=3 → 'B'=='B' → i=6,j=4 → j==4 → match at 2, set j=lps[3]=2
...
Final matches at indices: 0, 2, 7

```

---

## **Question: 13 Rabin-Karp algorithm Rolling hash**

**Approach:**
Question: Search for all occurrences of a pattern in a text using Rabin-Karp algorithm with rolling hash.

Approach:

1. Choose a base (e.g., 256 for ASCII) and a large prime modulus to avoid overflow.
2. Compute hash of the pattern and initial window of text of length m.
3. Slide the window over the text:
   a. If current window hash == pattern hash → compare characters to confirm match.
   b. Else → roll the hash: remove leading character, add trailing character.
4. Continue until end of text.
   Time Complexity: O(n + m) on average.
   Space Complexity: O(1) extra space for hash values.
   Notes:

- Efficient for multiple pattern searches.
- Can have collisions; character comparison resolves it.

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Rabin-Karp function to find pattern occurrences
vector<int> rabinKarp(const string &text, const string &pattern) {
    vector<int> occurrences;
    int n = text.size();
    int m = pattern.size();
    if(m > n) return occurrences;  // Edge case: pattern longer than text

    const int base = 256;           // Number of characters in input alphabet
    const int prime = 101;          // Prime modulus

    long long patternHash = 0, windowHash = 0, h = 1;

    // Precompute h = pow(base, m-1) % prime
    for(int i = 0; i < m-1; i++)
        h = (h * base) % prime;

    // Compute initial hash for pattern and first window
    for(int i = 0; i < m; i++) {
        patternHash = (base * patternHash + pattern[i]) % prime;
        windowHash = (base * windowHash + text[i]) % prime;
    }

    // Slide the window
    for(int i = 0; i <= n - m; i++) {
        if(patternHash == windowHash) {   // Potential match
            bool match = true;
            for(int j = 0; j < m; j++) {
                if(text[i+j] != pattern[j]) {
                    match = false;
                    break;
                }
            }
            if(match) occurrences.push_back(i);
        }
        // Compute hash for next window
        if(i < n - m) {
            windowHash = (base * (windowHash - text[i]*h) + text[i + m]) % prime;
            if(windowHash < 0) windowHash += prime;  // Ensure positive
        }
    }

    return occurrences;
}

int main() {
    string text = "ABABABCABAB";
    string pattern = "ABAB";

    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;

    vector<int> result = rabinKarp(text, pattern);

    cout << "Pattern found at indices: ";
    for(int idx : result)
        cout << idx << " ";
    cout << endl;

// End of code
```

**Dry Run:**

```cpp
Text = "ABABABCABAB", Pattern = "ABAB", m=4
Compute initial patternHash and windowHash:
patternHash("ABAB") = 0...calculated
windowHash(text[0..3]) = 0...matches patternHash → confirm characters → match → record 0
Slide window:
i=1 → text[1..4] = "BABA" → hash mismatch → skip
i=2 → text[2..5] = "ABAB" → hash match → confirm → match → record 2
i=3 → text[3..6] = "BABC" → hash mismatch → skip
...
Final occurrences = 0, 2, 7

```

---

## **Question: 14 Z-algorithm for pattern search Z-array**

**Approach:**
Question: Search for all occurrences of a pattern in a text using Z-Algorithm.

Approach:

1. Concatenate pattern + special character (not in text) + text: S = pattern + "$" + text
2. Compute Z-array for string S:
   - Z[i] = length of longest substring starting at i which is also a prefix of S.
3. Traverse Z-array:
   - If Z[i] == length of pattern → pattern occurs at position i - (pattern length + 1) in text.
     Time Complexity: O(n + m) – linear scan of combined string.
     Space Complexity: O(n + m) – Z-array and concatenated string.
     Notes:

- Efficient linear time pattern search.
- Handles multiple occurrences and overlapping patterns.

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Function to compute Z-array for string
vector<int> computeZ(const string &s) {
    int n = s.length();
    vector<int> Z(n, 0);
    int l = 0, r = 0;

    for(int i = 1; i < n; i++) {
        if(i <= r)
            Z[i] = min(r - i + 1, Z[i - l]);
        while(i + Z[i] < n && s[Z[i]] == s[i + Z[i]])
            Z[i]++;
        if(i + Z[i] - 1 > r) {
            l = i;
            r = i + Z[i] - 1;
        }
    }

    return Z;
}

// Z-algorithm search function
vector<int> ZAlgorithmSearch(const string &text, const string &pattern) {
    string concat = pattern + "$" + text;   // Concatenate pattern and text
    vector<int> Z = computeZ(concat);
    vector<int> occurrences;
    int pLen = pattern.length();

    for(int i = pLen + 1; i < Z.size(); i++) {
        if(Z[i] == pLen) {                  // Pattern matched
            occurrences.push_back(i - pLen - 1);  // Adjust index
        }
    }

    return occurrences;
}

int main() {
    string text = "ABABABCABAB";
    string pattern = "ABAB";

    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;

    vector<int> result = ZAlgorithmSearch(text, pattern);

    cout << "Pattern found at indices: ";
    for(int idx : result)
        cout << idx << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Text = "ABABABCABAB", Pattern = "ABAB"
Concat = "ABAB$ABABABCABAB"
Compute Z-array:
Z[5] = 4 → match → index 0
Z[7] = 4 → match → index 2
Z[12] = 4 → match → index 7
Final occurrences = 0, 2, 7

```

---

## **Question: 15 Count occurrences of a substring Pattern search**

**Approach:**
Question: Count how many times a given substring appears in a text.

Approach:

1. Use a naive method or efficient pattern search (KMP, Rabin-Karp, Z-algorithm).
2. Naive approach:
   a. Traverse text from index 0 to n-m (text length - pattern length).
   b. Compare substring of text with the pattern.
   c. If match → increment count.
3. Return total count.
   Time Complexity: O(n\*m) for naive method; O(n + m) for KMP/Z-algorithm.
   Space Complexity: O(1) for naive; O(m) for KMP or O(n + m) for Z-array.
   Notes:

- Efficient algorithms preferred in competitive programming.
- Handles overlapping occurrences depending on method.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to count occurrences of pattern in text (naive)
int countSubstringOccurrences(const string &text, const string &pattern) {
    int n = text.length();
    int m = pattern.length();
    int count = 0;

    for(int i = 0; i <= n - m; i++) {     // Traverse all possible start positions
        bool match = true;
        for(int j = 0; j < m; j++) {      // Compare substring with pattern
            if(text[i + j] != pattern[j]) {
                match = false;
                break;
            }
        }
        if(match) count++;                 // Increment if pattern matches
    }

    return count;
}

int main() {
    string text = "ABABABCABAB";
    string pattern = "ABAB";

    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;

    int occurrences = countSubstringOccurrences(text, pattern);

    cout << "Number of occurrences: " << occurrences << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Text = "ABABABCABAB", Pattern = "ABAB", m=4
i=0 → text[0..3]="ABAB" → match → count=1
i=1 → text[1..4]="BABA" → mismatch
i=2 → text[2..5]="ABAB" → match → count=2
i=3 → text[3..6]="BABC" → mismatch
i=7 → text[7..10]="ABAB" → match → count=3
Final count = 3

```

---

## **Question: 16 Check if string starts with a prefix Comparison**

**Approach:**
Question: Check whether a given string starts with a specific prefix.

Approach:

1. Let s = input string, prefix = prefix to check.
2. Compare first prefix.length() characters of s with prefix.
3. If all characters match → string starts with prefix → return true.
4. Else → return false.
   Time Complexity: O(m) – compare up to length of prefix.
   Space Complexity: O(1) – no extra space used.
   Notes:

- Works even if prefix is longer than string (return false).
- Can be implemented using substr() or manual comparison.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to check if string starts with a given prefix
bool startsWith(const string &s, const string &prefix) {
    int n = s.length();
    int m = prefix.length();

    if(m > n) return false;             // Prefix longer than string → false

    for(int i = 0; i < m; i++) {       // Compare character by character
        if(s[i] != prefix[i])
            return false;               // Mismatch found
    }

    return true;                        // All characters matched
}

int main() {
    string s = "HelloWorld";
    string prefix = "Hello";

    cout << "String: " << s << endl;
    cout << "Prefix: " << prefix << endl;

    if(startsWith(s, prefix))
        cout << "The string starts with the prefix." << endl;
    else
        cout << "The string does NOT start with the prefix." << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "HelloWorld", Prefix = "Hello"
Compare character by character:
s[0]='H' == prefix[0]='H' → OK
s[1]='e' == prefix[1]='e' → OK
s[2]='l' == prefix[2]='l' → OK
s[3]='l' == prefix[3]='l' → OK
s[4]='o' == prefix[4]='o' → OK
All characters matched → return true

```

---

## **Question: 17 Check if string ends with a suffix Comparison**

**Approach:**
Question: Check whether a given string ends with a specific suffix.

Approach:

1. Let s = input string, suffix = suffix to check.
2. Compare last suffix.length() characters of s with suffix.
3. If all characters match → string ends with suffix → return true.
4. Else → return false.
   Time Complexity: O(m) – compare up to length of suffix.
   Space Complexity: O(1) – no extra space used.
   Notes:

- Works even if suffix is longer than string (return false).
- Can be implemented using substr() or manual comparison.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to check if string ends with a given suffix
bool endsWith(const string &s, const string &suffix) {
    int n = s.length();
    int m = suffix.length();

    if(m > n) return false;                  // Suffix longer than string → false

    for(int i = 0; i < m; i++) {            // Compare from end
        if(s[n - m + i] != suffix[i])
            return false;                   // Mismatch found
    }

    return true;                             // All characters matched
}

int main() {
    string s = "HelloWorld";
    string suffix = "World";

    cout << "String: " << s << endl;
    cout << "Suffix: " << suffix << endl;

    if(endsWith(s, suffix))
        cout << "The string ends with the suffix." << endl;
    else
        cout << "The string does NOT end with the suffix." << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "HelloWorld", Suffix = "World"
Compare character by character from end:
s[5]='W' == suffix[0]='W' → OK
s[6]='o' == suffix[1]='o' → OK
s[7]='r' == suffix[2]='r' → OK
s[8]='l' == suffix[3]='l' → OK
s[9]='d' == suffix[4]='d' → OK
All characters matched → return true

```

---

## **Question: 18 Longest substring without repeating characters (simple ASCII assumption, no hashing) Two-pointer**

**Approach:**
Question: Find the length of the longest substring without repeating characters, assuming only ASCII characters and no hashing.

Approach:

1. Use two pointers (sliding window) – start and end.
2. Maintain an array of size 128 (ASCII) to track last seen index of characters.
3. Move the end pointer forward:
   a. If current character was seen inside current window → move start pointer after previous occurrence.
   b. Update last seen index of current character.
4. Track maximum window length.
   Time Complexity: O(n) – each character visited at most twice.
   Space Complexity: O(128) → O(1) constant extra space.
   Notes:

- Simple, efficient for ASCII strings.
- Works for competitive programming with no hashing.

**Code:**

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

// Function to find length of longest substring without repeating characters
int longestUniqueSubstring(const string &s) {
    int n = s.length();
    int lastIndex[128];                  // ASCII assumption
    fill(begin(lastIndex), end(lastIndex), -1); // Initialize to -1 (not seen)

    int maxLen = 0;
    int start = 0;                       // Start index of current window

    for(int end = 0; end < n; end++) {
        char c = s[end];

        if(lastIndex[c] >= start) {      // Character repeated in current window
            start = lastIndex[c] + 1;    // Move start after previous occurrence
        }

        lastIndex[c] = end;              // Update last seen index
        maxLen = max(maxLen, end - start + 1); // Update max length
    }

    return maxLen;
}

int main() {
    string s = "abcabcbb";

    cout << "String: " << s << endl;

    int length = longestUniqueSubstring(s);

    cout << "Length of longest substring without repeating characters: " << length << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "abcabcbb"
lastIndex[] initialized to -1
start=0, maxLen=0

end=0 → 'a', lastIndex['a']=-1 < start → update lastIndex['a']=0, maxLen=1
end=1 → 'b', lastIndex['b']=-1 → update lastIndex['b']=1, maxLen=2
end=2 → 'c', lastIndex['c']=-1 → update lastIndex['c']=2, maxLen=3
end=3 → 'a', lastIndex['a']=0 ≥ start → start=1, lastIndex['a']=3, maxLen=3
end=4 → 'b', lastIndex['b']=1 ≥ start → start=2, lastIndex['b']=4, maxLen=3
...
Final maxLen = 3 ("abc")

```

---

## **Question: 19 Longest substring with exactly 2 unique characters (fixed character set) Two-pointer**

**Approach:**
Question: Find the length of the longest substring containing exactly 2 unique characters, assuming a fixed character set (e.g., lowercase English letters).

Approach:

1. Use two-pointer (sliding window) approach.
2. Maintain a frequency array of size equal to character set (e.g., 26 for lowercase letters).
3. Expand the window by moving right pointer:
   a. Update frequency of character.
   b. Track number of unique characters in the window.
4. If unique characters > 2 → shrink window from left until unique count <= 2.
5. Update maximum length during window expansion.
   Time Complexity: O(n) – each character visited at most twice.
   Space Complexity: O(26) → O(1) constant extra space.
   Notes:

- Works for fixed alphabet size.
- Efficient for competitive programming.

**Code:**

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

// Function to find longest substring with exactly 2 unique characters
int longestSubstringWith2Unique(const string &s) {
    int n = s.length();
    int freq[26] = {0};               // Frequency array for lowercase letters
    int uniqueCount = 0;              // Number of unique characters in current window
    int start = 0, maxLen = 0;

    for(int end = 0; end < n; end++) {
        char c = s[end];
        if(freq[c - 'a'] == 0) uniqueCount++;  // New character in window
        freq[c - 'a']++;

        while(uniqueCount > 2) {        // Shrink window until uniqueCount <= 2
            char leftChar = s[start];
            freq[leftChar - 'a']--;
            if(freq[leftChar - 'a'] == 0) uniqueCount--; // One unique character removed
            start++;
        }

        maxLen = max(maxLen, end - start + 1);  // Update max length
    }

    return maxLen;
}

int main() {
    string s = "eceba";

    cout << "String: " << s << endl;

    int length = longestSubstringWith2Unique(s);

    cout << "Length of longest substring with exactly 2 unique characters: " << length << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "eceba"
Window [0,0] → 'e', uniqueCount=1 → maxLen=1
Window [0,1] → 'ec', uniqueCount=2 → maxLen=2
Window [0,2] → 'ece', uniqueCount=2 → maxLen=3
Window [0,3] → 'eceb', uniqueCount=3 → shrink window from start → start=1, uniqueCount=2 → maxLen=3
Window [2,4] → 'eba', uniqueCount=3 → shrink → start=3, uniqueCount=2 → maxLen remains 3
Final maxLen = 3 ("ece")

```

---

## **Question: 20 Smallest window containing all characters of another string (small string) Two-pointer + nested loops**

**Approach:**
Question: Find the smallest substring/window in text that contains all characters of a pattern (small pattern).

Approach (Naive / small pattern):

1. Let text = T, pattern = P of length m (small).
2. Traverse all possible substrings of T using two nested loops:
   a. Outer loop: start index i from 0 to n-1
   b. Inner loop: end index j from i to n-1
   c. For substring T[i..j], check if all characters of P are present (using frequency array)
3. Keep track of the minimum length substring satisfying the condition.
   Time Complexity: O(n^2 \* m) → acceptable only for small strings.
   Space Complexity: O(128) → frequency array for ASCII.
   Notes:

- For larger patterns/texts, sliding window + hashmap is efficient.
- Handles repeated characters in pattern properly.

**Code:**

```cpp
#include <iostream>
#include <string>
#include <climits>
#include <algorithm>
using namespace std;

// Function to check if substring contains all characters of pattern
bool containsAll(const string &window, const string &pattern) {
    int freq[128] = {0};                  // Frequency of pattern characters
    for(char c : pattern) freq[c]++;

    for(char c : window) {
        if(freq[c] > 0) freq[c]--;       // Reduce count for seen character
    }

    for(int i = 0; i < 128; i++)
        if(freq[i] > 0) return false;    // Some character missing

    return true;                          // All characters present
}

// Function to find smallest window containing all characters of pattern
string smallestWindowNaive(const string &text, const string &pattern) {
    int n = text.length();
    int minLen = INT_MAX;
    string result = "";

    for(int i = 0; i < n; i++) {
        for(int j = i; j < n; j++) {
            string window = text.substr(i, j - i + 1);
            if(containsAll(window, pattern)) {
                if(window.length() < minLen) {
                    minLen = window.length();
                    result = window;
                }
                break;                    // Smallest for this start found
            }
        }
    }

    return result;
}

int main() {
    string text = "ADOBECODEBANC";
    string pattern = "ABC";

    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;

    string window = smallestWindowNaive(text, pattern);

    if(window.empty())
        cout << "No window contains all characters." << endl;
    else
        cout << "Smallest window containing all characters: " << window << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Text = "ADOBECODEBANC", Pattern = "ABC"
Check all substrings starting at i=0:
"AD" → missing 'B', 'C'
"ADO" → missing 'B', 'C'
"ADOB" → missing 'C'
"ADOBEC" → contains 'A','B','C' → minLen=6, result="ADOBEC"
...
Final smallest window = "BANC"

```

---

## **Question: 21 Convert string to integer (atoi) Traversal + digit handling**

**Approach:**
Question: Convert a string representing a number into an integer (like atoi).

Approach:

1. Traverse the string character by character.
2. Handle optional leading '+' or '-' sign.
3. For each digit character, update result: result = result \* 10 + (digit).
4. Stop traversal on encountering non-digit character.
5. Handle integer overflow by checking limits (INT_MAX, INT_MIN).
   Time Complexity: O(n) – traverse string once.
   Space Complexity: O(1) – constant extra space.
   Notes:

- Works for both positive and negative numbers.
- Ignores trailing non-digit characters.
- Leading/trailing spaces can be handled if needed (optional).

**Code:**

```cpp
#include <iostream>
#include <string>
#include <climits>
using namespace std;

// Function to convert string to integer (atoi)
int stringToInteger(const string &s) {
    int n = s.length();
    int i = 0;
    while(i < n && s[i] == ' ') i++;      // Skip leading spaces

    int sign = 1;
    if(i < n && (s[i] == '+' || s[i] == '-')) {  // Handle sign
        if(s[i] == '-') sign = -1;
        i++;
    }

    long long result = 0;                 // Use long long to handle overflow
    while(i < n && isdigit(s[i])) {       // Traverse digits
        int digit = s[i] - '0';
        result = result * 10 + digit;
        if(sign * result > INT_MAX) return INT_MAX; // Overflow check
        if(sign * result < INT_MIN) return INT_MIN;
        i++;
    }

    return sign * result;
}

int main() {
    string s = "   -12345abc";

    cout << "String: \"" << s << "\"" << endl;

    int num = stringToInteger(s);

    cout << "Converted integer: " << num << endl;

    return 0;
}
// End of code
// End of code
```

**Dry Run:**

```cpp
String = "   -12345abc"
Skip leading spaces → i=3
s[3]='-' → sign=-1, i=4
s[4]='1' → result=1
s[5]='2' → result=12
s[6]='3' → result=123
s[7]='4' → result=1234
s[8]='5' → result=12345
s[9]='a' → non-digit → stop
Return -12345
```

---

## **Question: 22 Convert integer to string (itoa) Traversal + modulo**

**Approach:**
Question: Convert an integer to its string representation (like itoa).

Approach:

1. Handle 0 as a special case.
2. Handle negative numbers: store sign, work with absolute value.
3. Extract digits using modulo 10, convert to character, append to string.
4. Reverse the string at the end because digits are obtained in reverse order.
   Time Complexity: O(log10(n)) – number of digits.
   Space Complexity: O(log10(n)) – string to store digits.
   Notes:

- Works for positive and negative integers.
- Can be implemented without using built-in to_string().

**Code:**

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <climits>
using namespace std;

// Function to convert integer to string
string integerToString(int num) {
    if(num == 0) return "0";            // Special case for 0

    bool negative = false;
    long long n = num;                   // Use long long to handle INT_MIN
    if(n < 0) {
        negative = true;
        n = -n;                          // Work with positive value
    }

    string result = "";

    while(n > 0) {
        char digit = (n % 10) + '0';    // Convert digit to char
        result += digit;                // Append to result
        n /= 10;
    }

    if(negative) result += '-';          // Add negative sign if needed

    reverse(result.begin(), result.end()); // Reverse string to correct order

    return result;
}

int main() {
    int num = -12345;

    cout << "Integer: " << num << endl;

    string s = integerToString(num);

    cout << "Converted string: \"" << s << "\"" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Integer = -12345
negative = true, n = 12345
Extract digits:
12345 % 10 = 5 → result="5"
1234 % 10 = 4 → result="54"
123 % 10 = 3 → result="543"
12 % 10 = 2 → result="5432"
1 % 10 = 1 → result="54321"
Add negative sign → result="54321-"
Reverse → result="-12345"

```

---

## **Question: 23 Implement strstr / substring search Traversal**

**Approach:**
Question: Implement strstr function to find the first occurrence of a pattern/substring in a text.

Approach (Naive method):

1. Let text = T, pattern = P.
2. Traverse text from index 0 to n - m (where n=text length, m=pattern length).
3. For each index i, check if T[i..i+m-1] matches pattern P.
4. If match found → return index i.
5. If no match → return -1.
   Time Complexity: O(n\*m) for naive method.
   Space Complexity: O(1) – no extra space.
   Notes:

- Efficient for small patterns or competitive programming basics.
- For large strings, use KMP or Z-algorithm for O(n+m) solution.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to find first occurrence of pattern in text
int strstrNaive(const string &text, const string &pattern) {
    int n = text.length();
    int m = pattern.length();

    if(m == 0) return 0;               // Empty pattern → return 0

    for(int i = 0; i <= n - m; i++) { // Traverse all possible start positions
        bool match = true;
        for(int j = 0; j < m; j++) {
            if(text[i + j] != pattern[j]) {
                match = false;
                break;
            }
        }
        if(match) return i;            // First occurrence found
    }

    return -1;                         // Pattern not found
}

int main() {
    string text = "hello world";
    string pattern = "world";

    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;

    int index = strstrNaive(text, pattern);

    if(index != -1)
        cout << "Pattern found at index: " << index << endl;
    else
        cout << "Pattern not found" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Text = "hello world", Pattern = "world"
i=0 → "hello" → mismatch
i=1 → "ello " → mismatch
i=2 → "llo w" → mismatch
i=3 → "lo wo" → mismatch
i=4 → "o wor" → mismatch
i=5 → " worl" → mismatch
i=6 → "world" → match → return 6
```

---

## **Question: 24 String compression (like aaabb → a3b2) Traversal + count**

**Approach:**
Question: Compress a string by replacing consecutive repeating characters with character followed by count (run-length encoding).
Example: "aaabb" → "a3b2"

Approach:

1. Traverse the string using a single loop.
2. Keep track of current character and its consecutive count.
3. When next character differs or end of string is reached:
   a. Append current character to result.
   b. If count > 1, append count as string.
   c. Reset count to 1 for new character.
4. Continue until the end of string.
   Time Complexity: O(n) – single traversal of string.
   Space Complexity: O(n) – for resulting compressed string.
   Notes:

- Works for ASCII strings.
- For competitive programming, in-place modification can be done if allowed.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to compress string using run-length encoding
string compressString(const string &s) {
    int n = s.length();
    if(n == 0) return "";               // Empty string edge case

    string result = "";
    int count = 1;

    for(int i = 1; i <= n; i++) {       // Traverse including one past last char
        if(i < n && s[i] == s[i - 1]) {
            count++;                     // Same character → increment count
        } else {
            result += s[i - 1];          // Append current character
            if(count > 1)
                result += to_string(count); // Append count if >1
            count = 1;                   // Reset count for new character
        }
    }

    return result;
}

int main() {
    string s = "aaabbcccaa";

    cout << "Original string: " << s << endl;

    string compressed = compressString(s);

    cout << "Compressed string: " << compressed << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "aaabbcccaa"
i=1 → 'a'=='a' → count=2
i=2 → 'a'=='a' → count=3
i=3 → 'b'!='a' → append 'a3' → count=1
i=4 → 'b'=='b' → count=2
i=5 → 'c'!='b' → append 'b2' → count=1
i=6 → 'c'=='c' → count=2
i=7 → 'c'=='c' → count=3
i=8 → 'a'!='c' → append 'c3' → count=1
i=9 → 'a'=='a' → count=2
i=10 → end → append 'a2'
Final compressed string = "a3b2c3a2"

```

---

## **Question: 25 Remove adjacent duplicates Traversal + pointer**

**Approach:**
Question: Remove consecutive duplicate characters from a string.
Example: "aaabbcddd" → "abcd"

Approach:

1. Traverse the string using a pointer or index.
2. Keep track of previous character.
3. For each character:
   a. If it is same as previous → skip it.
   b. Else → append to result and update previous character.
4. Continue until the end of string.
   Time Complexity: O(n) – single traversal.
   Space Complexity: O(n) – for result string.
   Notes:

- Works for ASCII strings.
- Can be done in-place if modification of original string is allowed.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to remove adjacent duplicates
string removeAdjacentDuplicates(const string &s) {
    int n = s.length();
    if(n == 0) return "";             // Empty string edge case

    string result = "";
    char prev = '\0';                  // Initialize previous character to null

    for(int i = 0; i < n; i++) {
        if(s[i] != prev) {            // If current char is different from previous
            result += s[i];           // Append to result
            prev = s[i];              // Update previous character
        }
    }

    return result;
}

int main() {
    string s = "aaabbcddd";

    cout << "Original string: " << s << endl;

    string modified = removeAdjacentDuplicates(s);

    cout << "String after removing adjacent duplicates: " << modified << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "aaabbcddd"
i=0 → 'a' != prev('\0') → append 'a', prev='a'
i=1 → 'a' == prev → skip
i=2 → 'a' == prev → skip
i=3 → 'b' != prev → append 'b', prev='b'
i=4 → 'b' == prev → skip
i=5 → 'c' != prev → append 'c', prev='c'
i=6 → 'd' != prev → append 'd', prev='d'
i=7 → 'd' == prev → skip
i=8 → 'd' == prev → skip
Final string = "abcd"

```

---

## **Question: 26 Check if string is palindrome ignoring spaces and punctuation Two-pointer + filtering**

**Approach:**
Question: Check whether a string is a palindrome ignoring spaces, punctuation, and case.
Example: "A man, a plan, a canal: Panama" → true

Approach:

1. Use two pointers: left = 0, right = n-1.
2. While left < right:
   a. Skip non-alphanumeric characters on both ends.
   b. Compare lowercase versions of characters at left and right.
   c. If mismatch → return false.
   d. Else → move pointers inward.
3. If pointers cross → string is palindrome → return true.
   Time Complexity: O(n) – single traversal.
   Space Complexity: O(1) – in-place using pointers.
   Notes:

- Uses ASCII assumption for alphanumeric check.
- Ignores cases and non-alphanumeric characters.

**Code:**

```cpp
#include <iostream>
#include <string>
#include <cctype> // for isalnum() and tolower()
using namespace std;

// Function to check if string is palindrome ignoring spaces/punctuation
bool isPalindromeFiltered(const string &s) {
    int left = 0, right = s.length() - 1;

    while(left < right) {
        // Skip non-alphanumeric characters from left
        while(left < right && !isalnum(s[left])) left++;
        // Skip non-alphanumeric characters from right
        while(left < right && !isalnum(s[right])) right--;

        if(tolower(s[left]) != tolower(s[right])) return false; // Mismatch
        left++;
        right--;
    }

    return true; // All matched
}

int main() {
    string s = "A man, a plan, a canal: Panama";

    cout << "String: \"" << s << "\"" << endl;

    if(isPalindromeFiltered(s))
        cout << "The string is a palindrome (ignoring spaces/punctuation)." << endl;
    else
        cout << "The string is NOT a palindrome." << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "A man, a plan, a canal: Panama"
left=0('A'), right=29('a') → tolower('A')==tolower('a') → OK
left=1(' '), skip
left=2('m'), right=28('m') → OK
...
Continue comparing letters, skipping spaces/punctuation
All letters match → return true

```

---

## **Question: Decode a Run Length Encoded string Traversal + expansion**

**Approach:**
Question: Given a run-length encoded string (e.g., "a3b2c1"), decode it into the original string (e.g., "aaabbc").

Approach:

1. Traverse the encoded string character by character.
2. For each character:
   a. The next characters are digits representing count.
   b. Convert digits to integer (handle multi-digit counts).
   c. Append the character 'count' times to the result.
3. Continue until the end of the string.
   Time Complexity: O(n + total decoded length)
   Space Complexity: O(total decoded length) – for result string
   Notes:

- Works for ASCII characters and multi-digit counts.
- Efficient for competitive programming for moderate-length strings.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to decode run-length encoded string
string decodeRLE(const string &encoded) {
    int n = encoded.length();
    string result = "";
    int i = 0;

    while(i < n) {
        char c = encoded[i];        // Current character
        i++;

        // Extract number (may be multiple digits)
        int count = 0;
        while(i < n && isdigit(encoded[i])) {
            count = count * 10 + (encoded[i] - '0');
            i++;
        }

        // Append character 'count' times
        result.append(count, c);
    }

    return result;
}

int main() {
    string encoded = "a3b2c1";

    cout << "Encoded string: " << encoded << endl;

    string decoded = decodeRLE(encoded);

    cout << "Decoded string: " << decoded << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Encoded = "a3b2c1"
i=0 → c='a', next char='3' → count=3 → append 'aaa' → i=2
i=2 → c='b', next char='2' → count=2 → append 'bb' → i=4
i=4 → c='c', next char='1' → count=1 → append 'c' → i=6
Decoded string = "aaabbc"

```

---

## **Question: 28 Sort characters in string Sorting**

**Approach:**
Question: Given a string, sort all its characters in ascending order.
Example: "dcba" → "abcd"

Approach:

1. Use built-in sort function or implement a sorting algorithm.
2. Sort the string in-place or create a new sorted string.
3. For competitive programming, std::sort is efficient (O(n log n)).
   Time Complexity: O(n log n) – sorting characters.
   Space Complexity: O(1) if in-place, O(n) if creating new string.
   Notes:

- Works for ASCII or lowercase/uppercase letters.
- Can be extended for custom order (e.g., lowercase first, then uppercase).

**Code:**

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

// Function to sort characters of a string
string sortString(const string &s) {
    string result = s;                  // Copy original string
    sort(result.begin(), result.end()); // Sort characters in ascending order
    return result;
}

int main() {
    string s = "dcba";

    cout << "Original string: " << s << endl;

    string sortedStr = sortString(s);

    cout << "Sorted string: " << sortedStr << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "dcba"
Sort characters → 'a','b','c','d'
Result = "abcd"

```

---

## **Question: 29 Lexicographical rank of a string (small string) Factorials + comparison**

**Approach:**
Question: Find the lexicographical rank of a string among all its permutations.
Example: "bac" → Rank = 3 (permutations in order: "abc","acb","bac",...)

Approach:

1. Assume string length is small (n ≤ 10) → factorials manageable.
2. For each character in the string:
   a. Count number of characters smaller than current character to its right.
   b. Multiply count by factorial of remaining positions.
3. Sum all contributions + 1 → gives lexicographical rank.
   Time Complexity: O(n^2) – for each character, compare with remaining characters.
   Space Complexity: O(1) – using simple variables.
   Notes:

- Works for small strings in competitive programming.
- For large strings, factorials may overflow, use modulo arithmetic.

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Function to compute factorial
int factorial(int n) {
    int fact = 1;
    for(int i = 2; i <= n; i++) fact *= i;
    return fact;
}

// Function to find lexicographical rank of a string (small string)
int lexRank(const string &s) {
    int n = s.length();
    int rank = 1; // 1-based indexing

    for(int i = 0; i < n; i++) {
        int countSmaller = 0;
        for(int j = i + 1; j < n; j++) {
            if(s[j] < s[i]) countSmaller++; // Count chars smaller than s[i] to its right
        }

        rank += countSmaller * factorial(n - i - 1); // Contribution of current position
    }

    return rank;
}

int main() {
    string s = "bac";

    cout << "String: " << s << endl;

    int rank = lexRank(s);

    cout << "Lexicographical rank: " << rank << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "bac"
i=0 → s[0]='b', chars after: 'a','c'
'a' < 'b' → countSmaller=1
Contribution = 1 * factorial(2) = 2
Rank = 1 + 2 = 3
i=1 → s[1]='a', chars after: 'c' → no smaller → contribution=0
i=2 → s[2]='c', no chars after → contribution=0
Final rank = 3

```

---

## **Question: 30 Compare version numbers in string format Split + compare numbers**

**Approach:**
Question: Given two version strings, compare them.
Example: "1.01" vs "1.001" → versions are equal
"1.0.1" vs "1" → version1 > version2

Approach:

1. Split both version strings by '.' into components.
2. Convert each component to integer (ignore leading zeros).
3. Compare corresponding components:
   a. If a component in version1 > version2 → return 1
   b. If < → return -1
   c. If equal → continue
4. If all components equal → return 0
   Time Complexity: O(n + m) – traverse both strings.
   Space Complexity: O(1) – can be done with two pointers, no extra arrays needed.
   Notes:

- Works for competitive programming.
- Handles different number of components by treating missing parts as 0.

**Code:**

```cpp
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

// Function to compare version numbers
int compareVersion(const string &version1, const string &version2) {
    int n1 = version1.length(), n2 = version2.length();
    int i = 0, j = 0;

    while(i < n1 || j < n2) {
        int num1 = 0;
        while(i < n1 && version1[i] != '.') {
            num1 = num1 * 10 + (version1[i] - '0');
            i++;
        }
        int num2 = 0;
        while(j < n2 && version2[j] != '.') {
            num2 = num2 * 10 + (version2[j] - '0');
            j++;
        }

        if(num1 > num2) return 1;
        if(num1 < num2) return -1;

        i++; // Skip dot
        j++;
    }

    return 0; // Versions are equal
}

int main() {
    string v1 = "1.0.1";
    string v2 = "1";

    cout << "Version1: " << v1 << endl;
    cout << "Version2: " << v2 << endl;

    int cmp = compareVersion(v1, v2);

    if(cmp == 0) cout << "Versions are equal." << endl;
    else if(cmp == 1) cout << "Version1 is greater." << endl;
    else cout << "Version2 is greater." << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Version1 = "1.0.1", Version2 = "1"
i=0,j=0 → num1=1, num2=1 → equal → i++, j++
i=2,j=1 → num1=0, num2=0 (missing part treated as 0) → equal
i=4,j=1 → num1=1, num2=0 → num1>num2 → return 1
Result: Version1 is greater

```

---

## **Question: 31 Check if string is pangram (English alphabet) Traversal + simple array of 26**

**Approach:**
Question: Determine whether a string contains every letter of the English alphabet at least once.
Example: "The quick brown fox jumps over the lazy dog" → true

Approach:

1. Create a boolean array of size 26 to track occurrence of each letter.
2. Traverse the string:
   a. Convert character to lowercase.
   b. If alphabet, mark corresponding index as true.
3. After traversal, check if all 26 entries are true.
   Time Complexity: O(n) – traverse string once.
   Space Complexity: O(26) = O(1) – fixed array for English letters.
   Notes:

- Ignores case and non-alphabet characters.
- Suitable for competitive programming.

**Code:**

```cpp
#include <iostream>
#include <string>
#include <cctype> // for tolower()
using namespace std;

// Function to check if string is pangram
bool isPangram(const string &s) {
    bool seen[26] = {false};           // Track each alphabet character

    for(char c : s) {
        if(isalpha(c)) {               // Consider only letters
            seen[tolower(c) - 'a'] = true;
        }
    }

    // Check if all letters are seen
    for(int i = 0; i < 26; i++) {
        if(!seen[i]) return false;
    }

    return true;
}

int main() {
    string s = "The quick brown fox jumps over the lazy dog";

    cout << "String: \"" << s << "\"" << endl;

    if(isPangram(s))
        cout << "The string is a pangram." << endl;
    else
        cout << "The string is NOT a pangram." << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
String = "The quick brown fox jumps over the lazy dog"
Traverse characters:
'T' → lowercase 't' → mark seen[19]=true
'h' → seen[7]=true
...
After full traversal, all 26 entries in seen[] are true → return true

```

---
