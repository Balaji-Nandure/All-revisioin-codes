# 1️⃣ Basics / Traversal (7 questions)

## **Question: Print all elements of an array.**

**Approach:**
We simply iterate over the array from start to end and print each element.

For raw arrays, we use a simple for loop with the array size.

For vectors, we can use either index-based looping or range-based for loop.
Time complexity is O(n) where n = number of elements.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
void printArrayRaw(int arr[], int n) {
    // Time Complexity: O(n)
    cout << "Printing array elements (raw array): ";
    for(int i = 0; i < n; i++) {
        // Print current element
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Approach 2: Using vector with index-based loop
void printArrayVectorIndex(const vector<int>& vec) {
    // Time Complexity: O(n)
    cout << "Printing vector elements (index-based): ";
    for(int i = 0; i < vec.size(); i++) {
        cout << vec[i] << " ";
    }
    cout << endl;
}

// Approach 3: Using vector with range-based loop
void printArrayVectorRange(const vector<int>& vec) {
    // Time Complexity: O(n)
    cout << "Printing vector elements (range-based loop): ";
    for(int val : vec) {
        cout << val << " ";
    }
    cout << endl;
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    printArrayRaw(arr, n);

    // Vector
    vector<int> vec = {10, 20, 30, 40, 50};
    printArrayVectorIndex(vec);
    printArrayVectorRange(vec);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Dry run example here
```

---

## **Question: Update the i-th element of an array.**

**Approach:**
We directly access the i-th element of the array or vector using its index and assign it a new value.

For raw arrays, use arr[i] = newValue.

For vectors, use vec[i] = newValue.
Time complexity is O(1) for updating a single element.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Update raw array
void updateArrayRaw(int arr[], int n, int index, int newValue) {
    // Time Complexity: O(1)
    if(index >= 0 && index < n) {
        arr[index] = newValue; // Update the element at index
    } else {
        cout << "Invalid index!" << endl;
    }
}

// Approach 2: Update vector
void updateArrayVector(vector<int>& vec, int index, int newValue) {
    // Time Complexity: O(1)
    if(index >= 0 && index < vec.size()) {
        vec[index] = newValue; // Update element
    } else {
        cout << "Invalid index!" << endl;
    }
}

// Approach 3: Update vector using at() method (with bounds checking)
void updateArrayVectorAt(vector<int>& vec, int index, int newValue) {
    // Time Complexity: O(1)
    try {
        vec.at(index) = newValue; // Throws exception if index invalid
    } catch(out_of_range &e) {
        cout << "Invalid index!" << endl;
    }
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    updateArrayRaw(arr, n, 2, 10); // Change 3rd element (index 2) to 10
    for(int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << endl;

    // Vector
    vector<int> vec = {10, 20, 30, 40, 50};
    updateArrayVector(vec, 1, 99); // Change 2nd element to 99
    for(int val : vec) cout << val << " ";
    cout << endl;

    updateArrayVectorAt(vec, 4, 77); // Change 5th element to 77
    for(int val : vec) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array
arr = [1,2,3,4,5], update index 2 to 10
arr[2] = 10
Output: 1 2 10 4 5

// Vector
vec = [10,20,30,40,50]
update index 1 to 99 -> vec = [10,99,30,40,50]
update index 4 to 77 -> vec = [10,99,30,40,77]
Output: 10 99 30 40 77

```

---

## **Question: Find the sum of all elements in an array.**

**Approach:**
We traverse the array/vector and keep adding each element to a sum variable.

For raw arrays, use a simple for loop.

For vectors, we can use index-based loop or range-based loop.
Time complexity: O(n), where n = number of elements.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
int sumArrayRaw(int arr[], int n) {
    // Time Complexity: O(n)
    int sum = 0; // Initialize sum
    for(int i = 0; i < n; i++) {
        sum += arr[i]; // Add current element to sum
    }
    return sum;
}

// Approach 2: Using vector (index-based loop)
int sumArrayVectorIndex(const vector<int>& vec) {
    // Time Complexity: O(n)
    int sum = 0;
    for(int i = 0; i < vec.size(); i++) {
        sum += vec[i]; // Add each element
    }
    return sum;
}

// Approach 3: Using vector (range-based loop)
int sumArrayVectorRange(const vector<int>& vec) {
    // Time Complexity: O(n)
    int sum = 0;
    for(int val : vec) {
        sum += val; // Add each element
    }
    return sum;
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Sum of raw array: " << sumArrayRaw(arr, n) << endl;

    // Vector
    vector<int> vec = {10, 20, 30, 40, 50};
    cout << "Sum of vector (index-based): " << sumArrayVectorIndex(vec) << endl;
    cout << "Sum of vector (range-based): " << sumArrayVectorRange(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array
arr = [1,2,3,4,5], sum=0
i=0 -> sum = 0+1 = 1
i=1 -> sum = 1+2 = 3
i=2 -> sum = 3+3 = 6
i=3 -> sum = 6+4 = 10
i=4 -> sum = 10+5 = 15
Output: 15

// Vector
vec = [10,20,30,40,50], sum=0
val=10 -> sum=10
val=20 -> sum=30
val=30 -> sum=60
val=40 -> sum=100
val=50 -> sum=150
Output: 150

```

---

## **Question: Find the average of array elements.**

**Approach:**
The average is calculated as the sum of all elements divided by the number of elements.

First, traverse the array/vector to calculate the sum.

Then divide the sum by the size of the array/vector.
Time complexity: O(n), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
double averageArrayRaw(int arr[], int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int sum = 0;
    for(int i = 0; i < n; i++) {
        sum += arr[i]; // Add each element to sum
    }
    return (double)sum / n; // Divide sum by number of elements
}

// Approach 2: Using vector (index-based loop)
double averageArrayVectorIndex(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int sum = 0;
    for(int i = 0; i < vec.size(); i++) {
        sum += vec[i];
    }
    return (double)sum / vec.size();
}

// Approach 3: Using vector (range-based loop)
double averageArrayVectorRange(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int sum = 0;
    for(int val : vec) {
        sum += val;
    }
    return (double)sum / vec.size();
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Average of raw array: " << averageArrayRaw(arr, n) << endl;

    // Vector
    vector<int> vec = {10, 20, 30, 40, 50};
    cout << "Average of vector (index-based): " << averageArrayVectorIndex(vec) << endl;
    cout << "Average of vector (range-based): " << averageArrayVectorRange(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array
arr = [1,2,3,4,5], sum=0
i=0 -> sum=1
i=1 -> sum=3
i=2 -> sum=6
i=3 -> sum=10
i=4 -> sum=15
Average = 15 / 5 = 3
Output: 3

// Vector
vec = [10,20,30,40,50], sum=0
sum = 10+20+30+40+50 = 150
Average = 150 / 5 = 30
Output: 30

```

---

## **Question: Find the minimum element in an array.**

**Approach:**
We iterate through the array/vector and keep track of the smallest element encountered so far.

Initialize minVal with the first element.

Compare each element with minVal and update if smaller.
Time complexity: O(n), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <climits> // For INT_MAX
using namespace std;

// Approach 1: Using raw array
int findMinArrayRaw(int arr[], int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int minVal = INT_MAX; // Initialize with maximum possible value
    for(int i = 0; i < n; i++) {
        if(arr[i] < minVal) {
            minVal = arr[i]; // Update minVal if current element is smaller
        }
    }
    return minVal;
}

// Approach 2: Using vector (index-based loop)
int findMinArrayVectorIndex(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int minVal = INT_MAX;
    for(int i = 0; i < vec.size(); i++) {
        if(vec[i] < minVal) minVal = vec[i];
    }
    return minVal;
}

// Approach 3: Using vector (range-based loop)
int findMinArrayVectorRange(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int minVal = INT_MAX;
    for(int val : vec) {
        if(val < minVal) minVal = val;
    }
    return minVal;
}

int main() {
    // Raw array
    int arr[] = {5, 3, 8, 1, 4};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Minimum in raw array: " << findMinArrayRaw(arr, n) << endl;

    // Vector
    vector<int> vec = {10, 20, 5, 30, 15};
    cout << "Minimum in vector (index-based): " << findMinArrayVectorIndex(vec) << endl;
    cout << "Minimum in vector (range-based): " << findMinArrayVectorRange(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array
arr = [5,3,8,1,4], minVal=INT_MAX
i=0 -> arr[0]=5 < minVal=INF -> minVal=5
i=1 -> arr[1]=3 < minVal=5 -> minVal=3
i=2 -> arr[2]=8 > minVal=3 -> minVal=3
i=3 -> arr[3]=1 < minVal=3 -> minVal=1
i=4 -> arr[4]=4 > minVal=1 -> minVal=1
Output: 1

// Vector
vec = [10,20,5,30,15], minVal=INF
val=10 -> minVal=10
val=20 -> minVal=10
val=5 -> minVal=5
val=30 -> minVal=5
val=15 -> minVal=5
Output: 5

```

---

## **Question: Count the frequency of a given element in an array.**

**Approach:**
We traverse the array/vector and count how many times the target element occurs.

Initialize a count variable to 0.

Increment count whenever the current element matches the target.
Time complexity: O(n), Space complexity: O(1) for this approach.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
int frequencyArrayRaw(int arr[], int n, int target) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int count = 0; // Initialize counter
    for(int i = 0; i < n; i++) {
        if(arr[i] == target) {
            count++; // Increment when element matches target
        }
    }
    return count;
}

// Approach 2: Using vector (index-based loop)
int frequencyArrayVectorIndex(const vector<int>& vec, int target) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int count = 0;
    for(int i = 0; i < vec.size(); i++) {
        if(vec[i] == target) count++;
    }
    return count;
}

// Approach 3: Using vector (range-based loop)
int frequencyArrayVectorRange(const vector<int>& vec, int target) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int count = 0;
    for(int val : vec) {
        if(val == target) count++;
    }
    return count;
}

int main() {
    // Raw array
    int arr[] = {1, 2, 2, 3, 2, 4};
    int n = sizeof(arr)/sizeof(arr[0]);
    int target = 2;
    cout << "Frequency of " << target << " in raw array: " << frequencyArrayRaw(arr, n, target) << endl;

    // Vector
    vector<int> vec = {5, 3, 5, 5, 2, 5};
    target = 5;
    cout << "Frequency of " << target << " in vector (index-based): " << frequencyArrayVectorIndex(vec, target) << endl;
    cout << "Frequency of " << target << " in vector (range-based): " << frequencyArrayVectorRange(vec, target) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array
arr = [1,2,2,3,2,4], target=2, count=0
i=0 -> arr[0]=1 !=2 -> count=0
i=1 -> arr[1]=2 ==2 -> count=1
i=2 -> arr[2]=2 ==2 -> count=2
i=3 -> arr[3]=3 !=2 -> count=2
i=4 -> arr[4]=2 ==2 -> count=3
i=5 -> arr[5]=4 !=2 -> count=3
Output: 3

// Vector
vec = [5,3,5,5,2,5], target=5, count=0
val=5 -> count=1
val=3 -> count=1
val=5 -> count=2
val=5 -> count=3
val=2 -> count=3
val=5 -> count=4
Output: 4

```

---

# 2️⃣ Prefix / Suffix Concepts (8 questions)

## **Question: Compute prefix sum array.**

**Approach:**
Prefix sum array stores the sum of all elements from the start up to the current index.

For each index i, prefix[i] = arr[0] + arr[1] + ... + arr[i].

We can compute it iteratively by adding the current element to the previous prefix sum.
Time complexity: O(n), Space complexity: O(n).

Code:

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
void prefixSumArrayRaw(int arr[], int n, int prefix[]) {
    // Time Complexity: O(n)
    // Space Complexity: O(n) for prefix array
    if(n <= 0) return;
    prefix[0] = arr[0]; // First element remains same
    for(int i = 1; i < n; i++) {
        prefix[i] = prefix[i-1] + arr[i]; // Current prefix = previous prefix + current element
    }
}

// Approach 2: Using vector
vector<int> prefixSumArrayVector(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    vector<int> prefix(vec.size());
    if(vec.size() == 0) return prefix;
    prefix[0] = vec[0];
    for(int i = 1; i < vec.size(); i++) {
        prefix[i] = prefix[i-1] + vec[i];
    }
    return prefix;
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    int prefix[n]; // Array to store prefix sums
    prefixSumArrayRaw(arr, n, prefix);
    cout << "Prefix sum of raw array: ";
    for(int i = 0; i < n; i++) cout << prefix[i] << " ";
    cout << endl;

    // Vector
    vector<int> vec = {10, 20, 30, 40};
    vector<int> prefixVec = prefixSumArrayVector(vec);
    cout << "Prefix sum of vector: ";
    for(int val : prefixVec) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array
arr = [1,2,3,4,5], prefix=[]
prefix[0] = arr[0] = 1 -> prefix=[1]
i=1 -> prefix[1] = prefix[0]+arr[1] = 1+2=3 -> prefix=[1,3]
i=2 -> prefix[2] = 3+3=6 -> prefix=[1,3,6]
i=3 -> prefix[3] = 6+4=10 -> prefix=[1,3,6,10]
i=4 -> prefix[4] = 10+5=15 -> prefix=[1,3,6,10,15]
Output: 1 3 6 10 15

// Vector
vec = [10,20,30,40], prefix=[]
prefix[0] = 10 -> prefix=[10]
i=1 -> 10+20=30 -> prefix=[10,30]
i=2 -> 30+30=60 -> prefix=[10,30,60]
i=3 -> 60+40=100 -> prefix=[10,30,60,100]
Output: 10 30 60 100

```

---

## **Question: Compute suffix sum array.**

**Approach:**
Suffix sum array stores the sum of elements from the current index to the end of the array.

For each index i, suffix[i] = arr[i] + arr[i+1] + ... + arr[n-1].

Compute it iteratively from the end of the array towards the start.
Time complexity: O(n), Space complexity: O(n).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
void suffixSumArrayRaw(int arr[], int n, int suffix[]) {
    // Time Complexity: O(n)
    // Space Complexity: O(n) for suffix array
    if(n <= 0) return;
    suffix[n-1] = arr[n-1]; // Last element remains the same
    for(int i = n-2; i >= 0; i--) {
        suffix[i] = arr[i] + suffix[i+1]; // Current suffix = current element + next suffix
    }
}

// Approach 2: Using vector
vector<int> suffixSumArrayVector(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    int n = vec.size();
    vector<int> suffix(n);
    if(n == 0) return suffix;
    suffix[n-1] = vec[n-1];
    for(int i = n-2; i >= 0; i--) {
        suffix[i] = vec[i] + suffix[i+1];
    }
    return suffix;
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    int suffix[n];
    suffixSumArrayRaw(arr, n, suffix);
    cout << "Suffix sum of raw array: ";
    for(int i = 0; i < n; i++) cout << suffix[i] << " ";
    cout << endl;

    // Vector
    vector<int> vec = {10, 20, 30, 40};
    vector<int> suffixVec = suffixSumArrayVector(vec);
    cout << "Suffix sum of vector: ";
    for(int val : suffixVec) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array
arr = [1,2,3,4,5], suffix=[]
suffix[4] = arr[4] = 5 -> suffix=[_,_,_,_,5]
i=3 -> suffix[3] = arr[3]+suffix[4] = 4+5=9 -> suffix=[_,_,_,9,5]
i=2 -> suffix[2] = 3+9=12 -> suffix=[_,_,12,9,5]
i=1 -> suffix[1] = 2+12=14 -> suffix=[_,14,12,9,5]
i=0 -> suffix[0] = 1+14=15 -> suffix=[15,14,12,9,5]
Output: 15 14 12 9 5

// Vector
vec = [10,20,30,40], suffix=[]
suffix[3] = 40 -> suffix=[_,_,_,40]
i=2 -> 30+40=70 -> suffix=[_,_,70,40]
i=1 -> 20+70=90 -> suffix=[_,90,70,40]
i=0 -> 10+90=100 -> suffix=[100,90,70,40]
Output: 100 90 70 40

```

---

## **Question: Find sum of elements between indices L and R using prefix sums.**

**Approach:**
We can use the prefix sum array to efficiently calculate the sum of any subarray in O(1) time:

Compute prefix sum array first.

Sum from index L to R is prefix[R] - prefix[L-1] (if L > 0), else just prefix[R].
Time complexity: O(n) to compute prefix sums, O(1) for each query.

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to compute prefix sum array for raw array
void prefixSumRaw(int arr[], int n, int prefix[]) {
    prefix[0] = arr[0];
    for(int i = 1; i < n; i++) {
        prefix[i] = prefix[i-1] + arr[i];
    }
}

// Function to compute prefix sum array for vector
vector<int> prefixSumVector(const vector<int>& vec) {
    vector<int> prefix(vec.size());
    if(vec.size() == 0) return prefix;
    prefix[0] = vec[0];
    for(int i = 1; i < vec.size(); i++) {
        prefix[i] = prefix[i-1] + vec[i];
    }
    return prefix;
}

// Approach 1: Query sum using raw array
int sumRangeRaw(int prefix[], int L, int R) {
    // Time Complexity: O(1) per query
    if(L == 0) return prefix[R];
    else return prefix[R] - prefix[L-1];
}

// Approach 2: Query sum using vector
int sumRangeVector(const vector<int>& prefix, int L, int R) {
    // Time Complexity: O(1) per query
    if(L == 0) return prefix[R];
    else return prefix[R] - prefix[L-1];
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    int prefix[n];
    prefixSumRaw(arr, n, prefix);
    int L = 1, R = 3; // Sum from index 1 to 3 (2nd to 4th element)
    cout << "Sum from L to R (raw array): " << sumRangeRaw(prefix, L, R) << endl;

    // Vector
    vector<int> vec = {10, 20, 30, 40, 50};
    vector<int> prefixVec = prefixSumVector(vec);
    L = 2, R = 4; // Sum from 3rd to 5th element
    cout << "Sum from L to R (vector): " << sumRangeVector(prefixVec, L, R) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array
arr=[1,2,3,4,5]
prefix = [1,3,6,10,15]
Query: L=1, R=3
sum = prefix[3]-prefix[0] = 10-1=9
Output: 9  (2+3+4=9)

// Vector
vec=[10,20,30,40,50]
prefix=[10,30,60,100,150]
Query: L=2, R=4
sum = prefix[4]-prefix[1]=150-30=120
Output: 120  (30+40+50=120)

```

---

## **Question: Sliding window: find maximum sum of subarray of size k.**

**Approach:**
Use sliding window technique for O(n) solution:

Compute the sum of the first k elements.

Slide the window by one element at a time: subtract the element leaving the window and add the new element entering the window.

Keep track of the maximum sum encountered.

Time complexity: O(n), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
int maxSumSubarrayRaw(int arr[], int n, int k) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    if(k > n) return -1; // Invalid window size

    int windowSum = 0;
    // Compute sum of first window of size k
    for(int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    int maxSum = windowSum;

    // Slide the window
    for(int i = k; i < n; i++) {
        windowSum += arr[i] - arr[i - k]; // Add new element, remove old element
        if(windowSum > maxSum) maxSum = windowSum;
    }
    return maxSum;
}

// Approach 2: Using vector
int maxSumSubarrayVector(const vector<int>& vec, int k) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    if(k > n) return -1;

    int windowSum = 0;
    for(int i = 0; i < k; i++) {
        windowSum += vec[i];
    }
    int maxSum = windowSum;

    for(int i = k; i < n; i++) {
        windowSum += vec[i] - vec[i - k];
        if(windowSum > maxSum) maxSum = windowSum;
    }
    return maxSum;
}

int main() {
    // Raw array
    int arr[] = {1, 4, 2, 10, 23, 3, 1, 0, 20};
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 4;
    cout << "Maximum sum of subarray of size " << k << " (raw array): " << maxSumSubarrayRaw(arr, n, k) << endl;

    // Vector
    vector<int> vec = {1, 4, 2, 10, 23, 3, 1, 0, 20};
    cout << "Maximum sum of subarray of size " << k << " (vector): " << maxSumSubarrayVector(vec, k) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array: arr=[1,4,2,10,23,3,1,0,20], k=4
Initial window sum (first 4 elements): 1+4+2+10=17, maxSum=17
i=4 -> windowSum=17+23-1=39, maxSum=39
i=5 -> windowSum=39+3-4=38, maxSum=39
i=6 -> windowSum=38+1-2=37, maxSum=39
i=7 -> windowSum=37+0-10=27, maxSum=39
i=8 -> windowSum=27+20-23=24, maxSum=39
Output: 39

```

---

## **Question: Sliding window: count number of distinct elements in subarrays of size k.**

**Approach:**
Use sliding window + hashmap:

Maintain a frequency map for elements in the current window.

For each window, the size of the map = number of distinct elements.

Slide the window:

Add new element (increment frequency).

Remove old element (decrement frequency; remove from map if frequency becomes 0).

Time complexity: O(n), Space complexity: O(k).

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Approach 1: Using raw array
void countDistinctSubarraysRaw(int arr[], int n, int k) {
    // Time Complexity: O(n)
    // Space Complexity: O(k)
    if(k > n) return;

    unordered_map<int,int> freq;
    // Initialize first window
    for(int i = 0; i < k; i++) freq[arr[i]]++;

    cout << "Distinct count in subarray 0-" << k-1 << ": " << freq.size() << endl;

    // Slide the window
    for(int i = k; i < n; i++) {
        // Remove outgoing element
        freq[arr[i-k]]--;
        if(freq[arr[i-k]] == 0) freq.erase(arr[i-k]);
        // Add incoming element
        freq[arr[i]]++;
        cout << "Distinct count in subarray " << i-k+1 << "-" << i << ": " << freq.size() << endl;
    }
}

// Approach 2: Using vector
void countDistinctSubarraysVector(const vector<int>& vec, int k) {
    // Time Complexity: O(n)
    // Space Complexity: O(k)
    int n = vec.size();
    if(k > n) return;

    unordered_map<int,int> freq;
    for(int i = 0; i < k; i++) freq[vec[i]]++;
    cout << "Distinct count in subarray 0-" << k-1 << ": " << freq.size() << endl;

    for(int i = k; i < n; i++) {
        freq[vec[i-k]]--;
        if(freq[vec[i-k]] == 0) freq.erase(vec[i-k]);
        freq[vec[i]]++;
        cout << "Distinct count in subarray " << i-k+1 << "-" << i << ": " << freq.size() << endl;
    }
}

int main() {
    // Raw array
    int arr[] = {1, 2, 1, 3, 4, 2, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 4;
    cout << "Raw array:" << endl;
    countDistinctSubarraysRaw(arr, n, k);

    // Vector
    vector<int> vec = {1, 2, 1, 3, 4, 2, 3};
    cout << "Vector:" << endl;
    countDistinctSubarraysVector(vec, k);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
arr=[1,2,1,3,4,2,3], k=4
Initial window [1,2,1,3] -> distinct={1,2,3} -> 3
Slide by 1: remove 1, add 4 -> window [2,1,3,4] -> distinct={1,2,3,4} -> 4
Slide by 1: remove 2, add 2 -> window [1,3,4,2] -> distinct={1,2,3,4} -> 4
Slide by 1: remove 1, add 3 -> window [3,4,2,3] -> distinct={2,3,4} -> 3

```

---

## **Question: Print all subarrays of an array.**

**Approach:**
A subarray is a contiguous part of an array.

Use two nested loops:

Outer loop selects the starting index.

Inner loop selects the ending index and prints elements from start to end.

Time complexity: O(n²), Space complexity: O(1) for printing (not storing).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
void printAllSubarraysRaw(int arr[], int n) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1)
    for(int start = 0; start < n; start++) {
        for(int end = start; end < n; end++) {
            // Print subarray from start to end
            cout << "[";
            for(int i = start; i <= end; i++) {
                cout << arr[i];
                if(i < end) cout << ", ";
            }
            cout << "]" << endl;
        }
    }
}

// Approach 2: Using vector
void printAllSubarraysVector(const vector<int>& vec) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1)
    int n = vec.size();
    for(int start = 0; start < n; start++) {
        for(int end = start; end < n; end++) {
            cout << "[";
            for(int i = start; i <= end; i++) {
                cout << vec[i];
                if(i < end) cout << ", ";
            }
            cout << "]" << endl;
        }
    }
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Subarrays of raw array:" << endl;
    printAllSubarraysRaw(arr, n);

    // Vector
    vector<int> vec = {4, 5, 6};
    cout << "Subarrays of vector:" << endl;
    printAllSubarraysVector(vec);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array: arr=[1,2,3]
start=0
  end=0 -> [1]
  end=1 -> [1,2]
  end=2 -> [1,2,3]
start=1
  end=1 -> [2]
  end=2 -> [2,3]
start=2
  end=2 -> [3]
Output:
[1]
[1,2]
[1,2,3]
[2]
[2,3]
[3]

// Vector: vec=[4,5,6]
Output:
[4]
[4,5]
[4,5,6]
[5]
[5,6]
[6]

```

---

## **Question: Find sum of all subarrays (brute-force).**

**Approach:**
Use three nested loops:

Outer loop selects starting index.

Middle loop selects ending index.

Inner loop sums elements from start to end.

Time complexity: O(n³), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array (brute-force)
void sumAllSubarraysRaw(int arr[], int n) {
    // Time Complexity: O(n^3)
    // Space Complexity: O(1)
    for(int start = 0; start < n; start++) {
        for(int end = start; end < n; end++) {
            int sum = 0;
            for(int i = start; i <= end; i++) {
                sum += arr[i]; // Add each element in current subarray
            }
            cout << "Sum of subarray [" << start << "-" << end << "] = " << sum << endl;
        }
    }
}

// Approach 2: Using vector (brute-force)
void sumAllSubarraysVector(const vector<int>& vec) {
    // Time Complexity: O(n^3)
    // Space Complexity: O(1)
    int n = vec.size();
    for(int start = 0; start < n; start++) {
        for(int end = start; end < n; end++) {
            int sum = 0;
            for(int i = start; i <= end; i++) {
                sum += vec[i];
            }
            cout << "Sum of subarray [" << start << "-" << end << "] = " << sum << endl;
        }
    }
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Sum of all subarrays (raw array):" << endl;
    sumAllSubarraysRaw(arr, n);

    // Vector
    vector<int> vec = {4, 5, 6};
    cout << "Sum of all subarrays (vector):" << endl;
    sumAllSubarraysVector(vec);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Raw array: arr=[1,2,3]
start=0
  end=0 -> sum=1
  end=1 -> sum=1+2=3
  end=2 -> sum=1+2+3=6
start=1
  end=1 -> sum=2
  end=2 -> sum=2+3=5
start=2
  end=2 -> sum=3
Output:
Sum of subarray [0-0] = 1
Sum of subarray [0-1] = 3
Sum of subarray [0-2] = 6
Sum of subarray [1-1] = 2
Sum of subarray [1-2] = 5
Sum of subarray [2-2] = 3

```

---

## **Question: Maximum subarray sum (Kadane’s algorithm).**

**Approach:**
Kadane’s algorithm efficiently finds the maximum sum of a contiguous subarray.

Idea:

Traverse the array, maintaining currentSum = max sum ending at current index.

If currentSum becomes negative, reset it to 0 (ignore subarrays that reduce sum).

Keep track of maxSum as the maximum currentSum seen so far.

Time complexity: O(n), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

// Approach 1: Using raw array
int kadaneRaw(int arr[], int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int maxSum = INT_MIN; // Maximum sum found so far
    int currentSum = 0;   // Current sum ending at current index
    for(int i = 0; i < n; i++) {
        currentSum += arr[i];
        if(currentSum > maxSum) maxSum = currentSum;
        if(currentSum < 0) currentSum = 0; // Reset if sum becomes negative
    }
    return maxSum;
}

// Approach 2: Using vector
int kadaneVector(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int maxSum = INT_MIN, currentSum = 0;
    for(int val : vec) {
        currentSum += val;
        if(currentSum > maxSum) maxSum = currentSum;
        if(currentSum < 0) currentSum = 0;
    }
    return maxSum;
}

int main() {
    // Raw array
    int arr[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Maximum subarray sum (raw array): " << kadaneRaw(arr, n) << endl;

    // Vector
    vector<int> vec = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    cout << "Maximum subarray sum (vector): " << kadaneVector(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[-2,1,-3,4,-1,2,1,-5,4]
currentSum=0, maxSum=-INF
i=0 -> currentSum=-2 -> maxSum=-2 -> currentSum reset to 0
i=1 -> currentSum=1 -> maxSum=1
i=2 -> currentSum=1+(-3)=-2 -> maxSum=1 -> currentSum reset to 0
i=3 -> currentSum=4 -> maxSum=4
i=4 -> currentSum=4+(-1)=3 -> maxSum=4
i=5 -> currentSum=3+2=5 -> maxSum=5
i=6 -> currentSum=5+1=6 -> maxSum=6
i=7 -> currentSum=6+(-5)=1 -> maxSum=6
i=8 -> currentSum=1+4=5 -> maxSum=6
Output: 6
// Maximum sum subarray: [4,-1,2,1]

```

---

## **Question: Maximum product subarray.**

**Approach:**
Similar to Kadane’s algorithm but we must track both maximum and minimum product ending at current index because a negative number can turn a small negative product into a large positive product.

Steps:

Initialize maxProd and minProd with first element, result = first element.

Traverse array from index 1:

If current element is negative, swap maxProd and minProd.

Update maxProd = max(current element, maxProd \* current element).

Update minProd = min(current element, minProd \* current element).

Update result = max(result, maxProd).

Time complexity: O(n), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

// Approach 1: Using raw array
int maxProductSubarrayRaw(int arr[], int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int maxProd = arr[0];
    int minProd = arr[0];
    int result = arr[0];

    for(int i = 1; i < n; i++) {
        if(arr[i] < 0) swap(maxProd, minProd); // Negative flips max/min

        maxProd = max(arr[i], maxProd * arr[i]);
        minProd = min(arr[i], minProd * arr[i]);

        result = max(result, maxProd);
    }
    return result;
}

// Approach 2: Using vector
int maxProductSubarrayVector(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int maxProd = vec[0], minProd = vec[0], result = vec[0];

    for(int i = 1; i < vec.size(); i++) {
        if(vec[i] < 0) swap(maxProd, minProd);
        maxProd = max(vec[i], maxProd * vec[i]);
        minProd = min(vec[i], minProd * vec[i]);
        result = max(result, maxProd);
    }
    return result;
}

int main() {
    // Raw array
    int arr[] = {2, 3, -2, 4};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Maximum product subarray (raw array): " << maxProductSubarrayRaw(arr, n) << endl;

    // Vector
    vector<int> vec = {-2, 0, -1, 4, -3};
    cout << "Maximum product subarray (vector): " << maxProductSubarrayVector(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[2,3,-2,4]
maxProd=2, minProd=2, result=2
i=1 -> arr[1]=3 -> maxProd=max(3,2*3)=6, minProd=min(3,2*3)=3, result=6
i=2 -> arr[2]=-2 <0, swap maxProd/minProd -> maxProd=3, minProd=6
         maxProd=max(-2,3*-2)=-2, minProd=min(-2,6*-2)=-12
         result=max(6,-2)=6
i=3 -> arr[3]=4 -> maxProd=max(4,-2*4)=4, minProd=min(4,-12*4)=-48
         result=max(6,4)=6
Output: 6
// Maximum product subarray: [2,3]

```

---

## **Question: Count subarrays with sum divisible by k.**

**Approach:**
Use prefix sum + hashmap of remainders for an efficient solution:

Compute running prefix sum while traversing the array.

Compute remainder = (prefixSum % k + k) % k to handle negative numbers.

Maintain a hashmap that counts frequency of each remainder.

If the same remainder has appeared before, it means a subarray sum between those indices is divisible by k.

Time complexity: O(n), Space complexity: O(k).

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Approach 1: Using raw array
int countSubarraysDivisibleByKRaw(int arr[], int n, int k) {
    // Time Complexity: O(n)
    // Space Complexity: O(k)
    unordered_map<int,int> remainderFreq;
    remainderFreq[0] = 1; // Base case: prefix sum 0
    int count = 0, prefixSum = 0;

    for(int i = 0; i < n; i++) {
        prefixSum += arr[i];
        int rem = ((prefixSum % k) + k) % k; // Handle negative numbers
        if(remainderFreq.find(rem) != remainderFreq.end()) {
            count += remainderFreq[rem]; // Add number of previous same remainders
        }
        remainderFreq[rem]++;
    }
    return count;
}

// Approach 2: Using vector
int countSubarraysDivisibleByKVector(const vector<int>& vec, int k) {
    // Time Complexity: O(n)
    // Space Complexity: O(k)
    unordered_map<int,int> remainderFreq;
    remainderFreq[0] = 1;
    int count = 0, prefixSum = 0;

    for(int val : vec) {
        prefixSum += val;
        int rem = ((prefixSum % k) + k) % k;
        if(remainderFreq.find(rem) != remainderFreq.end()) {
            count += remainderFreq[rem];
        }
        remainderFreq[rem]++;
    }
    return count;
}

int main() {
    // Raw array
    int arr[] = {4, 5, 0, -2, -3, 1};
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 5;
    cout << "Count of subarrays divisible by " << k << " (raw array): " << countSubarraysDivisibleByKRaw(arr, n, k) << endl;

    // Vector
    vector<int> vec = {4, 5, 0, -2, -3, 1};
    cout << "Count of subarrays divisible by " << k << " (vector): " << countSubarraysDivisibleByKVector(vec, k) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[4,5,0,-2,-3,1], k=5
prefixSum=0, remainderFreq={0:1}, count=0
i=0 -> prefixSum=4 -> rem=4 -> remainderFreq={0:1,4:1}, count=0
i=1 -> prefixSum=9 -> rem=4 -> remainderFreq[4]=1 -> count+=1 -> count=1, remainderFreq[4]=2
i=2 -> prefixSum=9 -> rem=4 -> remainderFreq[4]=2 -> count+=2 -> count=3, remainderFreq[4]=3
i=3 -> prefixSum=7 -> rem=2 -> remainderFreq={0:1,4:3,2:1}, count=3
i=4 -> prefixSum=4 -> rem=4 -> remainderFreq[4]=3 -> count+=3 -> count=6, remainderFreq[4]=4
i=5 -> prefixSum=5 -> rem=0 -> remainderFreq[0]=1 -> count+=1 -> count=7, remainderFreq[0]=2
Output: 7

```

---

## **Question: Find the length of longest subarray with sum = 0.**

**Approach:**
Use prefix sum + hashmap:

Maintain a running prefix sum while traversing the array.

If prefix sum is 0, update max length (i + 1).

If the prefix sum has been seen before at index j, the subarray (j+1 to i) has sum = 0. Update max length.

If prefix sum is new, store it in the map with its index.

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Approach 1: Using raw array
int longestZeroSumSubarrayRaw(int arr[], int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    unordered_map<int,int> prefixIndex;
    int maxLen = 0, prefixSum = 0;

    for(int i = 0; i < n; i++) {
        prefixSum += arr[i];

        if(prefixSum == 0) maxLen = i + 1; // Subarray from 0 to i
        else if(prefixIndex.find(prefixSum) != prefixIndex.end()) {
            // Subarray from prefixIndex[prefixSum]+1 to i has sum=0
            maxLen = max(maxLen, i - prefixIndex[prefixSum]);
        } else {
            // Store first occurrence of this prefixSum
            prefixIndex[prefixSum] = i;
        }
    }
    return maxLen;
}

// Approach 2: Using vector
int longestZeroSumSubarrayVector(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    unordered_map<int,int> prefixIndex;
    int maxLen = 0, prefixSum = 0;

    for(int i = 0; i < vec.size(); i++) {
        prefixSum += vec[i];

        if(prefixSum == 0) maxLen = i + 1;
        else if(prefixIndex.find(prefixSum) != prefixIndex.end()) {
            maxLen = max(maxLen, i - prefixIndex[prefixSum]);
        } else {
            prefixIndex[prefixSum] = i;
        }
    }
    return maxLen;
}

int main() {
    // Raw array
    int arr[] = {1, 2, -3, 3, -1, -2, 4};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Length of longest zero-sum subarray (raw array): " << longestZeroSumSubarrayRaw(arr, n) << endl;

    // Vector
    vector<int> vec = {1, 2, -2, 4, -4};
    cout << "Length of longest zero-sum subarray (vector): " << longestZeroSumSubarrayVector(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[1,2,-3,3,-1,-2,4]
prefixSum=0, maxLen=0, prefixIndex={}
i=0 -> prefixSum=1 -> store 1:0
i=1 -> prefixSum=3 -> store 3:1
i=2 -> prefixSum=0 -> maxLen=i+1=3
i=3 -> prefixSum=3 -> seen at index 1 -> maxLen=max(3,3-1)=3
i=4 -> prefixSum=2 -> store 2:4
i=5 -> prefixSum=0 -> maxLen=max(3,5+1)=6
i=6 -> prefixSum=4 -> store 4:6
Output: 6
// Longest zero-sum subarray: [2,-3,3,-1,-2,4]

```

---

## **Question: Count subarrays with exactly K distinct elements.**

**Approach:**
Key idea:

countExactlyK = countAtMostK(K) - countAtMostK(K-1)

Use sliding window + hashmap to count subarrays with at most K distinct elements.

Steps for countAtMostK:

Maintain a hashmap for frequencies of elements in the current window.

Expand the right end of the window, update map.

If distinct elements > K, shrink window from left until distinct ≤ K.

Add (right - left + 1) to count for subarrays ending at right.

Time complexity: O(n), Space complexity: O(n).

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Helper: Count subarrays with at most K distinct elements
int countAtMostKRaw(int arr[], int n, int K) {
    unordered_map<int,int> freq;
    int left = 0, count = 0;
    for(int right = 0; right < n; right++) {
        freq[arr[right]]++;
        while(freq.size() > K) {
            freq[arr[left]]--;
            if(freq[arr[left]] == 0) freq.erase(arr[left]);
            left++;
        }
        count += (right - left + 1);
    }
    return count;
}

// Raw array: exactly K distinct
int countExactlyKRaw(int arr[], int n, int K) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    return countAtMostKRaw(arr, n, K) - countAtMostKRaw(arr, n, K-1);
}

// Vector version: at most K
int countAtMostKVector(const vector<int>& vec, int K) {
    unordered_map<int,int> freq;
    int left = 0, count = 0;
    for(int right = 0; right < vec.size(); right++) {
        freq[vec[right]]++;
        while(freq.size() > K) {
            freq[vec[left]]--;
            if(freq[vec[left]] == 0) freq.erase(vec[left]);
            left++;
        }
        count += (right - left + 1);
    }
    return count;
}

// Vector: exactly K distinct
int countExactlyKVector(const vector<int>& vec, int K) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    return countAtMostKVector(vec, K) - countAtMostKVector(vec, K-1);
}

int main() {
    // Raw array
    int arr[] = {1, 2, 1, 2, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    int K = 2;
    cout << "Subarrays with exactly " << K << " distinct elements (raw array): " << countExactlyKRaw(arr, n, K) << endl;

    // Vector
    vector<int> vec = {1, 2, 1, 2, 3};
    cout << "Subarrays with exactly " << K << " distinct elements (vector): " << countExactlyKVector(vec, K) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[1,2,1,2,3], K=2
countAtMostK(2):
right=0 -> window=[1], size=1 <=2 -> count=1
right=1 -> window=[1,2], size=2 -> count+=2 -> count=3
right=2 -> window=[1,2,1], size=2 -> count+=3 -> count=6
right=3 -> window=[1,2,1,2], size=2 -> count+=4 -> count=10
right=4 -> window=[2,1,2,3], size=3>2 -> shrink -> window=[1,2,3], size=3>2 -> shrink -> window=[2,3], size=2 -> count+=2 -> count=12

countAtMostK(1):
right=0 -> window=[1], count=1
right=1 -> window=[2], count+=1 -> 2
right=2 -> window=[1], count+=1 -> 3
right=3 -> window=[2], count+=1 -> 4
right=4 -> window=[3], count+=1 -> 5

countExactlyK = 12-5 = 7

```

---

## **Question: Largest sum of contiguous subarray with at most K elements.**

**Approach:**
Use sliding window since the subarray length is limited to at most K:

Maintain a window sum and window size.

Expand the window by including the next element.

If window size exceeds K, remove elements from the left.

Keep track of the maximum sum encountered.

Time complexity: O(n), Space complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
int maxSumAtMostKRaw(int arr[], int n, int K) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int maxSum = INT_MIN, windowSum = 0, left = 0;

    for(int right = 0; right < n; right++) {
        windowSum += arr[right];

        // If window size exceeds K, remove elements from left
        while(right - left + 1 > K) {
            windowSum -= arr[left];
            left++;
        }

        if(windowSum > maxSum) maxSum = windowSum;
    }

    return maxSum;
}

// Approach 2: Using vector
int maxSumAtMostKVector(const vector<int>& vec, int K) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int maxSum = INT_MIN, windowSum = 0, left = 0;

    for(int right = 0; right < vec.size(); right++) {
        windowSum += vec[right];

        while(right - left + 1 > K) {
            windowSum -= vec[left];
            left++;
        }

        if(windowSum > maxSum) maxSum = windowSum;
    }

    return maxSum;
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, -2, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    int K = 3;
    cout << "Largest sum of contiguous subarray with at most " << K << " elements (raw array): "
         << maxSumAtMostKRaw(arr, n, K) << endl;

    // Vector
    vector<int> vec = {1, 2, 3, -2, 5};
    cout << "Largest sum of contiguous subarray with at most " << K << " elements (vector): "
         << maxSumAtMostKVector(vec, K) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[1,2,3,-2,5], K=3
windowSum=0, maxSum=-INF, left=0

right=0 -> windowSum=1, size=1<=3 -> maxSum=1
right=1 -> windowSum=3, size=2<=3 -> maxSum=3
right=2 -> windowSum=6, size=3<=3 -> maxSum=6
right=3 -> windowSum=6+(-2)=4, size=4>3 -> remove arr[0]=1 -> windowSum=3, left=1 -> maxSum=6
right=4 -> windowSum=3+5=8, size=4>3 -> remove arr[1]=2 -> windowSum=6, left=2 -> maxSum=6

Output: 6
// Largest sum contiguous subarray with ≤ 3 elements: [3,-2,5] -> sum=6

```

---

## **Question: Number of subarrays with sum less than X.**

**Approach:**
Use sliding window / two-pointer technique (works for non-negative numbers) for efficiency:

Maintain a running sum of the current window.

Expand the window to the right while sum < X.

If sum ≥ X, shrink window from left until sum < X.

For each right end, the number of valid subarrays ending at right = right - left + 1.

Note: This approach works only for arrays with non-negative numbers.

Time complexity: O(n), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array (non-negative numbers)
int countSubarraysSumLessThanXRaw(int arr[], int n, int X) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int count = 0, sum = 0, left = 0;

    for(int right = 0; right < n; right++) {
        sum += arr[right];

        // Shrink window if sum >= X
        while(sum >= X && left <= right) {
            sum -= arr[left];
            left++;
        }

        // All subarrays ending at right and starting from left to right are valid
        count += (right - left + 1);
    }

    return count;
}

// Approach 2: Using vector
int countSubarraysSumLessThanXVector(const vector<int>& vec, int X) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int count = 0, sum = 0, left = 0;

    for(int right = 0; right < vec.size(); right++) {
        sum += vec[right];

        while(sum >= X && left <= right) {
            sum -= vec[left];
            left++;
        }

        count += (right - left + 1);
    }

    return count;
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, 4};
    int n = sizeof(arr)/sizeof(arr[0]);
    int X = 5;
    cout << "Number of subarrays with sum < " << X << " (raw array): "
         << countSubarraysSumLessThanXRaw(arr, n, X) << endl;

    // Vector
    vector<int> vec = {1, 2, 3, 4};
    cout << "Number of subarrays with sum < " << X << " (vector): "
         << countSubarraysSumLessThanXVector(vec, X) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[1,2,3,4], X=5
sum=0, count=0, left=0

right=0 -> sum=1<5 -> count+=1 -> count=1
right=1 -> sum=3<5 -> count+=2 -> count=3
right=2 -> sum=6>=5 -> shrink left: sum-=1 -> sum=5>=5 -> left=1 -> sum-=2 -> sum=3, left=2
           count+=1 -> count=4
right=3 -> sum=3+4=7>=5 -> shrink left: sum-=3 -> sum=4<5, left=3
           count+=1 -> count=5

Output: 5
// Valid subarrays: [1],[1,2],[2],[3],[4]

```

---

## **Question: Count subarrays with all elements unique.**

**Approach:**
Use sliding window + hash set:

Maintain a window with all unique elements using a set.

Expand the right end while the element is not in the set.

If a duplicate is found, remove elements from the left until duplicate is removed.

For each right end, number of unique subarrays ending at right = (right - left + 1).

Time complexity: O(n), Space complexity: O(n).

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;

// Approach 1: Using raw array
int countUniqueSubarraysRaw(int arr[], int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    unordered_set<int> s;
    int left = 0, count = 0;

    for(int right = 0; right < n; right++) {
        // Remove duplicates from left
        while(s.find(arr[right]) != s.end()) {
            s.erase(arr[left]);
            left++;
        }

        s.insert(arr[right]);
        count += (right - left + 1); // Subarrays ending at right
    }

    return count;
}

// Approach 2: Using vector
int countUniqueSubarraysVector(const vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    unordered_set<int> s;
    int left = 0, count = 0;

    for(int right = 0; right < vec.size(); right++) {
        while(s.find(vec[right]) != s.end()) {
            s.erase(vec[left]);
            left++;
        }
        s.insert(vec[right]);
        count += (right - left + 1);
    }

    return count;
}

int main() {
    // Raw array
    int arr[] = {1, 2, 1, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Number of subarrays with all unique elements (raw array): " << countUniqueSubarraysRaw(arr, n) << endl;

    // Vector
    vector<int> vec = {1, 2, 1, 3};
    cout << "Number of subarrays with all unique elements (vector): " << countUniqueSubarraysVector(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[1,2,1,3]
left=0, count=0, s={}

right=0 -> 1 not in s -> insert -> s={1} -> count+=1 -> count=1
right=1 -> 2 not in s -> insert -> s={1,2} -> count+=2 -> count=3
right=2 -> 1 in s -> remove arr[0]=1 -> left=1 -> insert 1 -> s={1,2} -> count+=2 -> count=5
right=3 -> 3 not in s -> insert -> s={1,2,3} -> count+=3 -> count=8

Output: 8
// Unique subarrays: [1],[2],[1,2],[2,1],[1,3],[1,2,1],[2,1,3],[1,2,1,3] ? Actually total 8 unique subarrays

```

---

# Array Manipulations

## **Question: Reverse an array.**

**Approach:**
Use two-pointer technique:

Initialize two pointers: left = 0 and right = n-1.

Swap arr[left] and arr[right].

Move left forward and right backward until they meet.

Time complexity: O(n), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using raw array
void reverseArrayRaw(int arr[], int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int left = 0, right = n - 1;
    while(left < right) {
        swap(arr[left], arr[right]); // Swap elements at ends
        left++;
        right--;
    }
}

// Approach 2: Using vector
void reverseVector(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int left = 0, right = vec.size() - 1;
    while(left < right) {
        swap(vec[left], vec[right]);
        left++;
        right--;
    }
}

int main() {
    // Raw array
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    reverseArrayRaw(arr, n);
    cout << "Reversed raw array: ";
    for(int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << endl;

    // Vector
    vector<int> vec = {6, 7, 8, 9};
    reverseVector(vec);
    cout << "Reversed vector: ";
    for(int val : vec) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[1,2,3,4,5]
left=0, right=4 -> swap 1 & 5 -> arr=[5,2,3,4,1]
left=1, right=3 -> swap 2 & 4 -> arr=[5,4,3,2,1]
left=2, right=2 -> stop
Output: [5,4,3,2,1]

// vec=[6,7,8,9]
left=0, right=3 -> swap 6 & 9 -> vec=[9,7,8,6]
left=1, right=2 -> swap 7 & 8 -> vec=[9,8,7,6]
left=2, right=1 -> stop
Output: [9,8,7,6]

```

---

## **Question: Rotate array left by d positions.**

**Approach:**
Approach:

Optimal approach (Reversal Algorithm):

Reverse first d elements.

Reverse remaining n-d elements.

Reverse the whole array.

Time complexity: O(n), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Helper function to reverse a segment of array
void reverseRaw(int arr[], int start, int end) {
    while(start < end) {
        swap(arr[start], arr[end]);
        start++;
        end--;
    }
}

// Rotate left by d positions: raw array
void rotateLeftRaw(int arr[], int n, int d) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    d = d % n; // Handle d > n
    reverseRaw(arr, 0, d - 1);       // Reverse first d elements
    reverseRaw(arr, d, n - 1);       // Reverse remaining elements
    reverseRaw(arr, 0, n - 1);       // Reverse whole array
}

// Rotate left by d positions: vector
void rotateLeftVector(vector<int>& vec, int d) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    d = d % n;
    // Reverse first d elements
    int left = 0, right = d - 1;
    while(left < right) {
        swap(vec[left], vec[right]);
        left++; right--;
    }
    // Reverse remaining
    left = d; right = n - 1;
    while(left < right) {
        swap(vec[left], vec[right]);
        left++; right--;
    }
    // Reverse whole vector
    left = 0; right = n - 1;
    while(left < right) {
        swap(vec[left], vec[right]);
        left++; right--;
    }
}

int main() {
    // Raw array
    int arr[] = {1,2,3,4,5};
    int n = sizeof(arr)/sizeof(arr[0]);
    int d = 2;
    rotateLeftRaw(arr, n, d);
    cout << "Array after left rotation by " << d << ": ";
    for(int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << endl;

    // Vector
    vector<int> vec = {6,7,8,9,10};
    rotateLeftVector(vec, 3);
    cout << "Vector after left rotation by 3: ";
    for(int val : vec) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[1,2,3,4,5], d=2
Step 1: Reverse first 2 -> [2,1,3,4,5]
Step 2: Reverse remaining -> [2,1,5,4,3]
Step 3: Reverse whole array -> [3,4,5,1,2]
Output: [3,4,5,1,2]

// vec=[6,7,8,9,10], d=3
Step 1: Reverse first 3 -> [8,7,6,9,10]
Step 2: Reverse remaining -> [8,7,6,10,9]
Step 3: Reverse whole -> [9,10,6,7,8]
Output: [9,10,6,7,8]

```

---

## **Question: Rotate array right by d positions.**

**Approach:**
Optimal approach (Reversal Algorithm):

Convert right rotation to left rotation by n-d positions.

Use reversal method:

Reverse first n-d elements.

Reverse last d elements.

Reverse the whole array.

Time complexity: O(n), Space complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Helper function to reverse a segment of array
void reverseRaw(int arr[], int start, int end) {
    while(start < end) {
        swap(arr[start], arr[end]);
        start++;
        end--;
    }
}

// Rotate right by d positions: raw array
void rotateRightRaw(int arr[], int n, int d) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    d = d % n;             // Handle d > n
    int leftPart = n - d;  // Convert right rotation to left rotation
    reverseRaw(arr, 0, leftPart - 1);
    reverseRaw(arr, leftPart, n - 1);
    reverseRaw(arr, 0, n - 1);
}

// Rotate right by d positions: vector
void rotateRightVector(vector<int>& vec, int d) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    d = d % n;
    int leftPart = n - d;
    // Reverse first n-d elements
    int left = 0, right = leftPart - 1;
    while(left < right) { swap(vec[left], vec[right]); left++; right--; }
    // Reverse last d elements
    left = leftPart; right = n - 1;
    while(left < right) { swap(vec[left], vec[right]); left++; right--; }
    // Reverse whole vector
    left = 0; right = n - 1;
    while(left < right) { swap(vec[left], vec[right]); left++; right--; }
}

int main() {
    // Raw array
    int arr[] = {1,2,3,4,5};
    int n = sizeof(arr)/sizeof(arr[0]);
    int d = 2;
    rotateRightRaw(arr, n, d);
    cout << "Array after right rotation by " << d << ": ";
    for(int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << endl;

    // Vector
    vector<int> vec = {6,7,8,9,10};
    rotateRightVector(vec, 3);
    cout << "Vector after right rotation by 3: ";
    for(int val : vec) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// arr=[1,2,3,4,5], d=2
leftPart = n-d = 5-2=3
Step 1: Reverse first 3 -> [3,2,1,4,5]
Step 2: Reverse last 2 -> [3,2,1,5,4]
Step 3: Reverse whole -> [4,5,1,2,3]
Output: [4,5,1,2,3]

// vec=[6,7,8,9,10], d=3
leftPart=5-3=2
Step1: Reverse first 2 -> [7,6,8,9,10]
Step2: Reverse last 3 -> [7,6,10,9,8]
Step3: Reverse whole -> [8,9,10,6,7]
Output: [8,9,10,6,7]

```

---

## **Question: Move all zeros to the end of the array.**

**Approach:**
Approach:

Brute Force (using extra vector):

Traverse the vector, copy all non-zero elements to a new vector.

Fill remaining positions with zeros.

Time Complexity: O(n), Space Complexity: O(n)

Optimal In-place (Two-pointer / Shift non-zero):

Maintain a pointer pos where the next non-zero should go.

Traverse the vector, whenever a non-zero element is found, place it at pos and increment pos.

After traversal, fill the rest with zeros.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force using extra vector
void moveZerosBruteForce(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    int n = vec.size();
    vector<int> temp; // New vector to store non-zero elements

    // Step 1: Copy non-zero elements
    for(int i = 0; i < n; i++) {
        if(vec[i] != 0) temp.push_back(vec[i]);
    }

    // Step 2: Fill remaining positions with zeros
    while(temp.size() < n) temp.push_back(0);

    // Step 3: Copy back to original vector
    vec = temp;
}

// Approach 2: Optimal In-place
void moveZerosOptimal(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int pos = 0; // Position to place next non-zero element

    // Step 1: Move all non-zero elements to the front
    for(int i = 0; i < vec.size(); i++) {
        if(vec[i] != 0) {
            vec[pos] = vec[i]; // Place non-zero at position 'pos'
            pos++;
        }
    }

    // Step 2: Fill remaining positions with zeros
    for(int i = pos; i < vec.size(); i++) {
        vec[i] = 0;
    }
}

int main() {
    vector<int> vec1 = {0, 1, 0, 3, 12};
    vector<int> vec2 = vec1; // Copy for second approach

    moveZerosBruteForce(vec1);
    cout << "After moving zeros (Brute Force): ";
    for(int val : vec1) cout << val << " ";
    cout << endl;

    moveZerosOptimal(vec2);
    cout << "After moving zeros (Optimal In-place): ";
    for(int val : vec2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// vec = [0,1,0,3,12]

// Brute Force:
Step 1: Copy non-zeros -> temp = [1,3,12]
Step 2: Fill remaining with zeros -> temp = [1,3,12,0,0]
Step 3: vec = temp -> [1,3,12,0,0]

// Optimal In-place:
pos=0
i=0 -> vec[0]=0 -> skip
i=1 -> vec[1]=1 -> vec[0]=1, pos=1
i=2 -> vec[2]=0 -> skip
i=3 -> vec[3]=3 -> vec[1]=3, pos=2
i=4 -> vec[4]=12 -> vec[2]=12, pos=3
Fill remaining pos=3 to 4 with 0 -> vec=[1,3,12,0,0]

```

---

## **Question: Move all zeros to the start of the array.**

**Approach:**
Brute Force (using extra vector):

Count the number of zeros in the vector.

Create a new vector: first fill zeros, then append all non-zero elements.

Time Complexity: O(n), Space Complexity: O(n)

Optimal In-place (Two-pointer / Shift non-zero):

Maintain a pointer pos starting from the end.

Traverse the vector from end to start, whenever a non-zero is found, place it at pos and decrement pos.

After traversal, fill positions 0 to pos with zeros.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force using extra vector
void moveZerosToStartBruteForce(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    int n = vec.size();
    int zeroCount = 0;

    // Step 1: Count zeros
    for(int val : vec) if(val == 0) zeroCount++;

    vector<int> temp;
    // Step 2: Fill zeros at start
    for(int i = 0; i < zeroCount; i++) temp.push_back(0);
    // Step 3: Append non-zero elements
    for(int val : vec) if(val != 0) temp.push_back(val);

    // Step 4: Copy back to original vector
    vec = temp;
}

// Approach 2: Optimal In-place
void moveZerosToStartOptimal(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int pos = vec.size() - 1; // Position to place next non-zero element

    // Step 1: Move non-zero elements to the end
    for(int i = vec.size() - 1; i >= 0; i--) {
        if(vec[i] != 0) {
            vec[pos] = vec[i];
            pos--;
        }
    }

    // Step 2: Fill remaining positions at start with zeros
    for(int i = 0; i <= pos; i++) vec[i] = 0;
}

int main() {
    vector<int> vec1 = {1, 0, 2, 0, 3, 0};
    vector<int> vec2 = vec1; // Copy for second approach

    moveZerosToStartBruteForce(vec1);
    cout << "After moving zeros to start (Brute Force): ";
    for(int val : vec1) cout << val << " ";
    cout << endl;

    moveZerosToStartOptimal(vec2);
    cout << "After moving zeros to start (Optimal In-place): ";
    for(int val : vec2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// vec = [1,0,2,0,3,0]

// Brute Force:
zeroCount = 3
Step 1: Fill zeros -> temp = [0,0,0]
Step 2: Append non-zeros -> temp = [0,0,0,1,2,3]
vec = temp -> [0,0,0,1,2,3]

// Optimal In-place:
pos = 5
i=5 -> vec[5]=0 -> skip
i=4 -> vec[4]=3 -> vec[5]=3, pos=4
i=3 -> vec[3]=0 -> skip
i=2 -> vec[2]=2 -> vec[4]=2, pos=3
i=1 -> vec[1]=0 -> skip
i=0 -> vec[0]=1 -> vec[3]=1, pos=2
Fill positions 0 to 2 with zeros -> vec=[0,0,0,1,2,3]

```

---

## **Question: Swap alternate elements in an array.**

**Approach:**
Simple In-place Swap:

Traverse the vector from index 0 to n-2 in steps of 2.

Swap element at index i with element at index i+1.

If vector has odd length, the last element remains in place.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to swap alternate elements in a vector
void swapAlternate(vector<int>& vec) {
    // Time Complexity: O(n) -> because we traverse the vector once
    // Space Complexity: O(1) -> swapping in-place, no extra memory used

    int n = vec.size(); // Store the size of the vector

    // Step 1: Traverse vector with step of 2 (0,2,4,...)
    for(int i = 0; i < n - 1; i += 2) {
        // i < n-1 because last element may not have a pair to swap with
        // If i == n-1, it means we reached the last element in odd-length vector

        // Step 2: Swap current element with next element
        swap(vec[i], vec[i + 1]); // Built-in swap function

        // Heavy comment:
        // swap(vec[i], vec[i+1]) performs:
        // temp = vec[i]; vec[i] = vec[i+1]; vec[i+1] = temp;
        // Ensures elements at positions i and i+1 are interchanged
    }
}

int main() {
    vector<int> vec = {1, 2, 3, 4, 5, 6, 7}; // Test vector

    cout << "Original vector: ";
    for(int val : vec) cout << val << " "; // Print original vector
    cout << endl;

    // Call the function to swap alternate elements
    swapAlternate(vec);

    cout << "Vector after swapping alternate elements: ";
    for(int val : vec) cout << val << " "; // Print modified vector
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input vector: [1,2,3,4,5,6,7]

// Step 1: i=0 -> swap vec[0] and vec[1] -> [2,1,3,4,5,6,7]
// Step 2: i=2 -> swap vec[2] and vec[3] -> [2,1,4,3,5,6,7]
// Step 3: i=4 -> swap vec[4] and vec[5] -> [2,1,4,3,6,5,7]
// Step 4: i=6 -> last element, no pair -> remain 7

// Output: [2,1,4,3,6,5,7]

```

---

## **Question: Rearrange array in max-min form.**

**Approach:**
Rearrange the vector so that the first element is the maximum, second is minimum, third is second maximum, fourth is second minimum, and so on.

Example:

Input: [1, 2, 3, 4, 5, 6, 7]

Output: [7, 1, 6, 2, 5, 3, 4]

Approach:

Brute Force (Extra Vector):

Sort the vector.

Use two pointers: one at start (min), one at end (max).

Fill a new vector alternately with max and min elements.

Time Complexity: O(n log n) (sorting) + O(n), Space Complexity: O(n).

Optimal In-place (Encoding Technique):

Idea: Store two numbers at each index using a formula:
arr[i] = arr[i] + (new_value % max_elem + 1) \* max_elem

Extract final values by dividing each element by max_elem.

Time Complexity: O(n), Space Complexity: O(1).

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Approach 1: Brute Force using extra vector
void rearrangeMaxMinBruteForce(vector<int>& vec) {
    // Time Complexity: O(n log n) due to sorting + O(n) for rearrangement
    // Space Complexity: O(n) due to extra vector

    sort(vec.begin(), vec.end()); // Sort the vector in ascending order

    int n = vec.size();
    int left = 0;       // Pointer for minimum elements
    int right = n - 1;  // Pointer for maximum elements
    vector<int> result; // Temporary vector to store max-min rearrangement

    // Step: Pick alternately from end and start
    while(left <= right) {
        if(left != right) result.push_back(vec[right]); // Pick max
        else result.push_back(vec[right]);              // For odd element at center
        right--;

        if(left <= right) result.push_back(vec[left]);  // Pick min
        left++;
    }

    vec = result; // Copy result back to original vector
}

// Approach 2: Optimal In-place using encoding
void rearrangeMaxMinOptimal(vector<int>& vec) {
    // Time Complexity: O(n) (one pass)
    // Space Complexity: O(1) (in-place)

    int n = vec.size();
    int max_idx = n - 1; // Index of current maximum element
    int min_idx = 0;     // Index of current minimum element
    int max_elem = vec[max_idx] + 1; // Value greater than max element, used for encoding

    // Step: Encode two numbers at each index
    for(int i = 0; i < n; i++) {
        if(i % 2 == 0) {
            // Place max element at even index
            vec[i] = vec[i] + (vec[max_idx] % max_elem) * max_elem;
            max_idx--;
        } else {
            // Place min element at odd index
            vec[i] = vec[i] + (vec[min_idx] % max_elem) * max_elem;
            min_idx++;
        }
    }

    // Step: Decode new values by dividing with max_elem
    for(int i = 0; i < n; i++) {
        vec[i] = vec[i] / max_elem;
    }
}

int main() {
    vector<int> vec1 = {1, 2, 3, 4, 5, 6, 7};
    vector<int> vec2 = vec1; // Copy for optimal approach

    // Brute Force
    rearrangeMaxMinBruteForce(vec1);
    cout << "Max-Min rearrangement (Brute Force): ";
    for(int val : vec1) cout << val << " ";
    cout << endl;

    // Optimal In-place
    rearrangeMaxMinOptimal(vec2);
    cout << "Max-Min rearrangement (Optimal In-place): ";
    for(int val : vec2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: [1,2,3,4,5,6,7]

// Brute Force:
// Sorted: [1,2,3,4,5,6,7]
// left=0, right=6
Step1: result = [7] (max)
// left=0, right=5
Step2: result = [7,1] (min)
// left=1, right=5
Step3: result = [7,1,6] (max)
// Continue -> [7,1,6,2,5,3,4]

// Optimal In-place:
// max_elem = 8 (max+1)
// Encode even index with max, odd index with min
i=0 -> vec[0]=1 + (7 % 8)*8 = 1+56=57
i=1 -> vec[1]=2 + (1%8)*8 = 2+8=10
i=2 -> vec[2]=3 + (6%8)*8 = 3+48=51
...
Decode: vec[i]/8 -> [7,1,6,2,5,3,4]

```

---

## **Question: Merge two sorted arrays without extra space.**

**Approach:**
Problem Statement:

You are given two sorted vectors vec1 and vec2.

Merge them so that after merging, both remain sorted without using extra space.

Example:

Input: vec1 = [1, 4, 7, 8, 10], vec2 = [2, 3, 9]

Output: vec1 = [1, 2, 3, 4, 7], vec2 = [8, 9, 10]

Approach:

Brute Force (Extra Space - for reference only):

Merge both vectors into a temporary vector, sort, and copy back.

Time Complexity: O((n+m) log(n+m)), Space Complexity: O(n+m)

Optimal (In-place using Gap Method / Shell Sort idea):

Treat the two vectors as a single array.

Use a "gap" to compare elements that are gap distance apart and swap if out of order.

Reduce gap each iteration: gap = ceil(gap/2) until gap = 0.

Time Complexity: O((n+m) log(n+m)), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <cmath> // For ceil
using namespace std;

// Function to merge two sorted vectors without extra space using Gap Method
void mergeSortedVectors(vector<int>& vec1, vector<int>& vec2) {
    // Time Complexity: O((n+m) * log(n+m))
    // Space Complexity: O(1) -> no extra array used

    int n = vec1.size();
    int m = vec2.size();
    int gap = ceil((n + m) / 2.0); // Initial gap (ceil of total size / 2)

    while(gap > 0) {
        int i = 0;
        int j = gap;

        // Step 1: Compare elements in vec1 itself
        while(j < n) {
            if(vec1[i] > vec1[j]) swap(vec1[i], vec1[j]);
            i++; j++;
        }

        // Step 2: Compare elements between vec1 and vec2
        j = j - n; // If j >= n, convert to vec2 index
        while(i < n && j < m) {
            if(vec1[i] > vec2[j]) swap(vec1[i], vec2[j]);
            i++; j++;
        }

        // Step 3: Compare elements in vec2 itself
        if(j < m) {
            int k = 0;
            while(j + k < m) {
                if(vec2[k] > vec2[j + k]) swap(vec2[k], vec2[j + k]);
                k++;
            }
        }

        // Step 4: Reduce gap
        if(gap == 1) gap = 0;
        else gap = ceil(gap / 2.0);
    }
}

int main() {
    vector<int> vec1 = {1, 4, 7, 8, 10};
    vector<int> vec2 = {2, 3, 9};

    mergeSortedVectors(vec1, vec2);

    cout << "After merging without extra space:" << endl;
    cout << "Vector 1: ";
    for(int val : vec1) cout << val << " ";
    cout << endl;

    cout << "Vector 2: ";
    for(int val : vec2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// vec1=[1,4,7,8,10], vec2=[2,3,9], total size=8
gap = ceil(8/2)=4

// Gap 4:
i=0,j=4 -> compare vec1[0]=1 and vec1[4]=10 -> ok
i=1,j=5 -> compare vec1[1]=4 and vec2[0]=2 -> swap -> vec1=[1,2,7,8,10], vec2=[4,3,9]
i=2,j=6 -> compare vec1[2]=7 and vec2[1]=3 -> swap -> vec1=[1,2,3,8,10], vec2=[4,7,9]
i=3,j=7 -> compare vec1[3]=8 and vec2[2]=9 -> ok

// Reduce gap -> ceil(4/2)=2
Repeat comparisons for gap=2, swap if needed

// Reduce gap -> 1
Final merged:
vec1=[1,2,3,4,7], vec2=[8,9,10]

```

---

## **Question: Replace every element with the product of all other elements.**

**Approach:**
Brute Force (Nested Loops):

For each element, compute product of all other elements.

Time Complexity: O(n²), Space Complexity: O(1)

Optimal Approach (Prefix and Suffix Product):

Compute prefix products (product of elements before current index).

Compute suffix products (product of elements after current index).

Multiply prefix and suffix for each index to get final product.

Time Complexity: O(n), Space Complexity: O(n) (can optimize further to O(1) using single vector).

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force (Nested Loops)
void productExceptSelfBruteForce(vector<int>& vec) {
    // Time Complexity: O(n^2) -> For each element, multiply n-1 others
    // Space Complexity: O(1) -> In-place modification (or can use extra vector)

    int n = vec.size();
    vector<int> result(n, 1); // Initialize result vector with 1s

    // Step 1: For each element, compute product of all other elements
    for(int i = 0; i < n; i++) {
        int prod = 1; // Temporary product for current index
        for(int j = 0; j < n; j++) {
            if(i != j) { // Skip current element
                prod *= vec[j]; // Multiply other elements
            }
        }
        result[i] = prod; // Assign to result vector
    }

    vec = result; // Copy result back to original vector
}

// Approach 2: Optimal using Prefix and Suffix Product
void productExceptSelfOptimal(vector<int>& vec) {
    // Time Complexity: O(n) -> Three passes: prefix, suffix, final multiplication
    // Space Complexity: O(n) -> Extra vector for prefix or suffix (can optimize to O(1))

    int n = vec.size();
    vector<int> result(n, 1); // Final result vector
    vector<int> prefix(n, 1); // Prefix product array
    vector<int> suffix(n, 1); // Suffix product array

    // Step 1: Compute prefix products
    // prefix[i] = product of all elements before index i
    prefix[0] = 1; // No elements before first index
    for(int i = 1; i < n; i++) {
        prefix[i] = prefix[i-1] * vec[i-1];
    }

    // Step 2: Compute suffix products
    // suffix[i] = product of all elements after index i
    suffix[n-1] = 1; // No elements after last index
    for(int i = n-2; i >= 0; i--) {
        suffix[i] = suffix[i+1] * vec[i+1];
    }

    // Step 3: Multiply prefix and suffix for each index
    for(int i = 0; i < n; i++) {
        result[i] = prefix[i] * suffix[i];
    }

    vec = result; // Copy back to original vector
}

int main() {
    vector<int> vec1 = {1, 2, 3, 4};
    vector<int> vec2 = vec1; // Copy for optimal approach

    // Brute Force
    productExceptSelfBruteForce(vec1);
    cout << "Product Except Self (Brute Force): ";
    for(int val : vec1) cout << val << " ";
    cout << endl;

    // Optimal
    productExceptSelfOptimal(vec2);
    cout << "Product Except Self (Optimal): ";
    for(int val : vec2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec = [1,2,3,4]

// Brute Force:
i=0 -> product of all except vec[0]=2*3*4=24
i=1 -> 1*3*4=12
i=2 -> 1*2*4=8
i=3 -> 1*2*3=6
Output: [24,12,8,6]

// Optimal:
Prefix products: [1,1,2,6] -> prefix[1]=1*vec[0]=1, prefix[2]=1*vec[1]=2, prefix[3]=2*vec[2]=6
Suffix products: [24,12,4,1] -> suffix[2]=vec[3]=4, etc.
Final product: prefix[i]*suffix[i] = [1*24, 1*12, 2*4,6*1] = [24,12,8,6]

```

---

# 5️⃣ Two-pointer / Partitioning

## **Question: Two-sum problem in a sorted array (two-pointer).**

**Approach:**
Brute Force:

Check all pairs (i,j) to see if vec[i] + vec[j] == target.

Time Complexity: O(n²), Space Complexity: O(1)

Optimal Two-Pointer (Sorted Vector):

Initialize two pointers: left = 0 (start), right = n-1 (end).

While left < right:

If vec[left] + vec[right] == target, return pair.

If sum < target, move left++.

If sum > target, move right--.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force (Check all pairs)
bool twoSumBruteForce(vector<int>& vec, int target) {
    // Time Complexity: O(n^2) -> nested loops
    // Space Complexity: O(1) -> no extra memory

    int n = vec.size();
    // Step 1: Iterate over all possible pairs
    for(int i = 0; i < n; i++) {
        for(int j = i + 1; j < n; j++) { // j>i to avoid repetition
            if(vec[i] + vec[j] == target) { // Check sum
                cout << "Pair found: (" << vec[i] << "," << vec[j] << ")" << endl;
                return true; // Pair exists
            }
        }
    }
    return false; // No pair found
}

// Approach 2: Optimal Two-Pointer (Sorted vector)
bool twoSumTwoPointer(vector<int>& vec, int target) {
    // Time Complexity: O(n) -> single pass using two pointers
    // Space Complexity: O(1) -> in-place, no extra space

    int left = 0;           // Start pointer
    int right = vec.size() - 1; // End pointer

    // Step 1: Move pointers toward each other
    while(left < right) {
        int sum = vec[left] + vec[right]; // Current sum of two elements

        if(sum == target) {
            // Step 2a: Pair found
            cout << "Pair found: (" << vec[left] << "," << vec[right] << ")" << endl;
            return true;
        } else if(sum < target) {
            // Step 2b: Sum too small, move left pointer to increase sum
            left++;
        } else {
            // Step 2c: Sum too large, move right pointer to decrease sum
            right--;
        }
    }

    return false; // No pair found
}

int main() {
    vector<int> vec = {1, 2, 3, 4, 6};
    int target = 6;

    // Brute Force
    if(!twoSumBruteForce(vec, target)) cout << "No pair found (Brute Force)" << endl;

    // Optimal Two-Pointer
    if(!twoSumTwoPointer(vec, target)) cout << "No pair found (Two-Pointer)" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,2,3,4,6], target=6

// Brute Force:
// i=0,j=1 -> 1+2=3 -> not target
// i=0,j=2 -> 1+3=4 -> not target
// i=0,j=3 -> 1+4=5 -> not target
// i=0,j=4 -> 1+6=7 -> not target
// i=1,j=2 -> 2+3=5 -> not target
// i=1,j=3 -> 2+4=6 -> found pair (2,4)

// Two-Pointer:
// left=0,right=4 -> 1+6=7 > target -> move right--
// left=0,right=3 -> 1+4=5 < target -> move left++
// left=1,right=3 -> 2+4=6 == target -> found pair (2,4)

```

---

## **Question: Three-sum problem.**

**Approach:**
Brute Force (Triple Nested Loops):

Traverse all combinations of three elements (i,j,k) and check sum.

Time Complexity: O(n³), Space Complexity: O(1)

Optimal Two-Pointer Approach:

Fix the first element vec[i].

Use two pointers (left = i+1, right = n-1) to find pairs with sum target - vec[i].

Skip duplicates to avoid repeated triplets.

Time Complexity: O(n²), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force (Triple Nested Loops)
void threeSumBruteForce(vector<int>& vec, int target) {
    // Time Complexity: O(n^3)
    // Space Complexity: O(1)

    int n = vec.size();
    cout << "Triplets (Brute Force): ";

    // Step 1: Iterate over all triplets
    for(int i = 0; i < n - 2; i++) { // First element
        for(int j = i + 1; j < n - 1; j++) { // Second element
            for(int k = j + 1; k < n; k++) { // Third element
                if(vec[i] + vec[j] + vec[k] == target) {
                    cout << "(" << vec[i] << "," << vec[j] << "," << vec[k] << ") ";
                }
            }
        }
    }
    cout << endl;
}

// Approach 2: Optimal Two-Pointer for Sorted Vector
void threeSumTwoPointer(vector<int>& vec, int target) {
    // Time Complexity: O(n^2) -> Fix one element and use two-pointer for remaining
    // Space Complexity: O(1) -> No extra space except loop variables

    int n = vec.size();
    cout << "Triplets (Two-Pointer): ";

    // Step 1: Iterate through the vector fixing the first element
    for(int i = 0; i < n - 2; i++) {
        // Optional: Skip duplicates if vector may contain repeated elements
        if(i > 0 && vec[i] == vec[i-1]) continue;

        int left = i + 1;      // Second element
        int right = n - 1;     // Third element

        // Step 2: Use two-pointer to find pairs with sum = target - vec[i]
        while(left < right) {
            int sum = vec[i] + vec[left] + vec[right];

            if(sum == target) {
                cout << "(" << vec[i] << "," << vec[left] << "," << vec[right] << ") ";
                left++;   // Move left to next
                right--;  // Move right to previous

                // Optional: Skip duplicates
                while(left < right && vec[left] == vec[left - 1]) left++;
                while(left < right && vec[right] == vec[right + 1]) right--;
            } else if(sum < target) {
                // Sum too small, move left to increase sum
                left++;
            } else {
                // Sum too large, move right to decrease sum
                right--;
            }
        }
    }
    cout << endl;
}

int main() {
    vector<int> vec = {1, 2, 3, 4, 5, 6};
    int target = 10;

    // Brute Force
    threeSumBruteForce(vec, target);

    // Optimal Two-Pointer
    threeSumTwoPointer(vec, target);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,2,3,4,5,6], target=10

// Brute Force:
// i=0,j=1,k=2 -> 1+2+3=6 -> not target
// i=0,j=1,k=3 -> 1+2+4=7 -> not target
// i=0,j=1,k=4 -> 1+2+5=8 -> not target
// i=0,j=1,k=5 -> 1+2+6=9 -> not target
// i=0,j=2,k=3 -> 1+3+4=8 -> not target
// i=0,j=2,k=4 -> 1+3+5=9 -> not target
// i=0,j=2,k=5 -> 1+3+6=10 -> found (1,3,6)
// Similarly find (1,4,5),(2,3,5)

// Two-Pointer:
// Fix i=0 -> vec[i]=1, target for pair=10-1=9
// left=1,right=5 -> 2+6=8<9 -> left++
// left=2,right=5 -> 3+6=9 -> found (1,3,6)
// left=3,right=4 -> 4+5=9 -> found (1,4,5)
// i=1 -> vec[i]=2, pair target=8
// left=2,right=5 -> 3+6=9>8 -> right--
// left=2,right=4 -> 3+5=8 -> found (2,3,5)

```

---

## **Question: Count pairs with sum = X in unsorted array.**

**Approach:**
Brute Force (Nested Loops):

Check all pairs (i,j) to see if sum equals X.

Time Complexity: O(n²), Space Complexity: O(1)

Optimal Approach (Using Hash Map / Frequency Vector):

Use a hash map to store frequency of each element.

For each element a, check if X-a exists in the map.

Count number of valid pairs.

Time Complexity: O(n), Space Complexity: O(n)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Approach 1: Brute Force (Nested Loops)
int countPairsBruteForce(vector<int>& vec, int X) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1)
    int n = vec.size();
    int count = 0; // Counter for valid pairs

    // Step 1: Iterate through all possible pairs
    for(int i = 0; i < n; i++) {
        for(int j = i + 1; j < n; j++) { // j>i to avoid repetition
            if(vec[i] + vec[j] == X) {
                count++; // Increment counter
            }
        }
    }
    return count;
}

// Approach 2: Optimal Using Hash Map
int countPairsHashing(vector<int>& vec, int X) {
    // Time Complexity: O(n) -> single pass through vector
    // Space Complexity: O(n) -> hash map stores frequency of each element

    unordered_map<int,int> freq; // Map to store frequency of elements
    int count = 0;

    // Step 1: Traverse the vector
    for(int val : vec) {
        int complement = X - val; // The value needed to form sum X

        // Step 2: If complement exists in map, add its frequency to count
        if(freq.find(complement) != freq.end()) {
            count += freq[complement];
        }

        // Step 3: Increment frequency of current element in map
        freq[val]++;
    }

    return count;
}

int main() {
    vector<int> vec = {1, 5, 7, -1, 5};
    int X = 6;

    // Brute Force
    int bruteCount = countPairsBruteForce(vec, X);
    cout << "Number of pairs (Brute Force): " << bruteCount << endl;

    // Optimal Hashing
    int hashCount = countPairsHashing(vec, X);
    cout << "Number of pairs (Hashing): " << hashCount << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,5,7,-1,5], X=6

// Brute Force:
// i=0,j=1 -> 1+5=6 -> count=1
// i=0,j=2 -> 1+7=8 -> skip
// i=0,j=3 -> 1+(-1)=0 -> skip
// i=0,j=4 -> 1+5=6 -> count=2
// i=1,j=2 -> 5+7=12 -> skip
// i=1,j=3 -> 5+(-1)=4 -> skip
// i=1,j=4 -> 5+5=10 -> skip
// i=2,j=3 -> 7+(-1)=6 -> count=3
// i=2,j=4 -> 7+5=12 -> skip
// i=3,j=4 -> -1+5=4 -> skip
// Output: 3

// Hashing:
// freq map empty
// val=1, complement=5 -> not in map, freq[1]=1
// val=5, complement=1 -> freq[1]=1 -> count=1, freq[5]=1
// val=7, complement=-1 -> not in map, freq[7]=1
// val=-1, complement=7 -> freq[7]=1 -> count=2, freq[-1]=1
// val=5, complement=1 -> freq[1]=1 -> count=3, freq[5]=2
// Output: 3

```

---

## **Question: Partition array into even and odd numbers.**

**Approach:**
Brute Force (Extra Vector):

Create two vectors: one for even, one for odd.

Concatenate even and odd vectors.

Time Complexity: O(n), Space Complexity: O(n)

Optimal In-place (Two-Pointer Partitioning):

Use two pointers: left = 0, right = n-1.

Increment left until an odd number is found.

Decrement right until an even number is found.

Swap vec[left] and vec[right] and continue until left >= right.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force using extra vectors
void partitionEvenOddBruteForce(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)

    vector<int> even; // Store even numbers
    vector<int> odd;  // Store odd numbers

    // Step 1: Separate even and odd numbers
    for(int val : vec) {
        if(val % 2 == 0) {
            even.push_back(val); // Add even numbers
        } else {
            odd.push_back(val);  // Add odd numbers
        }
    }

    // Step 2: Concatenate even and odd vectors
    vec.clear();         // Clear original vector
    vec.insert(vec.end(), even.begin(), even.end()); // Add evens first
    vec.insert(vec.end(), odd.begin(), odd.end());   // Add odds next
}

// Approach 2: Optimal In-place using Two Pointers
void partitionEvenOddOptimal(vector<int>& vec) {
    // Time Complexity: O(n) -> single pass
    // Space Complexity: O(1) -> in-place partitioning

    int left = 0;              // Pointer from start
    int right = vec.size() - 1; // Pointer from end

    // Step: Move pointers and swap elements
    while(left < right) {
        // Increment left pointer until we find odd number
        while(left < right && vec[left] % 2 == 0) left++;

        // Decrement right pointer until we find even number
        while(left < right && vec[right] % 2 != 0) right--;

        // Swap odd at left with even at right
        if(left < right) {
            swap(vec[left], vec[right]);
            left++;
            right--;
        }
    }
}

int main() {
    vector<int> vec1 = {12, 34, 45, 9, 8, 90, 3};
    vector<int> vec2 = vec1; // Copy for optimal approach

    // Brute Force
    partitionEvenOddBruteForce(vec1);
    cout << "Even-Odd Partition (Brute Force): ";
    for(int val : vec1) cout << val << " ";
    cout << endl;

    // Optimal In-place
    partitionEvenOddOptimal(vec2);
    cout << "Even-Odd Partition (Optimal): ";
    for(int val : vec2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[12,34,45,9,8,90,3]

// Brute Force:
// even=[12,34,8,90], odd=[45,9,3]
// Concatenate -> [12,34,8,90,45,9,3]

// Optimal In-place:
// left=0,right=6
// vec[0]=12 even -> left++ -> left=1
// vec[1]=34 even -> left++ -> left=2
// vec[6]=3 odd -> right-- -> right=5
// vec[2]=45 odd, vec[5]=90 even -> swap -> vec=[12,34,90,9,8,45,3], left++, right--
// Continue until left>=right -> final partition: [12,34,90,8,9,45,3]

```

---

## **Question: Partition array into negative and positive numbers.**

**Approach:**
Brute Force (Extra Vectors):

Use two vectors: one for negative numbers, one for positive.

Concatenate negative and positive vectors.

Time Complexity: O(n), Space Complexity: O(n)

Optimal In-place (Two-Pointer Partitioning):

Use two pointers: left = 0, right = n-1.

Increment left until a positive number is found.

Decrement right until a negative number is found.

Swap vec[left] and vec[right] and continue until left >= right.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force using extra vectors
void partitionNegPosBruteForce(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)

    vector<int> neg; // Store negative numbers
    vector<int> pos; // Store positive numbers (and zero if treated positive)

    // Step 1: Separate negative and positive numbers
    for(int val : vec) {
        if(val < 0) neg.push_back(val);   // Negative
        else pos.push_back(val);          // Positive or zero
    }

    // Step 2: Concatenate negative and positive vectors
    vec.clear();               // Clear original vector
    vec.insert(vec.end(), neg.begin(), neg.end()); // Negatives first
    vec.insert(vec.end(), pos.begin(), pos.end()); // Positives next
}

// Approach 2: Optimal In-place using Two Pointers
void partitionNegPosOptimal(vector<int>& vec) {
    // Time Complexity: O(n) -> single pass
    // Space Complexity: O(1) -> in-place partitioning

    int left = 0;               // Start pointer
    int right = vec.size() - 1; // End pointer

    while(left < right) {
        // Increment left pointer until we find positive number
        while(left < right && vec[left] < 0) left++;

        // Decrement right pointer until we find negative number
        while(left < right && vec[right] >= 0) right--;

        // Swap positive at left with negative at right
        if(left < right) {
            swap(vec[left], vec[right]);
            left++;
            right--;
        }
    }
}

int main() {
    vector<int> vec1 = {12, -34, 45, -9, 8, -90, 3};
    vector<int> vec2 = vec1; // Copy for optimal approach

    // Brute Force
    partitionNegPosBruteForce(vec1);
    cout << "Negative-Positive Partition (Brute Force): ";
    for(int val : vec1) cout << val << " ";
    cout << endl;

    // Optimal In-place
    partitionNegPosOptimal(vec2);
    cout << "Negative-Positive Partition (Optimal): ";
    for(int val : vec2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[12,-34,45,-9,8,-90,3]

// Brute Force:
// neg=[-34,-9,-90], pos=[12,45,8,3]
// Concatenate -> [-34,-9,-90,12,45,8,3]

// Optimal In-place:
// left=0,right=6
// vec[0]=12 positive, vec[6]=3 positive -> right--
// vec[0]=12 positive, vec[5]=-90 negative -> swap -> vec=[-90,-34,45,-9,8,12,3], left++,right--
// left=1,right=4
// vec[1]=-34 negative -> left++, vec[4]=8 positive -> continue
// left=2,right=4
// vec[2]=45 positive, vec[4]=8 positive -> right--
// left=2,right=3
// vec[2]=45 positive, vec[3]=-9 negative -> swap -> vec=[-90,-34,-9,45,8,12,3], left++,right--
// left=3,right=2 -> stop
// Final partition: [-90,-34,-9,45,8,12,3]

```

---

## **Question: Dutch National Flag problem (0,1,2 sorting).**

**Approach:**
Brute Force (Counting Sort):

Count number of 0s, 1s, and 2s.

Overwrite the vector according to counts.

Time Complexity: O(n), Space Complexity: O(1)

Optimal In-place (Dutch National Flag / Three-Pointer):

Use three pointers: low, mid, high.

Initialize: low=0, mid=0, high=n-1.

Traverse vector with mid:

If vec[mid]==0, swap with vec[low], increment low and mid.

If vec[mid]==1, mid++.

If vec[mid]==2, swap with vec[high], decrement high.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force using Counting
void dutchFlagCounting(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1) -> only 3 counters

    int count0 = 0, count1 = 0, count2 = 0;

    // Step 1: Count number of 0s, 1s, 2s
    for(int val : vec) {
        if(val == 0) count0++;
        else if(val == 1) count1++;
        else count2++;
    }

    // Step 2: Overwrite vector based on counts
    int index = 0;
    while(count0--) vec[index++] = 0;
    while(count1--) vec[index++] = 1;
    while(count2--) vec[index++] = 2;
}

// Approach 2: Optimal Dutch National Flag Algorithm (Three-Pointer)
void dutchFlagOptimal(vector<int>& vec) {
    // Time Complexity: O(n) -> single pass
    // Space Complexity: O(1) -> in-place

    int low = 0;            // Pointer for next 0
    int mid = 0;            // Current element pointer
    int high = vec.size() - 1; // Pointer for next 2

    // Step 1: Traverse vector with mid
    while(mid <= high) {
        if(vec[mid] == 0) {
            // Swap current 0 to the low position
            swap(vec[mid], vec[low]);
            low++;  // Increment low pointer
            mid++;  // Increment mid pointer
        } else if(vec[mid] == 1) {
            // 1 is already in correct place
            mid++;
        } else if(vec[mid] == 2) {
            // Swap current 2 to the high position
            swap(vec[mid], vec[high]);
            high--; // Decrement high pointer
            // Do not increment mid here as swapped value needs checking
        }
    }
}

int main() {
    vector<int> vec1 = {0, 1, 2, 0, 1, 2, 1, 0};
    vector<int> vec2 = vec1; // Copy for optimal approach

    // Brute Force
    dutchFlagCounting(vec1);
    cout << "Dutch Flag Sort (Counting): ";
    for(int val : vec1) cout << val << " ";
    cout << endl;

    // Optimal In-place
    dutchFlagOptimal(vec2);
    cout << "Dutch Flag Sort (Optimal): ";
    for(int val : vec2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[0,1,2,0,1,2,1,0]

// Optimal:
// Initial: low=0, mid=0, high=7
// mid=0 -> vec[0]=0 -> swap with vec[low]=0 -> low++, mid++
// mid=1 -> vec[1]=1 -> mid++
// mid=2 -> vec[2]=2 -> swap with vec[high]=0 -> vec=[0,1,0,0,1,2,1,2], high--
// mid=2 -> vec[2]=0 -> swap with vec[low]=1 -> vec=[0,0,1,0,1,2,1,2], low++, mid++
// Continue process until mid>high
// Final vector: [0,0,0,1,1,1,2,2]

```

---

## **Question: Container with most water (two-pointer).**

**Approach:**
Brute Force (Check all pairs):

For each pair (i,j), calculate min(height[i], height[j]) \* (j-i) and track maximum.

Time Complexity: O(n²), Space Complexity: O(1)

Optimal Two-Pointer:

Use two pointers: left = 0 and right = n-1.

Calculate current water: min(height[left], height[right]) \* (right-left).

Move the pointer pointing to the smaller height (to potentially increase area).

Continue until left >= right.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force (All Pairs)
int maxWaterBruteForce(vector<int>& height) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1)
    int n = height.size();
    int maxArea = 0;

    // Step 1: Iterate over all pairs of lines
    for(int i = 0; i < n; i++) {
        for(int j = i+1; j < n; j++) {
            // Width = distance between lines
            int width = j - i;
            // Height = minimum of two lines
            int h = min(height[i], height[j]);
            int area = width * h; // Area of container
            if(area > maxArea) maxArea = area; // Update max
        }
    }
    return maxArea;
}

// Approach 2: Optimal Two-Pointer
int maxWaterTwoPointer(vector<int>& height) {
    // Time Complexity: O(n) -> single pass using two pointers
    // Space Complexity: O(1)

    int left = 0;                   // Start pointer
    int right = height.size() - 1;  // End pointer
    int maxArea = 0;

    // Step 1: Traverse vector until pointers meet
    while(left < right) {
        int width = right - left;                 // Distance between lines
        int h = min(height[left], height[right]); // Container height
        int area = width * h;                     // Current area
        if(area > maxArea) maxArea = area;       // Update maximum area

        // Step 2: Move the pointer pointing to smaller height
        if(height[left] < height[right]) left++; // Left shorter, move right to increase min height
        else right--;                             // Right shorter, move left
    }

    return maxArea;
}

int main() {
    vector<int> height = {1,8,6,2,5,4,8,3,7};

    // Brute Force
    cout << "Max Water (Brute Force): " << maxWaterBruteForce(height) << endl;

    // Optimal Two-Pointer
    cout << "Max Water (Two-Pointer): " << maxWaterTwoPointer(height) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: height=[1,8,6,2,5,4,8,3,7]

// Two-Pointer:
// left=0, right=8 -> width=8, min height=min(1,7)=1 -> area=8 -> maxArea=8
// height[left]=1<height[right]=7 -> left++
// left=1, right=8 -> width=7, min(8,7)=7 -> area=49 -> maxArea=49
// height[left]=8>height[right]=7 -> right--
// left=1, right=7 -> width=6, min(8,3)=3 -> area=18 -> maxArea=49
// left=1, right=6 -> width=5, min(8,8)=8 -> area=40 -> maxArea=49
// Continue moving pointers toward each other
// Final maxArea=49

```

---

## **Question: Remove duplicates from a sorted array (in-place).**

**Approach:**
Brute Force (Extra Vector):

Traverse the vector and push unique elements into a new vector.

Copy back if needed.

Time Complexity: O(n), Space Complexity: O(n)

Optimal In-place (Two Pointers):

Use two pointers: i tracks the last unique element, j scans the array.

If vec[j] != vec[i], increment i and set vec[i] = vec[j].

Return i + 1 as the new length.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force using extra vector
int removeDuplicatesBruteForce(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)

    vector<int> temp; // Temporary vector to store unique elements

    for(int val : vec) {
        // Only push if temp is empty or last element != current
        if(temp.empty() || temp.back() != val) {
            temp.push_back(val);
        }
    }

    // Copy back to original vector
    for(int i = 0; i < temp.size(); i++) {
        vec[i] = temp[i];
    }

    return temp.size(); // Return new length
}

// Approach 2: Optimal In-place using Two Pointers
int removeDuplicatesOptimal(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1) -> in-place

    int n = vec.size();
    if(n == 0) return 0; // Empty vector

    int i = 0; // Pointer for last unique element

    for(int j = 1; j < n; j++) { // j scans the vector
        if(vec[j] != vec[i]) {
            i++;           // Move i to next position
            vec[i] = vec[j]; // Update with new unique element
        }
    }

    return i + 1; // New length = index + 1
}

int main() {
    vector<int> vec1 = {1,1,2,2,2,3,4,4,5};
    vector<int> vec2 = vec1; // Copy for optimal approach

    // Brute Force
    int len1 = removeDuplicatesBruteForce(vec1);
    cout << "After removing duplicates (Brute Force): ";
    for(int i = 0; i < len1; i++) cout << vec1[i] << " ";
    cout << "\nNew length: " << len1 << endl;

    // Optimal In-place
    int len2 = removeDuplicatesOptimal(vec2);
    cout << "After removing duplicates (Optimal): ";
    for(int i = 0; i < len2; i++) cout << vec2[i] << " ";
    cout << "\nNew length: " << len2 << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,1,2,2,2,3,4,4,5]

// Optimal In-place:
// i=0, vec[i]=1
// j=1, vec[j]=1 -> same as vec[i], skip
// j=2, vec[j]=2 -> vec[i+1]=vec[1]=2, i=1
// j=3, vec[j]=2 -> same as vec[i], skip
// j=4, vec[j]=2 -> same as vec[i], skip
// j=5, vec[j]=3 -> vec[i+1]=vec[2]=3, i=2
// j=6, vec[j]=4 -> vec[i+1]=vec[3]=4, i=3
// j=7, vec[j]=4 -> same as vec[i], skip
// j=8, vec[j]=5 -> vec[i+1]=vec[4]=5, i=4
// Final vector: [1,2,3,4,5], New length = 5

```

---

# 6️⃣ Frequency / Counting / Hashing (7 questions)

## **Question: Count frequency of all elements (using extra array).**

**Approach:**
Using Extra Array:

Find the maximum element in the vector.

Create a frequency array of size maxElement + 1.

Traverse the vector and increment freq[vec[i]].

Time Complexity: O(n), Space Complexity: O(maxElement + 1)

Optimal Using Hash Map (for arbitrary elements):

If elements are negative or very large, use unordered_map<int,int> to store frequencies.

Time Complexity: O(n), Space Complexity: O(n)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach: Using Extra Frequency Array
void countFrequencyExtraArray(vector<int>& vec) {
    // Time Complexity: O(n) for traversing + O(n) for finding max
    // Space Complexity: O(maxElement + 1) for freq array

    if(vec.empty()) return; // Empty vector, nothing to count

    // Step 1: Find the maximum element in the vector
    int maxElement = vec[0];
    for(int val : vec) {
        if(val > maxElement) maxElement = val;
    }

    // Step 2: Create frequency array of size maxElement+1 and initialize with 0
    vector<int> freq(maxElement + 1, 0);

    // Step 3: Traverse vector and count occurrences
    for(int val : vec) {
        freq[val]++;
    }

    // Step 4: Print frequencies
    cout << "Element -> Frequency\n";
    for(int i = 0; i <= maxElement; i++) {
        if(freq[i] > 0) { // Only print elements present in vector
            cout << i << " -> " << freq[i] << endl;
        }
    }
}

int main() {
    vector<int> vec = {1, 2, 2, 3, 1, 2, 0};

    countFrequencyExtraArray(vec);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,2,2,3,1,2,0]

// Step 1: Find maxElement
// maxElement = 3

// Step 2: freq array of size 4 -> [0,0,0,0]

// Step 3: Count occurrences
// val=1 -> freq[1]=1
// val=2 -> freq[2]=1
// val=2 -> freq[2]=2
// val=3 -> freq[3]=1
// val=1 -> freq[1]=2
// val=2 -> freq[2]=3
// val=0 -> freq[0]=1

// Step 4: Print frequencies
// Output:
// 0 -> 1
// 1 -> 2
// 2 -> 3
// 3 -> 1

```

---

## **Question: Find majority element (> n/2 occurrences).**

**Approach:**
Brute Force (Count Each Element):

For each element, count occurrences.

If count > n/2, return element.

Time Complexity: O(n²), Space Complexity: O(1)

Using Hash Map:

Count frequencies using unordered_map.

Return element with frequency > n/2 if exists.

Time Complexity: O(n), Space Complexity: O(n)

Optimal (Boyer-Moore Voting Algorithm):

Step 1: Find candidate: Traverse vector and maintain count and candidate.

If count=0, set candidate=vec[i].

If vec[i]==candidate, increment count, else decrement count.

Step 2: Verify candidate occurs > n/2 times.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Approach 1: Brute Force
int majorityBruteForce(vector<int>& vec) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1)
    int n = vec.size();
    for(int i = 0; i < n; i++) {
        int count = 0;
        for(int j = 0; j < n; j++) {
            if(vec[j] == vec[i]) count++;
        }
        if(count > n/2) return vec[i];
    }
    return -1; // No majority element
}

// Approach 2: Using Hash Map
int majorityHashMap(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    unordered_map<int,int> freq;
    int n = vec.size();
    for(int val : vec) {
        freq[val]++;
        if(freq[val] > n/2) return val; // Early return if majority found
    }
    return -1; // No majority element
}

// Approach 3: Boyer-Moore Voting Algorithm
int majorityBoyerMoore(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int candidate = -1; // Potential majority element
    int count = 0;      // Counter for candidate

    // Step 1: Find candidate
    for(int val : vec) {
        if(count == 0) candidate = val; // Reset candidate
        if(val == candidate) count++;   // Increment if matches candidate
        else count--;                   // Decrement otherwise
    }

    // Step 2: Verify candidate
    count = 0;
    for(int val : vec) {
        if(val == candidate) count++;
    }

    if(count > vec.size()/2) return candidate;
    return -1; // No majority element
}

int main() {
    vector<int> vec = {3,3,4,2,3,3,3};

    cout << "Majority Element (Brute Force): " << majorityBruteForce(vec) << endl;
    cout << "Majority Element (Hash Map): " << majorityHashMap(vec) << endl;
    cout << "Majority Element (Boyer-Moore): " << majorityBoyerMoore(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[3,3,4,2,3,3,3], n=7

// Brute Force:
// i=0, vec[i]=3, count occurrences=5 > n/2=3 -> return 3

// Hash Map:
// freq[3]=1
// freq[3]=2
// freq[4]=1
// freq[2]=1
// freq[3]=3
// freq[3]=4 -> > n/2=3 -> return 3

// Boyer-Moore:
// candidate=-1, count=0
// val=3 -> count=0 -> candidate=3, count=1
// val=3 -> candidate=3 -> count=2
// val=4 -> count-- -> count=1
// val=2 -> count-- -> count=0
// val=3 -> count=0 -> candidate=3, count=1
// val=3 -> candidate=3 -> count=2
// val=3 -> candidate=3 -> count=3
// Verify: occurrences of 3=5 > n/2=3 -> return 3

```

---

## **Question: Find elements occurring more than n/3 times.**

**Approach:**
Using Hash Map:

Count frequency of each element using unordered_map.

Return elements with frequency > n/3.

Time Complexity: O(n), Space Complexity: O(n)

Optimal Extended Boyer-Moore Voting Algorithm:

At most 2 elements can appear more than n/3 times.

Step 1: Maintain two candidates and counts (candidate1, count1, candidate2, count2).

Step 2: Traverse vector:

If element matches candidate1 or candidate2 → increment respective count

Else if count1 == 0 → candidate1 = element, count1=1

Else if count2 == 0 → candidate2 = element, count2=1

Else → decrement both counts

Step 3: Verify candidates actually appear > n/3 times.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Approach 1: Using Hash Map
vector<int> elementsMoreThanNBy3HashMap(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    unordered_map<int,int> freq;
    int n = vec.size();
    vector<int> result;

    // Step 1: Count frequencies
    for(int val : vec) freq[val]++;

    // Step 2: Collect elements appearing more than n/3 times
    for(auto it : freq) {
        if(it.second > n/3) result.push_back(it.first);
    }

    return result;
}

// Approach 2: Extended Boyer-Moore Voting Algorithm
vector<int> elementsMoreThanNBy3BoyerMoore(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int candidate1 = -1, candidate2 = -1;
    int count1 = 0, count2 = 0;

    // Step 1: Find potential candidates
    for(int val : vec) {
        if(val == candidate1) count1++;
        else if(val == candidate2) count2++;
        else if(count1 == 0) { candidate1 = val; count1 = 1; }
        else if(count2 == 0) { candidate2 = val; count2 = 1; }
        else { count1--; count2--; }
    }

    // Step 2: Verify candidates
    count1 = count2 = 0;
    for(int val : vec) {
        if(val == candidate1) count1++;
        else if(val == candidate2) count2++;
    }

    vector<int> result;
    int n = vec.size();
    if(count1 > n/3) result.push_back(candidate1);
    if(count2 > n/3) result.push_back(candidate2);

    return result;
}

int main() {
    vector<int> vec = {1,2,2,3,2,1,1,3};

    // Hash Map Approach
    vector<int> res1 = elementsMoreThanNBy3HashMap(vec);
    cout << "Elements appearing more than n/3 (Hash Map): ";
    for(int val : res1) cout << val << " ";
    cout << endl;

    // Extended Boyer-Moore Approach
    vector<int> res2 = elementsMoreThanNBy3BoyerMoore(vec);
    cout << "Elements appearing more than n/3 (Boyer-Moore): ";
    for(int val : res2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,2,2,3,2,1,1,3], n=8, n/3≈2.66

// Extended Boyer-Moore:
// candidate1=-1,count1=0; candidate2=-1,count2=0

// val=1 -> count1=0 -> candidate1=1, count1=1
// val=2 -> count2=0 -> candidate2=2, count2=1
// val=2 -> val==candidate2 -> count2=2
// val=3 -> else -> count1--, count2-- -> count1=0,count2=1
// val=2 -> val==candidate2 -> count2=2
// val=1 -> count1=0 -> candidate1=1, count1=1
// val=1 -> val==candidate1 -> count1=2
// val=3 -> else -> count1--, count2-- -> count1=1,count2=1

// Verify counts:
// candidate1=1 -> occurs 3 times > n/3 -> include
// candidate2=2 -> occurs 3 times > n/3 -> include
// Result: [1,2]

```

---

## **Question: Find duplicates in an array.**

**Approach:**
Using Hash Map:

Count frequency of each element.

Return elements with frequency > 1.

Time Complexity: O(n), Space Complexity: O(n)

Optimal In-place (Only if elements are in 1…n):

For vector elements in range 1..n, mark visited by making vec[abs(val)-1] negative.

If already negative → duplicate.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Approach 1: Using Hash Map
vector<int> findDuplicatesHashMap(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    unordered_map<int,int> freq;
    vector<int> duplicates;

    // Step 1: Count frequencies
    for(int val : vec) freq[val]++;

    // Step 2: Collect elements with frequency > 1
    for(auto it : freq) {
        if(it.second > 1) duplicates.push_back(it.first);
    }

    return duplicates;
}

// Approach 2: Optimal In-place (for elements in 1..n)
// Only works if elements are positive and in range 1 to n
vector<int> findDuplicatesInPlace(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1) (ignoring output)
    vector<int> duplicates;

    for(int i = 0; i < vec.size(); i++) {
        int index = abs(vec[i]) - 1; // Map value to index
        if(vec[index] < 0) {
            // Already visited -> duplicate
            duplicates.push_back(abs(vec[i]));
        } else {
            // Mark visited by making negative
            vec[index] = -vec[index];
        }
    }

    // Restore original vector (optional)
    for(int i = 0; i < vec.size(); i++) {
        if(vec[i] < 0) vec[i] = -vec[i];
    }

    return duplicates;
}

int main() {
    vector<int> vec = {1,2,3,2,4,5,1,6};
    vector<int> vec2 = vec; // Copy for in-place approach

    // Hash Map Approach
    vector<int> dup1 = findDuplicatesHashMap(vec);
    cout << "Duplicates (Hash Map): ";
    for(int val : dup1) cout << val << " ";
    cout << endl;

    // In-place Approach
    vector<int> dup2 = findDuplicatesInPlace(vec2);
    cout << "Duplicates (In-place): ";
    for(int val : dup2) cout << val << " ";
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,2,3,2,4,5,1,6]

// Hash Map:
// freq: {1:2,2:2,3:1,4:1,5:1,6:1}
// Duplicates: [1,2]

// In-place:
// i=0, val=1 -> index=0 -> vec[0]=1>0 -> mark vec[0]=-1
// i=1, val=2 -> index=1 -> vec[1]=2>0 -> mark vec[1]=-2
// i=2, val=3 -> index=2 -> vec[2]=3>0 -> mark vec[2]=-3
// i=3, val=2 -> index=1 -> vec[1]=-2 <0 -> duplicate found: 2
// i=4, val=4 -> index=3 -> vec[3]=2>0 -> mark vec[3]=-2
// i=5, val=5 -> index=4 -> vec[4]=4>0 -> mark vec[4]=-4
// i=6, val=1 -> index=0 -> vec[0]=-1 <0 -> duplicate found: 1
// i=7, val=6 -> index=5 -> vec[5]=5>0 -> mark vec[5]=-5
// Restore vector: [1,2,3,2,4,5,1,6]
// Duplicates: [2,1]

```

---

## **Question: Find missing number in 1 to n array.**

**Approach:**
Sum Formula:

Sum of 1 to n = n\*(n+1)/2.

Missing number = Sum_1_to_n - sum(vector).

Time Complexity: O(n), Space Complexity: O(1)

XOR Approach:

XOR all numbers from 1 to n and XOR all elements in vector.

Missing number = XOR of the above two results.

Time Complexity: O(n), Space Complexity: O(1)

Hash Map/Array Approach:

Mark elements present in a boolean array of size n.

Missing number = index not marked.

Time Complexity: O(n), Space Complexity: O(n)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Using Sum Formula
int missingNumberSum(vector<int>& vec, int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int total = n * (n + 1) / 2; // Sum of first n numbers
    int sumVec = 0;
    for(int val : vec) sumVec += val; // Sum of vector elements
    return total - sumVec; // Missing number
}

// Approach 2: Using XOR
int missingNumberXOR(vector<int>& vec, int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int xorAll = 0; // XOR of numbers from 1 to n
    int xorVec = 0; // XOR of elements in vector

    for(int i = 1; i <= n; i++) xorAll ^= i;
    for(int val : vec) xorVec ^= val;

    return xorAll ^ xorVec; // XOR of above two gives missing number
}

// Approach 3: Using Boolean Array
int missingNumberArray(vector<int>& vec, int n) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    vector<bool> present(n+1, false); // Index 1..n

    for(int val : vec) present[val] = true; // Mark present numbers

    for(int i = 1; i <= n; i++) {
        if(!present[i]) return i; // First unmarked index is missing
    }
    return -1; // Should not happen
}

int main() {
    vector<int> vec = {1,2,4,5,6};
    int n = 6; // Total numbers from 1 to n

    cout << "Missing Number (Sum Formula): " << missingNumberSum(vec, n) << endl;
    cout << "Missing Number (XOR): " << missingNumberXOR(vec, n) << endl;
    cout << "Missing Number (Boolean Array): " << missingNumberArray(vec, n) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,2,4,5,6], n=6

// Sum Formula:
// total = 6*7/2 = 21
// sumVec = 1+2+4+5+6 = 18
// Missing = 21 - 18 = 3

// XOR Approach:
// xorAll = 1^2^3^4^5^6 = 7
// xorVec = 1^2^4^5^6 = 4
// Missing = xorAll^xorVec = 7^4 = 3

// Boolean Array:
// present = [false,true,true,false,true,true,true]
// First false index from 1..n = 3
// Missing number = 3

```

---

## **Question: Find first repeating element.**

**Approach:**
Brute Force:

Check every pair (i,j) where i<j to find first repeat.

Time Complexity: O(n²), Space Complexity: O(1)

Using Hash Map:

Traverse vector from left to right, track frequency in unordered_map.

The first element whose count becomes 2 → first repeating element.

Time Complexity: O(n), Space Complexity: O(n)

Optimal Using Index Array (if elements in 1..n):

Use a boolean vector to mark visited elements.

First element that is already visited → first repeating.

Time Complexity: O(n), Space Complexity: O(n)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Approach 1: Brute Force
int firstRepeatingBruteForce(vector<int>& vec) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1)
    int n = vec.size();
    for(int i = 0; i < n; i++) {
        for(int j = i+1; j < n; j++) {
            if(vec[i] == vec[j]) return vec[i]; // Found first repeat
        }
    }
    return -1; // No repeating element
}

// Approach 2: Using Hash Map
int firstRepeatingHashMap(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    unordered_map<int,int> freq;

    for(int val : vec) {
        freq[val]++;
        if(freq[val] == 2) return val; // First element to repeat
    }

    return -1; // No repeating element
}

// Approach 3: Using Visited Array (for elements 1..n)
int firstRepeatingIndexArray(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    int n = vec.size();
    vector<bool> visited(n+1, false); // Assuming elements in 1..n

    for(int val : vec) {
        if(visited[val]) return val; // Already visited -> repeat
        visited[val] = true;         // Mark as visited
    }

    return -1; // No repeating element
}

int main() {
    vector<int> vec = {10, 5, 3, 4, 3, 5, 6};
    vector<int> vec2 = {1, 2, 3, 4, 3, 2}; // For index array approach (elements 1..n)

    cout << "First Repeating (Brute Force): " << firstRepeatingBruteForce(vec) << endl;
    cout << "First Repeating (Hash Map): " << firstRepeatingHashMap(vec) << endl;
    cout << "First Repeating (Index Array, 1..n): " << firstRepeatingIndexArray(vec2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[10,5,3,4,3,5,6]

// Hash Map Approach:
// freq={}
0 -> 10: freq[10]=1
1 -> 5: freq[5]=1
2 -> 3: freq[3]=1
3 -> 4: freq[4]=1
4 -> 3: freq[3]=2 -> first repeating element found = 3
// Output: 3

// Brute Force:
// i=0, val=10 -> check j=1..6 -> no match
// i=1, val=5 -> check j=2..6 -> j=5, vec[j]=5 -> first repeat found = 5
// Depending on method, first repeat is based on earliest second occurrence

```

---

## **Question: Count number of elements in a given range [L, R].**

**Approach:**
Approach:

Brute Force:

Traverse the vector and increment counter if L <= vec[i] <= R.

Time Complexity: O(n), Space Complexity: O(1)

Using Sorting + Binary Search (Optional for multiple queries):

Sort the vector.

Use lower_bound(L) and upper_bound(R) to find indices.

Count = upper_index - lower_index.

Time Complexity: O(n log n + q log n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // For sorting approach
using namespace std;

// Approach 1: Brute Force
int countInRangeBruteForce(vector<int>& vec, int L, int R) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int count = 0; // Initialize counter

    for(int val : vec) {
        if(val >= L && val <= R) { // Check if element lies in range
            count++;              // Increment counter
        }
    }

    return count; // Total elements in range
}

// Approach 2: Sorting + Binary Search (efficient for multiple queries)
int countInRangeBinarySearch(vector<int>& vec, int L, int R) {
    // Time Complexity: O(n log n) for sort + O(log n) for query
    // Space Complexity: O(1)
    sort(vec.begin(), vec.end()); // Sort vector first

    // lower_bound returns iterator to first element >= L
    auto low = lower_bound(vec.begin(), vec.end(), L);
    // upper_bound returns iterator to first element > R
    auto high = upper_bound(vec.begin(), vec.end(), R);

    return high - low; // Number of elements in range
}

int main() {
    vector<int> vec = {1, 5, 3, 7, 9, 2};
    int L = 3, R = 7;

    cout << "Count in range [L,R] (Brute Force): " << countInRangeBruteForce(vec, L, R) << endl;
    cout << "Count in range [L,R] (Binary Search after Sort): " << countInRangeBinarySearch(vec, L, R) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,5,3,7,9,2], L=3, R=7

// Brute Force:
// val=1 -> 1<3 -> skip
// val=5 -> 3<=5<=7 -> count=1
// val=3 -> 3<=3<=7 -> count=2
// val=7 -> 3<=7<=7 -> count=3
// val=9 -> 9>7 -> skip
// val=2 -> 2<3 -> skip
// Output: count=3

// Binary Search Approach:
// Sorted vec = [1,2,3,5,7,9]
// lower_bound(3) -> points to 3 (index=2)
// upper_bound(7) -> points to 9 (index=5)
// Count = 5 - 2 = 3

```

---

# 7️⃣ Miscellaneous / Patterns (10 questions)

## **Question: Arrange array in alternating high-low pattern.**

**Approach:**
Question: Arrange Vector in Alternating High-Low Pattern

Problem Statement:

Given a vector, rearrange it such that elements follow the pattern: arr[0] >= arr[1] <= arr[2] >= arr[3] …

Example:

Input: [3, 5, 2, 1, 6, 4]

Output: [5, 2, 6, 1, 4, 3] → one possible valid arrangement

Approach:

Sorting + Swap Adjacent:

Sort the vector.

Swap every adjacent pair starting from index 1.

Time Complexity: O(n log n), Space Complexity: O(1)

One-Pass (Greedy, In-place):

Traverse vector:

For even indices, ensure vec[i] >= vec[i+1] → swap if not

For odd indices, ensure vec[i] <= vec[i+1] → swap if not

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Approach 1: Sorting + Swap Adjacent
void alternatingHighLowSort(vector<int>& vec) {
    // Time Complexity: O(n log n)
    // Space Complexity: O(1)
    sort(vec.begin(), vec.end()); // Sort vector ascending

    // Swap every adjacent pair starting from index 1
    for(int i = 1; i < vec.size(); i += 2) {
        swap(vec[i], vec[i-1]);
    }
}

// Approach 2: One-Pass Greedy (Optimal, In-place)
void alternatingHighLowGreedy(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    for(int i = 0; i < n - 1; i++) {
        if(i % 2 == 0) {
            // Even index, ensure vec[i] >= vec[i+1]
            if(vec[i] < vec[i+1]) swap(vec[i], vec[i+1]);
        } else {
            // Odd index, ensure vec[i] <= vec[i+1]
            if(vec[i] > vec[i+1]) swap(vec[i], vec[i+1]);
        }
    }
}

// Helper function to print vector
void printVector(vector<int>& vec) {
    for(int val : vec) cout << val << " ";
    cout << endl;
}

int main() {
    vector<int> vec1 = {3,5,2,1,6,4};
    vector<int> vec2 = vec1; // Copy for second approach

    // Sorting + Swap Adjacent
    alternatingHighLowSort(vec1);
    cout << "Alternating High-Low (Sort + Swap): ";
    printVector(vec1);

    // One-Pass Greedy
    alternatingHighLowGreedy(vec2);
    cout << "Alternating High-Low (Greedy): ";
    printVector(vec2);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[3,5,2,1,6,4]

// Approach 1: Sort + Swap
// Sorted vec: [1,2,3,4,5,6]
// Swap indices 0-1 -> [2,1,3,4,5,6]
// Swap indices 2-3 -> [2,1,4,3,5,6]
// Swap indices 4-5 -> [2,1,4,3,6,5]
// Output: [2,1,4,3,6,5] -> satisfies alternating pattern

// Approach 2: One-Pass Greedy
// i=0 even: 3<5 -> swap -> vec=[5,3,2,1,6,4]
// i=1 odd: 3>2 -> swap -> vec=[5,2,3,1,6,4]
// i=2 even: 3<1 -> ok
// i=3 odd: 1>6 -> swap -> vec=[5,2,3,6,1,4]
// i=4 even: 1<4 -> swap -> vec=[5,2,3,6,4,1]
// Output: [5,2,3,6,4,1] -> valid alternating pattern

```

---

## **Question: Rearrange array such that positive and negative numbers alternate.**

**Approach:**
Approach:

Separate Positives and Negatives:

Create two vectors: positives and negatives.

Merge them alternately.

Time Complexity: O(n), Space Complexity: O(n)

In-place Greedy (Two Pointers):

Traverse vector, ensure alternating sign:

If mismatch at index i (i.e., positive where negative expected or vice versa), find next opposite-signed element and rotate subarray to fix.

Time Complexity: O(n), Space Complexity: O(1) (in-place, may use rotation logic)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Separate Positives and Negatives
vector<int> alternatePosNegSeparate(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    vector<int> pos, neg;

    // Separate positives and negatives
    for(int val : vec) {
        if(val >= 0) pos.push_back(val);
        else neg.push_back(val);
    }

    vector<int> result;
    int i = 0, j = 0;
    // Merge alternately
    while(i < pos.size() && j < neg.size()) {
        result.push_back(pos[i++]);
        result.push_back(neg[j++]);
    }
    // Append remaining positives
    while(i < pos.size()) result.push_back(pos[i++]);
    // Append remaining negatives
    while(j < neg.size()) result.push_back(neg[j++]);

    return result;
}

// Approach 2: In-place Greedy (rotate elements)
void alternatePosNegInPlace(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();

    // 'wrong' points to index where sign mismatch occurs
    int wrong = -1;

    for(int i = 0; i < n; i++) {
        if(wrong >= 0) {
            // Check if current element can be swapped to fix mismatch
            if((vec[i] >= 0 && vec[wrong] < 0) || (vec[i] < 0 && vec[wrong] >= 0)) {
                // Right rotate subarray between 'wrong' and 'i'
                int temp = vec[i];
                for(int k = i; k > wrong; k--) vec[k] = vec[k-1];
                vec[wrong] = temp;

                // If distance > 2, next wrong index shifts by 2, else reset
                if(i - wrong >= 2) wrong += 2;
                else wrong = -1;
            }
        }

        // Update wrong if mismatch found
        if(wrong == -1) {
            if((i % 2 == 0 && vec[i] < 0) || (i % 2 == 1 && vec[i] >= 0)) wrong = i;
        }
    }
}

// Helper function to print vector
void printVector(vector<int>& vec) {
    for(int val : vec) cout << val << " ";
    cout << endl;
}

int main() {
    vector<int> vec1 = {1, 2, -3, -4, 5, -6};
    vector<int> vec2 = vec1; // Copy for in-place approach

    // Separate Positives and Negatives
    vector<int> res1 = alternatePosNegSeparate(vec1);
    cout << "Alternate Pos-Neg (Separate Vectors): ";
    printVector(res1);

    // In-place Greedy
    alternatePosNegInPlace(vec2);
    cout << "Alternate Pos-Neg (In-place): ";
    printVector(vec2);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,2,-3,-4,5,-6]

// Approach 1: Separate Vectors
pos=[1,2,5], neg=[-3,-4,-6]
Merge alternately: 1,-3,2,-4,5,-6
Remaining elements: none
Output: [1,-3,2,-4,5,-6]

// Approach 2: In-place Greedy
i=0: vec[0]=1 (even) OK
i=1: vec[1]=2 (odd, positive expected negative) -> wrong=1
i=2: vec[2]=-3 -> opposite sign -> rotate [wrong..i] -> vec=[1,-3,2,-4,5,-6], wrong=3
i=3: vec[3]=-4 (odd, negative) OK -> wrong=-1
i=4: vec[4]=5 (even, positive) OK
i=5: vec[5]=-6 (odd, negative) OK
Output: [1,-3,2,-4,5,-6]

```

---

## **Question: Find peak element (element greater than neighbors).**

**Approach:**
Linear Scan (O(n)):

Traverse the vector from start to end, check for each element if it satisfies peak condition.

Time Complexity: O(n), Space Complexity: O(1)

Binary Search (O(log n)) – Efficient:

Use modified binary search:

mid element vec[mid]

If vec[mid] < vec[mid+1], peak lies on right side

Else if vec[mid] < vec[mid-1], peak lies on left side

Else vec[mid] is peak

Time Complexity: O(log n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Linear Scan
int findPeakLinear(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    if(n == 0) return -1; // Empty vector
    if(n == 1) return vec[0]; // Single element is peak

    // Check first element
    if(vec[0] >= vec[1]) return vec[0];

    // Check middle elements
    for(int i = 1; i < n-1; i++) {
        if(vec[i] >= vec[i-1] && vec[i] >= vec[i+1]) return vec[i];
    }

    // Check last element
    if(vec[n-1] >= vec[n-2]) return vec[n-1];

    return -1; // No peak (should not happen)
}

// Approach 2: Binary Search
int findPeakBinarySearch(vector<int>& vec) {
    // Time Complexity: O(log n)
    // Space Complexity: O(1)
    int n = vec.size();
    int low = 0, high = n-1;

    while(low <= high) {
        int mid = low + (high - low)/2;

        // Check neighbors with boundary conditions
        int left = (mid == 0) ? INT_MIN : vec[mid-1];
        int right = (mid == n-1) ? INT_MIN : vec[mid+1];

        if(vec[mid] >= left && vec[mid] >= right) {
            return vec[mid]; // Peak found
        } else if(vec[mid] < right) {
            // Peak must be in right half
            low = mid + 1;
        } else {
            // Peak must be in left half
            high = mid - 1;
        }
    }

    return -1; // Should not happen
}

int main() {
    vector<int> vec = {1, 3, 20, 4, 1, 0};

    cout << "Peak Element (Linear Scan): " << findPeakLinear(vec) << endl;
    cout << "Peak Element (Binary Search): " << findPeakBinarySearch(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,3,20,4,1,0], n=6

// Linear Scan:
// i=0: vec[0]=1 < vec[1]=3 -> not peak
// i=1: vec[1]=3 < vec[2]=20 -> not peak
// i=2: vec[2]=20 >= vec[1]=3 && vec[2]=20 >= vec[3]=4 -> peak found = 20

// Binary Search:
// low=0, high=5, mid=2
// left=vec[1]=3, right=vec[3]=4
// vec[2]=20 >= left & right -> peak found = 20

```

---

## **Question: Find valleys (element smaller than neighbors).**

**Approach:**
Linear Scan:

Traverse the vector from start to end and check each element against neighbors.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach: Linear Scan to find valleys
vector<int> findValleys(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1) extra (output vector counts as O(n))
    vector<int> valleys;
    int n = vec.size();
    if(n == 0) return valleys; // Empty vector

    for(int i = 0; i < n; i++) {
        int left = (i == 0) ? INT_MAX : vec[i-1];   // Treat boundary as INF
        int right = (i == n-1) ? INT_MAX : vec[i+1]; // Treat boundary as INF

        if(vec[i] <= left && vec[i] <= right) {
            valleys.push_back(vec[i]); // Current element is valley
        }
    }

    return valleys;
}

// Helper function to print vector
void printVector(vector<int>& vec) {
    for(int val : vec) cout << val << " ";
    cout << endl;
}

int main() {
    vector<int> vec = {5, 3, 4, 2, 6, 1};

    vector<int> valleys = findValleys(vec);
    cout << "Valleys in vector: ";
    printVector(valleys);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[5,3,4,2,6,1], n=6

// i=0: vec[0]=5, left=INF, right=3 -> 5 <= INF? yes, 5<=3? no -> not valley
// i=1: vec[1]=3, left=5, right=4 -> 3<=5? yes, 3<=4? yes -> valley found: 3
// i=2: vec[2]=4, left=3, right=2 -> 4<=3? no -> not valley
// i=3: vec[3]=2, left=4, right=6 -> 2<=4 & 2<=6 -> valley found: 2
// i=4: vec[4]=6, left=2, right=1 -> 6<=2? no -> not valley
// i=5: vec[5]=1, left=6, right=INF -> 1<=6 & 1<=INF -> valley found: 1

// Output: [3, 2, 1]

```

---

## **Question: Maximum difference between two elements such that larger comes after smaller.**

**Approach:**
Approach:

Brute Force (O(n²)):

Check all pairs (i,j) where j > i.

Time Complexity: O(n²), Space Complexity: O(1)

Optimal (One Pass):

Track minimum element so far while traversing.

Update maxDiff = max(maxDiff, vec[i] - min_so_far).

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

// Approach 1: Brute Force
int maxDifferenceBruteForce(vector<int>& vec) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1)
    int n = vec.size();
    int maxDiff = INT_MIN; // Initialize max difference

    for(int i = 0; i < n-1; i++) {
        for(int j = i+1; j < n; j++) {
            int diff = vec[j] - vec[i]; // Difference where j > i
            if(diff > maxDiff) maxDiff = diff;
        }
    }

    return maxDiff;
}

// Approach 2: Optimal One Pass
int maxDifferenceOptimal(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    if(n < 2) return 0; // Not enough elements for difference

    int min_so_far = vec[0]; // Track minimum element so far
    int maxDiff = vec[1] - vec[0]; // Initial difference

    for(int i = 1; i < n; i++) {
        int diff = vec[i] - min_so_far; // Difference with minimum so far
        if(diff > maxDiff) maxDiff = diff; // Update maxDiff
        if(vec[i] < min_so_far) min_so_far = vec[i]; // Update min_so_far
    }

    return maxDiff;
}

int main() {
    vector<int> vec = {2, 3, 10, 6, 4, 8, 1};

    cout << "Maximum Difference (Brute Force): " << maxDifferenceBruteForce(vec) << endl;
    cout << "Maximum Difference (Optimal One Pass): " << maxDifferenceOptimal(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[2,3,10,6,4,8,1]

// Optimal Approach:
// min_so_far=2, maxDiff=3-2=1
// i=1: vec[1]=3, diff=3-2=1 -> maxDiff=1
// i=2: vec[2]=10, diff=10-2=8 -> maxDiff=8
// i=3: vec[3]=6, diff=6-2=4 -> maxDiff=8
// i=4: vec[4]=4, diff=4-2=2 -> maxDiff=8
// i=5: vec[5]=8, diff=8-2=6 -> maxDiff=8
// i=6: vec[6]=1, diff=1-2=-1 -> maxDiff=8, update min_so_far=1
// Output: 8

```

---

## **Question: Rearrange array to make even numbers at even indices and odd numbers at odd indices**

**Approach:**
Separate Even and Odd Arrays:

Create two vectors: evens and odds.

Place alternately into result vector.

Time Complexity: O(n), Space Complexity: O(n)

In-place Two-Pointer (Greedy):

Use two pointers evenIndex=0, oddIndex=1.

Find misplaced elements and swap.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Separate Even and Odd Arrays
vector<int> rearrangeEvenOddSeparate(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n)
    vector<int> even, odd;
    for(int val : vec) {
        if(val % 2 == 0) even.push_back(val);
        else odd.push_back(val);
    }

    vector<int> result(vec.size());
    int i = 0, e = 0, o = 0;
    // Fill alternately
    while(e < even.size() && o < odd.size()) {
        result[i++] = even[e++]; // Even index
        result[i++] = odd[o++];  // Odd index
    }
    // Fill remaining even numbers
    while(e < even.size()) result[i++] = even[e++];
    // Fill remaining odd numbers
    while(o < odd.size()) result[i++] = odd[o++];

    return result;
}

// Approach 2: In-place Two-Pointer
void rearrangeEvenOddInPlace(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    int evenIndex = 0; // Start at index 0
    int oddIndex = 1;  // Start at index 1

    while(evenIndex < n && oddIndex < n) {
        // Find misplaced even at odd index
        while(evenIndex < n && vec[evenIndex] % 2 == 0) evenIndex += 2;
        // Find misplaced odd at even index
        while(oddIndex < n && vec[oddIndex] % 2 == 1) oddIndex += 2;

        if(evenIndex < n && oddIndex < n) {
            swap(vec[evenIndex], vec[oddIndex]); // Correct positions
        }
    }
}

// Helper function to print vector
void printVector(vector<int>& vec) {
    for(int val : vec) cout << val << " ";
    cout << endl;
}

int main() {
    vector<int> vec1 = {3, 6, 12, 1, 5, 8};
    vector<int> vec2 = vec1; // Copy for in-place approach

    // Separate Arrays
    vector<int> res1 = rearrangeEvenOddSeparate(vec1);
    cout << "Even at Even, Odd at Odd (Separate Arrays): ";
    printVector(res1);

    // In-place Two-Pointer
    rearrangeEvenOddInPlace(vec2);
    cout << "Even at Even, Odd at Odd (In-place): ";
    printVector(vec2);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[3,6,12,1,5,8]

// Approach 1: Separate Arrays
even=[6,12,8], odd=[3,1,5]
// Fill alternately:
// i=0 -> 6 (even)
// i=1 -> 3 (odd)
// i=2 -> 12 (even)
// i=3 -> 1 (odd)
// i=4 -> 8 (even)
// i=5 -> 5 (odd)
// Output: [6,3,12,1,8,5]

// Approach 2: In-place Two-Pointer
evenIndex=0, oddIndex=1
evenIndex points to 3 (misplaced), oddIndex points to 6 (misplaced)
swap -> vec=[6,3,12,1,5,8]
evenIndex moves to 2 (12 OK), oddIndex moves to 3 (1 OK)
evenIndex moves to 4 (5 misplaced), oddIndex moves to 5 (8 misplaced)
swap -> vec=[6,3,12,1,8,5]
Output: [6,3,12,1,8,5]

```

---

## **Question: Replace every element with next greater element on the right.**

**Approach:**
Brute Force (O(n²)):

For each element, check all elements to its right to find the next greater.

Time Complexity: O(n²), Space Complexity: O(1)

Optimal Using Stack (O(n)):

Traverse the vector from right to left, use a stack to keep potential next greater elements.

Time Complexity: O(n), Space Complexity: O(n)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// Approach 1: Brute Force
vector<int> nextGreaterBruteForce(vector<int>& vec) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1) extra
    int n = vec.size();
    vector<int> res(n, -1); // Initialize result with -1

    for(int i = 0; i < n; i++) {
        for(int j = i+1; j < n; j++) {
            if(vec[j] > vec[i]) {
                res[i] = vec[j]; // Next greater found
                break;           // Stop at first greater
            }
        }
    }

    return res;
}

// Approach 2: Using Stack (Optimal)
vector<int> nextGreaterStack(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(n) for stack
    int n = vec.size();
    vector<int> res(n, -1); // Initialize result with -1
    stack<int> st;          // Stack to store elements

    // Traverse from right to left
    for(int i = n-1; i >= 0; i--) {
        // Pop smaller elements, they can't be next greater for current
        while(!st.empty() && st.top() <= vec[i]) st.pop();

        if(!st.empty()) res[i] = st.top(); // Top is next greater
        st.push(vec[i]); // Push current element for next iteration
    }

    return res;
}

// Helper function to print vector
void printVector(vector<int>& vec) {
    for(int val : vec) cout << val << " ";
    cout << endl;
}

int main() {
    vector<int> vec = {4, 5, 2, 10};

    // Brute Force
    vector<int> res1 = nextGreaterBruteForce(vec);
    cout << "Next Greater Elements (Brute Force): ";
    printVector(res1);

    // Stack Optimal
    vector<int> res2 = nextGreaterStack(vec);
    cout << "Next Greater Elements (Stack): ";
    printVector(res2);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[4,5,2,10], n=4

// Brute Force:
// i=0: vec[0]=4, next greater=5
// i=1: vec[1]=5, next greater=10
// i=2: vec[2]=2, next greater=10
// i=3: vec[3]=10, no greater element -> -1
// Output: [5,10,10,-1]

// Stack Approach:
// i=3: vec[3]=10, stack empty -> res[3]=-1, push 10 -> st=[10]
// i=2: vec[2]=2, st.top()=10>2 -> res[2]=10, push 2 -> st=[10,2]
// i=1: vec[1]=5, pop 2<=5 -> st=[10], st.top()=10>5 -> res[1]=10, push 5 -> st=[10,5]
// i=0: vec[0]=4, st.top()=5>4 -> res[0]=5, push 4 -> st=[10,5,4]
// Output: [5,10,10,-1]

```

---

## **Question: Find equilibrium index (sum of left = sum of right).**

**Approach:**
Brute Force (O(n²)):

For each index, compute left sum and right sum.

Time Complexity: O(n²), Space Complexity: O(1)

Optimal Using Prefix Sum (O(n)):

Compute total sum of vector.

Traverse and maintain left sum, right sum = total - left sum - vec[i].

If left sum == right sum → equilibrium index found.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Approach 1: Brute Force
int equilibriumIndexBruteForce(vector<int>& vec) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1)
    int n = vec.size();

    for(int i = 0; i < n; i++) {
        int leftSum = 0, rightSum = 0;

        // Sum of elements to the left
        for(int j = 0; j < i; j++) leftSum += vec[j];

        // Sum of elements to the right
        for(int j = i+1; j < n; j++) rightSum += vec[j];

        if(leftSum == rightSum) return i; // Equilibrium found
    }

    return -1; // No equilibrium index
}

// Approach 2: Optimal Using Prefix Sum
int equilibriumIndexOptimal(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    int totalSum = 0;
    for(int val : vec) totalSum += val; // Compute total sum

    int leftSum = 0;
    for(int i = 0; i < n; i++) {
        int rightSum = totalSum - leftSum - vec[i]; // Right sum = total - left - current
        if(leftSum == rightSum) return i;          // Equilibrium found
        leftSum += vec[i];                          // Update left sum for next iteration
    }

    return -1; // No equilibrium index
}

// Helper function to print index
void printIndex(int idx) {
    if(idx == -1) cout << "No equilibrium index found" << endl;
    else cout << "Equilibrium index: " << idx << endl;
}

int main() {
    vector<int> vec = {3, 4, 8, -9, 20, 6};

    // Brute Force
    int idx1 = equilibriumIndexBruteForce(vec);
    printIndex(idx1);

    // Optimal
    int idx2 = equilibriumIndexOptimal(vec);
    printIndex(idx2);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[3,4,8,-9,20,6], n=6
// totalSum = 3+4+8-9+20+6=32

// Optimal Approach:
// i=0: leftSum=0, rightSum=32-0-3=29 -> not equal
// i=1: leftSum=3, rightSum=32-3-4=25 -> not equal
// i=2: leftSum=7, rightSum=32-7-8=17 -> not equal
// i=3: leftSum=15, rightSum=32-15-(-9)=26 -> not equal
// i=4: leftSum=6 (wait let's check leftSum)
// Correction step-by-step:
// leftSum=0
// i=0: leftSum=0, rightSum=32-0-3=29 -> not equal, leftSum+=3=3
// i=1: leftSum=3, rightSum=32-3-4=25 -> not equal, leftSum+=4=7
// i=2: leftSum=7, rightSum=32-7-8=17 -> not equal, leftSum+=8=15
// i=3: leftSum=15, rightSum=32-15-(-9)=26 -> not equal, leftSum+=-9=6
// i=4: leftSum=6, rightSum=32-6-20=6 -> equal -> equilibrium index=4

// Output: 4

```

---

## **Question: Rotate array by one position without extra space.**

**Approach:**
Brute Force (Shift Right by One, O(n))

Store last element in temp.

Shift all elements one position to the right.

Place temp at index 0.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Approach 1: Shift Right by One
void rotateByOne(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    if(n <= 1) return; // No rotation needed

    int last = vec[n-1]; // Store last element

    // Shift all elements to the right by one
    for(int i = n-1; i > 0; i--) {
        vec[i] = vec[i-1];
    }

    vec[0] = last; // Place last element at first position
}

// Approach 2: Using Reverse Method
void rotateByOneReverse(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int n = vec.size();
    if(n <= 1) return;

    // Step 1: Reverse entire vector
    reverse(vec.begin(), vec.end()); // Now last element is at index 0

    // Step 2: Reverse first element (single element, no change)
    // Step 3: Reverse remaining n-1 elements
    reverse(vec.begin() + 1, vec.end());
}

// Helper function to print vector
void printVector(vector<int>& vec) {
    for(int val : vec) cout << val << " ";
    cout << endl;
}

int main() {
    vector<int> vec1 = {1, 2, 3, 4, 5};
    vector<int> vec2 = vec1; // Copy for reverse approach

    // Shift Right by One
    rotateByOne(vec1);
    cout << "After rotating by one (Shift): ";
    printVector(vec1);

    // Reverse Approach
    rotateByOneReverse(vec2);
    cout << "After rotating by one (Reverse): ";
    printVector(vec2);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[1,2,3,4,5]

// Approach 1: Shift Right by One
last=5
i=4 -> vec[4]=vec[3]=4
i=3 -> vec[3]=vec[2]=3
i=2 -> vec[2]=vec[1]=2
i=1 -> vec[1]=vec[0]=1
vec[0]=5
Output: [5,1,2,3,4]

// Approach 2: Reverse Method
Step1: Reverse entire vec -> [5,4,3,2,1]
Step2: Reverse first element -> [5,4,3,2,1] (no change)
Step3: Reverse remaining 4 elements -> [5,1,2,3,4]
Output: [5,1,2,3,4]

```

---

## **Question: Maximum circular subarray sum.**

**Approach:**
Problem Statement:

Given a vector, find the maximum sum of a subarray in a circular array (wrap-around allowed).

Example:

Input: [8, -1, 3, 4]

Output: 15 → Entire array sum (8 + -1 + 3 + 4 = 14?) Wait, carefully: sum=14, check calculation. Yes. Correct sum = 14.

Input: [5, -2, 3, 4] → Output: 12 (sum of subarray [3,4,5] circular)

Approach:

Brute Force (O(n²)):

Consider all subarrays including wrap-around using modulo indexing.

Time Complexity: O(n²), Space Complexity: O(1)

Optimal Using Kadane’s Algorithm (O(n)):

Case 1: Non-circular max sum → normal Kadane’s algorithm.

Case 2: Circular max sum → total sum - min subarray sum (exclude minimum subarray).

Maximum of the two cases is the answer.

Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

// Helper: Standard Kadane's Algorithm (Maximum subarray sum)
int kadaneMax(vector<int>& vec) {
    int maxEndingHere = vec[0];
    int maxSoFar = vec[0];
    for(int i = 1; i < vec.size(); i++) {
        maxEndingHere = max(vec[i], maxEndingHere + vec[i]);
        maxSoFar = max(maxSoFar, maxEndingHere);
    }
    return maxSoFar;
}

// Helper: Kadane for Minimum subarray sum
int kadaneMin(vector<int>& vec) {
    int minEndingHere = vec[0];
    int minSoFar = vec[0];
    for(int i = 1; i < vec.size(); i++) {
        minEndingHere = min(vec[i], minEndingHere + vec[i]);
        minSoFar = min(minSoFar, minEndingHere);
    }
    return minSoFar;
}

// Approach: Optimal using Kadane's Algorithm
int maxCircularSubarraySum(vector<int>& vec) {
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    int maxKadane = kadaneMax(vec); // Case 1: non-circular max sum

    int totalSum = 0;
    for(int val : vec) totalSum += val;

    int minKadane = kadaneMin(vec); // Minimum subarray sum
    int maxCircular = totalSum - minKadane; // Case 2: circular sum

    // Edge case: all numbers negative, totalSum - minKadane = 0 -> use maxKadane
    if(maxCircular == 0) return maxKadane;

    return max(maxKadane, maxCircular);
}

// Brute Force Approach (O(n^2))
int maxCircularSubarraySumBruteForce(vector<int>& vec) {
    // Time Complexity: O(n^2)
    // Space Complexity: O(1)
    int n = vec.size();
    int maxSum = INT_MIN;

    for(int i = 0; i < n; i++) {
        int currSum = 0;
        for(int j = 0; j < n; j++) {
            int idx = (i + j) % n; // Circular index
            currSum += vec[idx];
            maxSum = max(maxSum, currSum);
        }
    }
    return maxSum;
}

int main() {
    vector<int> vec = {5, -2, 3, 4};

    cout << "Maximum Circular Subarray Sum (Brute Force): " << maxCircularSubarraySumBruteForce(vec) << endl;
    cout << "Maximum Circular Subarray Sum (Optimal Kadane): " << maxCircularSubarraySum(vec) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Input: vec=[5,-2,3,4], n=4

// Optimal Approach:
// Non-circular max (Kadane):
// maxEndingHere=5 -> maxSoFar=5
// i=1: -2 -> maxEndingHere=max(-2,5-2)=3 -> maxSoFar=5
// i=2: 3 -> maxEndingHere=max(3,3+3)=6 -> maxSoFar=6
// i=3: 4 -> maxEndingHere=max(4,6+4)=10 -> maxSoFar=10

// Circular max:
// totalSum=5-2+3+4=10
// minKadane (min subarray sum):
// minEndingHere=5, minSoFar=5
// i=1: -2 -> minEndingHere=min(-2,5-2)=-2 -> minSoFar=-2
// i=2: 3 -> minEndingHere=min(3,-2+3)=1 -> minSoFar=-2
// i=3: 4 -> minEndingHere=min(4,1+4)=5 -> minSoFar=-2
// maxCircular=totalSum - minKadane=10-(-2)=12
// Max of 10,12 = 12

// Output: 12

```

---
