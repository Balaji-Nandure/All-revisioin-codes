## **Question: 1 Factorial of a number Multiply n \* factorial(n-1)**

**Approach:**
-- Question: Factorial of a Number
-- Approach:
-- 1. Factorial of n is defined as n \* factorial(n-1)
-- 2. Base case: factorial(0) = 1
-- 3. Factorial is not defined for negative numbers
-- 4. Recursively multiply n by factorial(n-1) until base case
-- 5. Return the result

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to calculate factorial
int factorial(int n) {
    if (n == 0 || n == 1) // Base case: 0! = 1! = 1
        return 1;
    return n * factorial(n - 1); // Recursive call
}

int main() {
    int n;
    cin >> n; // Read input number

    if (n < 0) { // Factorial undefined for negative numbers
        cout << "Factorial not defined for negative numbers." << endl;
        return 0;
    }

    int result = factorial(n); // Call recursive function
    cout << result << endl;    // Print the result

    return 0; // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input: n = 4

factorial(4)
= 4 * factorial(3)
= 4 * (3 * factorial(2))
= 4 * (3 * (2 * factorial(1)))
= 4 * 3 * 2 * 1
= 24

Output: 24

```

---

## **Question: 2 Fibonacci number (nth) fib(n-1) + fib(n-2)**

**Approach:**
-- Question: Fibonacci Number (nth)
-- Approach:
-- 1. Fibonacci sequence: F(n) = F(n-1) + F(n-2)
-- 2. Base cases: F(0) = 0, F(1) = 1
-- 3. Use recursion to calculate F(n-1) and F(n-2)
-- 4. Sum the results to get F(n)
-- 5. Return the result

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to find nth Fibonacci number
int fibonacci(int n) {
    if (n == 0) return 0;     // Base case F(0) = 0
    if (n == 1) return 1;     // Base case F(1) = 1
    return fibonacci(n - 1) + fibonacci(n - 2); // Recursion: sum of previous two
}

int main() {
    int n;
    cin >> n;                  // Read input number
    if (n < 0) {               // Fibonacci undefined for negative numbers
        cout << "Invalid input" << endl;
        return 0;
    }
    int result = fibonacci(n); // Call recursive function
    cout << result << endl;    // Print the result
    return 0;                  // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input: n = 5

fibonacci(5)
= fibonacci(4) + fibonacci(3)
= (fibonacci(3) + fibonacci(2)) + (fibonacci(2) + fibonacci(1))
= ((fibonacci(2)+fibonacci(1)) + (fibonacci(1)+fibonacci(0))) + ((fibonacci(1)+fibonacci(0)) + 1)
= ((1+1) + (1+0)) + ((1+0) + 1)
= (2+1) + (1+1)
= 3 + 2
= 5

Output: 5

```

---

## **Question: 3 Sum of first N natural numbers sum(n-1) + n**

**Approach:**
-- Question: Sum of First N Natural Numbers
-- Approach:
-- 1. Sum of first N numbers: sum(n) = n + sum(n-1)
-- 2. Base case: sum(0) = 0
-- 3. Use recursion to calculate sum(n-1)
-- 4. Add n to the result of sum(n-1)
-- 5. Return the result

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to calculate sum of first N natural numbers
int sumN(int n) {
    if (n == 0) return 0;        // Base case: sum of 0 numbers is 0
    return n + sumN(n - 1);      // Recursive call: n + sum of first n-1 numbers
}

int main() {
    int n;
    cin >> n;                     // Read input number
    if (n < 0) {                  // Sum not defined for negative numbers
        cout << "Invalid input" << endl;
        return 0;
    }
    int result = sumN(n);         // Call recursive function
    cout << result << endl;       // Print the result
    return 0;                     // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input: n = 5

sumN(5)
= 5 + sumN(4)
= 5 + (4 + sumN(3))
= 5 + (4 + (3 + sumN(2)))
= 5 + (4 + (3 + (2 + sumN(1))))
= 5 + (4 + (3 + (2 + (1 + sumN(0)))))
= 5 + 4 + 3 + 2 + 1 + 0
= 15

Output: 15

```

---

## **Question: 4 Power of a number (x^n) x \* power(x, n-1)**

**Approach:**
-- Question: Power of a Number (x^n)
-- Approach:
-- 1. Power of a number: x^n = x \* x^(n-1)
-- 2. Base case: x^0 = 1
-- 3. Use recursion to calculate x^(n-1)
-- 4. Multiply x with result of x^(n-1)
-- 5. Return the result
-- 6. Handle negative powers (optional: can return 1/(x^-n))

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to calculate x^n
int power(int x, int n) {
    if (n == 0) return 1;          // Base case: x^0 = 1
    return x * power(x, n - 1);    // Recursive call: multiply x with power(x, n-1)
}

int main() {
    int x, n;
    cin >> x >> n;                  // Read base and exponent

    if (n < 0) {                    // Negative exponent not handled in integer version
        cout << "Negative exponent not supported" << endl;
        return 0;
    }

    int result = power(x, n);       // Call recursive function
    cout << result << endl;         // Print result

    return 0;                       // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Input: x = 2, n = 4

power(2,4)
= 2 * power(2,3)
= 2 * (2 * power(2,2))
= 2 * (2 * (2 * power(2,1)))
= 2 * (2 * (2 * (2 * power(2,0))))
= 2 * 2 * 2 * 2 * 1
= 16

Output: 16

```

---

## **Question: 4 Power of a number**

**Approach:**
-- Question: Power of a Number (x^n) - Optimal
-- Approach:
-- 1. If n is 0, return 1 (base case)
-- 2. Recursively calculate half = power(x, n/2)
-- 3. If n is even: x^n = half _ half
-- 4. If n is odd: x^n = x _ half \* half
-- 5. This reduces recursion depth to O(log n)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to calculate x^n optimally
long long power(long long x, int n) {
    if (n == 0) return 1;             // Base case: x^0 = 1

    long long half = power(x, n / 2); // Compute x^(n/2) recursively

    if (n % 2 == 0)                    // If n is even
        return half * half;            // Multiply halves
    else                               // If n is odd
        return x * half * half;        // Multiply by x as well
}

int main() {
    long long x;
    int n;
    cin >> x >> n;                      // Read base and exponent

    if (n < 0) {                        // Negative exponent not handled here
        cout << "Negative exponent not supported" << endl;
        return 0;
    }

    long long result = power(x, n);     // Call optimal recursive function
    cout << result << endl;             // Print result
    return 0;                           // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
power(2,5)
n is odd, compute half = power(2,2)
    power(2,2)
    n is even, compute half = power(2,1)
        power(2,1)
        n is odd, compute half = power(2,0)
            power(2,0) = 1 (base case)
        power(2,1) = 2 * 1 * 1 = 2
    power(2,2) = 2 * 2 = 4
power(2,5) = 2 * 4 * 4 = 32

Output: 32

```

---

## **Question: 5 Check if a number is prime Recursively test divisibility**

**Approach:**
-- Question: Check if a Number is Prime
-- Approach:
-- 1. A number n > 1 is prime if it is not divisible by any number from 2 to sqrt(n)
-- 2. Use recursion to check divisibility from 2 up to sqrt(n)
-- 3. Base case: if divisor\*divisor > n, return true (no divisor found)
-- 4. If n divisible by current divisor, return false
-- 5. Otherwise, recurse with next divisor

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to check primality
bool isPrimeHelper(int n, int divisor) {
    if (n <= 1) return false;          // 0 and 1 are not prime
    if (divisor * divisor > n) return true; // No divisor found, prime
    if (n % divisor == 0) return false; // Divisible, not prime
    return isPrimeHelper(n, divisor + 1); // Recurse with next divisor
}

// Wrapper function
bool isPrime(int n) {
    return isPrimeHelper(n, 2);        // Start checking from divisor = 2
}

int main() {
    int n;
    cin >> n;                           // Read input number
    bool result = isPrime(n);           // Call recursive function
    if (result) cout << "Prime" << endl;
    else cout << "Not Prime" << endl;
    return 0;                           // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
isPrimeHelper(17,2)
2*2 <= 17, 17 % 2 != 0, recurse with divisor=3
3*3 <= 17, 17 % 3 != 0, recurse with divisor=4
4*4 > 17, base case reached, return true
Output: Prime

```

---

## **Question: 6 Greatest Common Divisor (GCD) Euclid's recursion: gcd(a, b) = gcd(b, a%b)**

**Approach:**
-- Question: Greatest Common Divisor (GCD)
-- Approach:
-- 1. GCD of two numbers a and b is defined as gcd(a, b) = gcd(b, a % b)
-- 2. Base case: if b == 0, return a
-- 3. Otherwise, recursively call gcd(b, a % b)
-- 4. This reduces the problem size efficiently
-- 5. Time complexity is O(log min(a,b))

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to find GCD using Euclid's algorithm
int gcd(int a, int b) {
    if (b == 0) return a;         // Base case: gcd(a,0) = a
    return gcd(b, a % b);         // Recursive call: gcd(b, a%b)
}

int main() {
    int a, b;
    cin >> a >> b;                // Read two numbers
    int result = gcd(a, b);       // Call recursive GCD function
    cout << result << endl;       // Print the GCD
    return 0;                     // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
gcd(48,18)
= gcd(18, 48%18) = gcd(18,12)
= gcd(12, 18%12) = gcd(12,6)
= gcd(6, 12%6) = gcd(6,0)
Base case reached, return 6

Output: 6

```

---

## **Question: 7 Reverse digits of a number last_digit + recursive call on remaining digits**

**Approach:**
-- Question: Reverse Digits of a Number
-- Approach:
-- 1. Extract the last digit of the number using n % 10
-- 2. Remove last digit using n / 10 and recurse on remaining number
-- 3. Multiply last digit by appropriate power of 10 according to number of digits left
-- 4. Base case: if n < 10, return n
-- 5. Combine results to get reversed number

**Code:**

```cpp
#include <iostream>
#include <cmath>
using namespace std;

// Helper function to count digits
int countDigits(int n) {
    if (n == 0) return 0;              // Base case: 0 has 0 digits
    return 1 + countDigits(n / 10);    // Count 1 + digits of remaining number
}

// Recursive function to reverse digits
int reverseDigits(int n) {
    if (n < 10) return n;              // Base case: single digit
    int digits = countDigits(n);       // Count digits in current number
    int lastDigit = n % 10;            // Extract last digit
    int remaining = n / 10;            // Remaining number
    return lastDigit * pow(10, digits - 1) + reverseDigits(remaining); // Recurse
}

int main() {
    int n;
    cin >> n;                          // Read input number
    if (n < 0) {                       // Handle negative numbers
        cout << "Negative numbers not supported" << endl;
        return 0;
    }
    int result = reverseDigits(n);     // Call recursive function
    cout << result << endl;            // Print reversed number
    return 0;                          // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
reverseDigits(1234)
lastDigit = 4, remaining = 123, digits = 4
4 * 10^(4-1) + reverseDigits(123)
= 4*1000 + reverseDigits(123)
= 4000 + (3*100 + reverseDigits(12))
= 4000 + (300 + (2*10 + reverseDigits(1)))
= 4000 + 300 + 20 + 1
= 4321

Output: 4321

```

---

## **Question: 8 Count digits in a number 1 + count(n/10)**

---

## **Question: 9 Find maximum element in an array Compare arr[n-1] with max(arr[0..n-2])**

**Approach:**
-- Question: Find Maximum Element in an Array
-- Approach:
-- 1. Compare last element arr[n-1] with maximum of remaining array arr[0..n-2]
-- 2. Base case: if array has only one element, return that element
-- 3. Recurse on subarray of size n-1
-- 4. Return the larger of arr[n-1] and max of subarray
-- 5. This reduces problem size in each recursive call

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to find maximum element in array
int findMax(const vector<int> &arr, int n) {
    if (n == 1) return arr[0];                // Base case: only one element
    int maxSub = findMax(arr, n - 1);         // Recursive call on first n-1 elements
    return max(arr[n - 1], maxSub);           // Compare last element with max of subarray
}

int main() {
    int n;
    cin >> n;                                 // Read array size
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    int result = findMax(arr, n);             // Call recursive function
    cout << result << endl;                   // Print maximum element
    return 0;                                 // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
findMax([3,1,7,2],4)
maxSub = findMax([3,1,7,2],3)
    maxSub = findMax([3,1,7,2],2)
        maxSub = findMax([3,1,7,2],1) = 3
        Compare arr[1]=1 with maxSub=3 => max=3
    Compare arr[2]=7 with maxSub=3 => max=7
Compare arr[3]=2 with maxSub=7 => max=7

Output: 7

```

---

## **Question: 10 Find minimum element in an array Compare arr[n-1] with min(arr[0..n-2])**

**Approach:**
-- Question: Find Minimum Element in an Array
-- Approach:
-- 1. Compare last element arr[n-1] with minimum of remaining array arr[0..n-2]
-- 2. Base case: if array has only one element, return that element
-- 3. Recurse on subarray of size n-1
-- 4. Return the smaller of arr[n-1] and min of subarray
-- 5. This reduces problem size in each recursive call

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to find minimum element in array
int findMin(const vector<int> &arr, int n) {
    if (n == 1) return arr[0];                // Base case: only one element
    int minSub = findMin(arr, n - 1);         // Recursive call on first n-1 elements
    return min(arr[n - 1], minSub);           // Compare last element with min of subarray
}

int main() {
    int n;
    cin >> n;                                 // Read array size
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    int result = findMin(arr, n);             // Call recursive function
    cout << result << endl;                   // Print minimum element
    return 0;                                 // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
findMin([3,1,7,2],4)
minSub = findMin([3,1,7,2],3)
    minSub = findMin([3,1,7,2],2)
        minSub = findMin([3,1,7,2],1) = 3
        Compare arr[1]=1 with minSub=3 => min=1
    Compare arr[2]=7 with minSub=1 => min=1
Compare arr[3]=2 with minSub=1 => min=1

Output: 1

```

---

## **Question: 11 Sum of array elements arr[n-1] + sum(arr[0..n-2])**

**Approach:**
-- Question: Sum of Array Elements
-- Approach:
-- 1. Sum of array = last element arr[n-1] + sum of remaining array arr[0..n-2]
-- 2. Base case: if array has only one element, return that element
-- 3. Recurse on subarray of size n-1
-- 4. Return arr[n-1] + sum of subarray

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to find sum of array elements
int sumArray(const vector<int> &arr, int n) {
    if (n == 1) return arr[0];               // Base case: only one element
    return arr[n - 1] + sumArray(arr, n - 1); // Add last element to sum of subarray
}

int main() {
    int n;
    cin >> n;                                // Read array size
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    int result = sumArray(arr, n);           // Call recursive function
    cout << result << endl;                  // Print sum
    return 0;                                // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
sumArray([3,1,7,2],4)
= arr[3] + sumArray([3,1,7,2],3) = 2 + sumArray([3,1,7],3)
= 2 + (arr[2] + sumArray([3,1],2)) = 2 + (7 + sumArray([3,1],2))
= 2 + 7 + (arr[1] + sumArray([3],1)) = 2 + 7 + (1 + 3)
= 2 + 7 + 1 + 3 = 13

Output: 13

```

---

## **Question: 12 Check if array is sorted Compare arr[n-1] >= arr[n-2] and recursive check on arr[0..n-2]**

**Approach:**
-- Question: Check if Array is Sorted
-- Approach:
-- 1. Compare last two elements: arr[n-2] <= arr[n-1]
-- 2. Base case: if array has only one element, it is sorted
-- 3. Recurse on subarray of size n-1
-- 4. If any comparison fails, return false; else return true

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to check if array is sorted
bool isSorted(const vector<int> &arr, int n) {
    if (n == 1) return true;                  // Base case: single element is sorted
    if (arr[n - 2] > arr[n - 1]) return false; // If previous element > current, not sorted
    return isSorted(arr, n - 1);             // Recurse on first n-1 elements
}

int main() {
    int n;
    cin >> n;                                // Read array size
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    bool result = isSorted(arr, n);          // Call recursive function
    if (result) cout << "Sorted" << endl;
    else cout << "Not Sorted" << endl;
    return 0;                                // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
isSorted([1,2,3,4],4)
arr[2]=3 <= arr[3]=4 => recurse on n=3
arr[1]=2 <= arr[2]=3 => recurse on n=2
arr[0]=1 <= arr[1]=2 => recurse on n=1
Base case reached => return true

Output: Sorted

```

---

## **Question: 13 Count occurrences of an element (arr[n-1]==x ?1:0) + count(arr[0..n-2], x)**

**Approach:**
-- Question: Count Occurrences of an Element in an Array
-- Approach:
-- 1. Compare last element arr[n-1] with target x
-- 2. Base case: if array has only one element, return 1 if it equals x, else 0
-- 3. Recurse on subarray of size n-1
-- 4. Add 1 if arr[n-1] == x, else add 0
-- 5. Return total count

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to count occurrences of x in array
int countOccurrences(const vector<int> &arr, int n, int x) {
    if (n == 0) return 0;                     // Base case: empty array, 0 occurrences
    int countSub = countOccurrences(arr, n - 1, x); // Recursive call on first n-1 elements
    return countSub + (arr[n - 1] == x ? 1 : 0);    // Add 1 if last element equals x
}

int main() {
    int n, x;
    cin >> n >> x;                            // Read array size and target element
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    int result = countOccurrences(arr, n, x); // Call recursive function
    cout << result << endl;                   // Print count
    return 0;                                 // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
countOccurrences([1,2,3,2,4],5,2)
countSub = countOccurrences([1,2,3,2,4],4,2)
    countSub = countOccurrences([1,2,3,2],4) = 2 (2 occurs twice)
arr[4]=4 != 2 => add 0
Total count = 2

Output: 2

```

---

## **Question: 14 First occurrence of an element Check arr[0]==x, else recurse on arr[1..n-1]**

**Approach:**
-- Question: First Occurrence of an Element in an Array
-- Approach:
-- 1. Check if the first element arr[0] equals target x
-- 2. Base case: if array is empty, return -1 (not found)
-- 3. If arr[0] == x, return index 0
-- 4. Otherwise, recursively search in the rest of the array arr[1..n-1]
-- 5. If found in subarray, add 1 to index to get correct position

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to find first occurrence of x
int firstOccurrence(const vector<int> &arr, int n, int x) {
    if (n == 0) return -1;                    // Base case: empty array
    if (arr[0] == x) return 0;                // Found at first element
    int subIndex = firstOccurrence(vector<int>(arr.begin()+1, arr.end()), n-1, x); // Recurse on subarray
    if (subIndex == -1) return -1;            // Not found in subarray
    return subIndex + 1;                      // Adjust index relative to original array
}

int main() {
    int n, x;
    cin >> n >> x;                            // Read array size and target
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    int result = firstOccurrence(arr, n, x); // Call recursive function
    cout << result << endl;                   // Print index (-1 if not found)
    return 0;                                 // End program
}
// End of code
// Optimized Version (Pass start index to avoid copying):
int firstOccurrenceOptimized(const vector<int> &arr, int n, int x, int start=0) {
    if (start == n) return -1;                 // Base case: end of array
    if (arr[start] == x) return start;         // Found
    return firstOccurrenceOptimized(arr, n, x, start+1); // Recurse on next index
}


// End of code
```

**Dry Run:**

```cpp
firstOccurrence([4,2,5,2,7],5,2)
arr[0]=4 != 2 -> recurse on [2,5,2,7]
arr[0]=2 == 2 -> return 0
Adjust index: 0 + 1 = 1

Output: 1

```

---

## **Question: 15 Last occurrence of an element Recurse on arr[1..n-1], if found return index, else check arr[0]**

**Approach:**
-- Question: Last Occurrence of an Element in an Array
-- Approach:
-- 1. Recurse on the rest of the array arr[1..n-1] to find x
-- 2. Base case: if array is empty, return -1 (not found)
-- 3. If found in subarray, adjust index by adding 1
-- 4. If not found in subarray, check arr[0]; if arr[0]==x return 0
-- 5. This ensures we get the last occurrence

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to find last occurrence of x
int lastOccurrence(const vector<int> &arr, int n) {
    if (n == 0) return -1;                     // Base case: empty array
    int subIndex = lastOccurrence(vector<int>(arr.begin()+1, arr.end()), n-1); // Recurse on subarray
    if (subIndex != -1) return subIndex + 1;  // Found in subarray, adjust index
    return (arr[0] == arr[n-1] ? n-1 : -1);   // Check first element (or last element) if subarray returned -1
}

int main() {
    int n, x;
    cin >> n >> x;                             // Read array size and target
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    // Optimized version passes target x
    function<int(const vector<int>&, int, int, int)> lastOcc = [&](const vector<int> &arr, int n, int x, int start=0) -> int {
        if (start == n) return -1;             // Base case
        int subIndex = lastOcc(arr, n, x, start+1); // Recurse on next index
        if (subIndex != -1) return subIndex;   // Found in subarray
        return (arr[start] == x ? start : -1); // Else check current element
    };

    int result = lastOcc(arr, n, x);          // Call recursive function
    cout << result << endl;                    // Print index (-1 if not found)
    return 0;                                 // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
lastOccurrence([4,2,5,2,7],5,2)
Recurse on [2,5,2,7]
Recurse on [5,2,7]
Recurse on [2,7]
Recurse on [7]
Recurse on [] -> return -1
Check arr[3]=7? No
Check arr[2]=2? Yes -> return 3
Backtrack and return 3 as final index

Output: 3

```

---

## **Question: 16 Reverse an array Swap first and last, recurse on middle subarray**

**Approach:**
-- Question: Reverse an Array
-- Approach:
-- 1. Swap first and last elements of the current subarray
-- 2. Base case: if start index >= end index, stop recursion
-- 3. Recurse on the subarray from start+1 to end-1
-- 4. This way, array is reversed in-place

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to reverse an array in-place
void reverseArray(vector<int> &arr, int start, int end) {
    if (start >= end) return;                 // Base case: crossed indices
    swap(arr[start], arr[end]);               // Swap first and last elements
    reverseArray(arr, start + 1, end - 1);    // Recurse on the middle subarray
}

int main() {
    int n;
    cin >> n;                                 // Read array size
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    reverseArray(arr, 0, n - 1);              // Call recursive function
    for (int i = 0; i < n; i++) cout << arr[i] << " "; // Print reversed array
    cout << endl;
    return 0;                                 // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
reverseArray([1,2,3,4,5], start=0, end=4)
swap arr[0] & arr[4] => [5,2,3,4,1]
recurse start=1, end=3
swap arr[1] & arr[3] => [5,4,3,2,1]
recurse start=2, end=2
Base case reached => stop

Output: [5,4,3,2,1]

```

---

## **Question: 17 Check if array is palindrome Compare first and last, recurse on middle subarray**

**Approach:**
-- Question: Check if Array is Palindrome
-- Approach:
-- 1. Compare first and last elements of the current subarray
-- 2. Base case: if start >= end, array is palindrome
-- 3. If arr[start] != arr[end], return false
-- 4. Otherwise, recurse on subarray from start+1 to end-1
-- 5. Return true if all pairs match

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to check if array is palindrome
bool isPalindrome(const vector<int> &arr, int start, int end) {
    if (start >= end) return true;            // Base case: crossed indices or single element
    if (arr[start] != arr[end]) return false; // Mismatch found
    return isPalindrome(arr, start + 1, end - 1); // Recurse on middle subarray
}

int main() {
    int n;
    cin >> n;                                 // Read array size
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    bool result = isPalindrome(arr, 0, n - 1); // Call recursive function
    if (result) cout << "Palindrome" << endl;
    else cout << "Not Palindrome" << endl;
    return 0;                                 // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
isPalindrome([1,2,3,2,1], start=0, end=4)
arr[0]=1 == arr[4]=1 -> recurse start=1, end=3
arr[1]=2 == arr[3]=2 -> recurse start=2, end=2
Base case reached -> return true

Output: Palindrome

```

---

## **Question: 18 Product of all array elements arr[n-1] \* product(arr[0..n-2])**

**Approach:**
-- Question: Product of All Array Elements
-- Approach:
-- 1. Base case: if array size is 0, return 1 (multiplicative identity)
-- 2. Multiply last element arr[n-1] with product of first n-1 elements
-- 3. Recurse on subarray arr[0..n-2]
-- 4. Return the final product

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to calculate product of array elements
long long productArray(const vector<int> &arr, int n) {
    if (n == 0) return 1;                      // Base case: empty array
    return arr[n - 1] * productArray(arr, n - 1); // Multiply last element with product of rest
}

int main() {
    int n;
    cin >> n;                                  // Read array size
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    long long result = productArray(arr, n);   // Call recursive function
    cout << result << endl;                    // Print product
    return 0;                                  // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
productArray([1,2,3,4],4)
= arr[3]*productArray([1,2,3],3) = 4 * productArray([1,2,3],3)
= 4 * (3 * productArray([1,2],2))
= 4 * 3 * (2 * productArray([1],1))
= 4 * 3 * 2 * (1 * productArray([],0))
= 4 * 3 * 2 * 1 * 1
= 24

Output: 24

```

---

## **Question: 19 Find index of maximum element Compare indices recursively**

**Approach:**
-- Question: Find Index of Maximum Element in an Array
-- Approach:
-- 1. Base case: if array size is 1, return index 0
-- 2. Recurse on subarray arr[1..n-1] to find index of max element in that subarray
-- 3. Compare arr[0] with arr[subIndex+1..n-1], return index of larger element
-- 4. Adjust index relative to original array if max is in subarray

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to find index of maximum element
int maxIndex(const vector<int> &arr, int n, int start=0) {
    if (start == n - 1) return start;           // Base case: last element
    int subIndex = maxIndex(arr, n, start + 1); // Recurse on rest of array
    if (arr[start] >= arr[subIndex]) return start; // Compare first element with max in subarray
    return subIndex;                             // Else return index from subarray
}

int main() {
    int n;
    cin >> n;                                   // Read array size
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];  // Read array elements

    int result = maxIndex(arr, n);              // Call recursive function
    cout << result << endl;                     // Print index of maximum element
    return 0;                                   // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
maxIndex([3,7,2,9,5], n=5, start=0)
subIndex = maxIndex([3,7,2,9,5], start=1)
...
subIndex = maxIndex([3,7,2,9,5], start=3) -> base case, return 3
Compare arr[2]=2 with arr[3]=9 -> return 3
Compare arr[1]=7 with arr[3]=9 -> return 3
Compare arr[0]=3 with arr[3]=9 -> return 3

Output: 3

```

---

## **Question: 20 Count even/odd elements (arr[n-1]%2==0?1:0) + recurse on arr[0..n-2]**

**Approach:**
-- Question: Count Even/Odd Elements in an Array
-- Approach:
-- 1. Base case: if array size is 0, return 0
-- 2. Check last element arr[n-1]; if even, add 1, else 0
-- 3. Recurse on subarray arr[0..n-2] and add result
-- 4. Returns count of even elements (for odd, change condition)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to count even elements
int countEven(const vector<int> &arr, int n) {
    if (n == 0) return 0;                      // Base case: empty array
    int count = (arr[n - 1] % 2 == 0) ? 1 : 0; // Check if last element is even
    return count + countEven(arr, n - 1);       // Recurse on rest of array
}

// Recursive function to count odd elements
int countOdd(const vector<int> &arr, int n) {
    if (n == 0) return 0;                      // Base case
    int count = (arr[n - 1] % 2 != 0) ? 1 : 0; // Check if last element is odd
    return count + countOdd(arr, n - 1);        // Recurse on rest of array
}

int main() {
    int n;
    cin >> n;                                  // Read array size
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i]; // Read array elements

    cout << "Even count: " << countEven(arr, n) << endl;
    cout << "Odd count: " << countOdd(arr, n) << endl;
    return 0;                                  // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
countEven([1,2,3,4,5],5)
last element 5 -> odd -> count=0
recurse on [1,2,3,4] -> last element 4 -> even -> count=1
recurse on [1,2,3] -> last element 3 -> odd -> count=0
recurse on [1,2] -> last element 2 -> even -> count=1
recurse on [1] -> last element 1 -> odd -> count=0
recurse on [] -> 0

Total even count = 2
Total odd count = 3

```

---

## **Question: 21 Check if string is palindrome Compare first and last, recurse on substring**

**Approach:**
-- Question: Check if String is Palindrome
-- Approach:
-- 1. Base case: if string has 0 or 1 character, it's a palindrome
-- 2. Compare first and last characters
-- 3. If they differ, return false
-- 4. Else, recurse on substring excluding first and last characters
-- 5. Return true if all pairs match

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Recursive function to check if string is palindrome
bool isPalindrome(const string &s, int start, int end) {
    if (start >= end) return true;            // Base case: single char or crossed indices
    if (s[start] != s[end]) return false;     // Mismatch found
    return isPalindrome(s, start + 1, end - 1); // Recurse on middle substring
}

int main() {
    string s;
    cin >> s;                                 // Read input string
    bool result = isPalindrome(s, 0, s.length() - 1); // Call recursive function
    if (result) cout << "Palindrome" << endl;
    else cout << "Not Palindrome" << endl;
    return 0;                                 // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
isPalindrome("level", start=0, end=4)
s[0]='l' == s[4]='l' -> recurse start=1, end=3
s[1]='e' == s[3]='e' -> recurse start=2, end=2
Base case reached -> return true

Output: Palindrome

```

---

## **Question: 22 Reverse a string recursively Swap first and last, recurse on substring**

**Approach:**
-- Question: Reverse a String Recursively
-- Approach:
-- 1. Base case: if start >= end, stop recursion
-- 2. Swap characters at start and end
-- 3. Recurse on substring from start+1 to end-1
-- 4. This reverses string in-place without extra memory

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Recursive function to reverse string in-place
void reverseString(string &s, int start, int end) {
    if (start >= end) return;                 // Base case: single char or crossed indices
    swap(s[start], s[end]);                   // Swap first and last characters
    reverseString(s, start + 1, end - 1);     // Recurse on middle substring
}

int main() {
    string s;
    cin >> s;                                 // Read input string
    reverseString(s, 0, s.length() - 1);     // Call recursive function
    cout << s << endl;                        // Print reversed string
    return 0;                                 // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
reverseString("hello", start=0, end=4)
swap 'h' and 'o' -> "oellh"
recurse start=1, end=3
swap 'e' and 'l' -> "olleh"
recurse start=2, end=2
Base case reached -> stop

Output: "olleh"

```

---

## **Question: 23 Count vowels in string (isVowel(s[0])?1:0) + recurse on s[1..n-1]**

**Approach:**
-- Question: Count Vowels in a String
-- Approach:
-- 1. Base case: if string is empty, return 0
-- 2. Check first character; if vowel, add 1
-- 3. Recurse on substring excluding first character
-- 4. Sum counts from all recursive calls

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Helper function to check if character is a vowel
bool isVowel(char c) {
    c = tolower(c);                          // Convert to lowercase
    return (c=='a' || c=='e' || c=='i' || c=='o' || c=='u');
}

// Recursive function to count vowels
int countVowels(const string &s, int index = 0) {
    if (index >= s.length()) return 0;       // Base case: end of string
    int count = isVowel(s[index]) ? 1 : 0;  // Count current character if vowel
    return count + countVowels(s, index + 1); // Recurse on next character
}

int main() {
    string s;
    getline(cin, s);                         // Read input string (can include spaces)
    int result = countVowels(s);             // Call recursive function
    cout << result << endl;                  // Print number of vowels
    return 0;                                // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
countVowels("Hello World", index=0)
'H' -> not vowel -> 0
'e' -> vowel -> 1
'l' -> not vowel -> 0
'l' -> not vowel -> 0
'o' -> vowel -> 1
...
Total vowels = 3

Output: 3

```

---

## **Question: 24 Count consonants in string (isConsonant(s[0])?1:0) + recurse on s[1..n-1]**

**Approach:**
-- Question: Count Consonants in a String
-- Approach:
-- 1. Base case: if string is empty, return 0
-- 2. Check first character; if it is an alphabet and not a vowel, it's a consonant
-- 3. Add 1 if consonant, else 0
-- 4. Recurse on substring excluding first character
-- 5. Sum counts from all recursive calls

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Helper function to check if character is a consonant
bool isConsonant(char c) {
    c = tolower(c);                          // Convert to lowercase
    return (c >= 'a' && c <= 'z') && !(c=='a'||c=='e'||c=='i'||c=='o'||c=='u');
}

// Recursive function to count consonants
int countConsonants(const string &s, int index = 0) {
    if (index >= s.length()) return 0;       // Base case: end of string
    int count = isConsonant(s[index]) ? 1 : 0; // Count if consonant
    return count + countConsonants(s, index + 1); // Recurse on next character
}

int main() {
    string s;
    getline(cin, s);                         // Read input string (can include spaces)
    int result = countConsonants(s);         // Call recursive function
    cout << result << endl;                  // Print number of consonants
    return 0;                                // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
countConsonants("Hello World", index=0)
'H' -> consonant -> 1
'e' -> not consonant -> 0
'l' -> consonant -> 1
'l' -> consonant -> 1
'o' -> not consonant -> 0
...
Total consonants = 7

Output: 7

```

---

## **Question: 25 Print string characters recursively Print s[0], recurse on s[1..n-1]**

**Approach:**
-- Question: Print String Characters Recursively
-- Approach:
-- 1. Base case: if string is empty, stop recursion
-- 2. Print first character
-- 3. Recurse on substring excluding first character
-- 4. This prints characters in original order

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Recursive function to print string characters
void printChars(const string &s, int index = 0) {
    if (index >= s.length()) return;       // Base case: end of string
    cout << s[index];                       // Print current character
    printChars(s, index + 1);              // Recurse on next character
}

int main() {
    string s;
    getline(cin, s);                        // Read input string
    printChars(s);                          // Call recursive function
    cout << endl;                           // Print newline at end
    return 0;                               // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
printChars("ABC", index=0)
Print 'A'
Recurse index=1
Print 'B'
Recurse index=2
Print 'C'
Recurse index=3 -> Base case -> stop

Output: ABC

```

---

## **Question: 26 Remove all occurrences of a character If s[0]==c skip, else append, recurse on s[1..n-1]**

**Approach:**
-- Question: Remove All Occurrences of a Character in a String
-- Approach:
-- 1. Base case: if string is empty, return empty string
-- 2. Check first character:
-- a) If it matches the character to remove, skip it
-- b) Else, include it in result
-- 3. Recurse on substring excluding first character
-- 4. Concatenate results from recursion

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Recursive function to remove all occurrences of character c
string removeChar(const string &s, char c, int index = 0) {
    if (index >= s.length()) return "";             // Base case: end of string
    if (s[index] == c) return removeChar(s, c, index + 1); // Skip character if it matches
    return s[index] + removeChar(s, c, index + 1); // Include character and recurse
}

int main() {
    string s;
    char c;
    getline(cin, s);                                // Read input string
    cin >> c;                                       // Character to remove
    string result = removeChar(s, c);              // Call recursive function
    cout << result << endl;                         // Print result
    return 0;                                      // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
removeChar("banana", 'a', index=0)
s[0]='b' != 'a' -> include 'b' + recurse
s[1]='a' == 'a' -> skip + recurse
s[2]='n' != 'a' -> include 'n' + recurse
s[3]='a' == 'a' -> skip + recurse
s[4]='n' != 'a' -> include 'n' + recurse
s[5]='a' == 'a' -> skip + recurse
s[6] -> Base case -> return ""

Output: "bnn"

```

---

## **Question: 27 Convert string to uppercase toupper(s[0]), recurse on s[1..n-1]**

**Approach:**
-- Question: Convert String to Uppercase Recursively
-- Approach:
-- 1. Base case: if string is empty, return empty string
-- 2. Convert first character to uppercase using toupper()
-- 3. Recurse on substring excluding first character
-- 4. Concatenate converted character with result of recursion

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Recursive function to convert string to uppercase
string toUpperCase(const string &s, int index = 0) {
    if (index >= s.length()) return "";            // Base case: end of string
    char upperChar = toupper(s[index]);           // Convert current character to uppercase
    return upperChar + toUpperCase(s, index + 1); // Concatenate with recursive result
}

int main() {
    string s;
    getline(cin, s);                               // Read input string
    string result = toUpperCase(s);               // Call recursive function
    cout << result << endl;                        // Print uppercase string
    return 0;                                     // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
toUpperCase("Hello World", index=0)
'H' -> 'H'
'e' -> 'E'
'l' -> 'L'
'l' -> 'L'
'o' -> 'O'
...
Output: "HELLO WORLD"

```

---

## **Question: 29 Count number of words in a string Traverse recursively, increment count on spaces/boundaries**

**Approach:**
-- Question: Count Number of Words in a String Recursively
-- Approach:
-- 1. Base case: if index reaches end of string, return 0
-- 2. Skip leading spaces
-- 3. Count a word when a non-space character is found
-- 4. Recurse to find next word after current word ends

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Recursive function to count words in a string
int countWords(const string &s, int index = 0) {
    int n = s.length();
    while (index < n && s[index] == ' ') index++;    // Skip spaces
    if (index >= n) return 0;                        // Base case: end of string
    while (index < n && s[index] != ' ') index++;    // Skip current word
    return 1 + countWords(s, index);                // Count current word + recurse
}

int main() {
    string s;
    getline(cin, s);                                 // Read input string (can include spaces)
    int result = countWords(s);                      // Call recursive function
    cout << result << endl;                          // Print number of words
    return 0;                                       // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
countWords("Hello world from ChatGPT", index=0)
Skip spaces -> index=0
Skip word "Hello" -> index=5
Recurse -> count = 1 + countWords(index=6)
Skip spaces -> index=6
Skip word "world" -> index=11
Recurse -> count = 1 + countWords(index=12)
...
Total words = 4

Output: 4

```

---

## **Question: 30 Remove duplicate adjacent characters Compare s[0] and s[1], keep first, recurse on rest**

**Approach:**
-- Question: Remove Duplicate Adjacent Characters in a String Recursively
-- Approach:
-- 1. Base case: if string is empty or has only one character, return it
-- 2. Compare first two characters:
-- a) If equal, skip the first character and recurse on remaining string
-- b) Else, keep first character and recurse on remaining string
-- 3. Concatenate kept character with recursive result

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Recursive function to remove adjacent duplicates
string removeAdjacentDuplicates(const string &s, int index = 0) {
    if (index >= s.length() - 1) return s.substr(index);  // Base case: last character or empty
    if (s[index] == s[index + 1])
        return removeAdjacentDuplicates(s, index + 1);    // Skip duplicate
    return s[index] + removeAdjacentDuplicates(s, index + 1); // Keep character and recurse
}

int main() {
    string s;
    getline(cin, s);                                     // Read input string
    string result = removeAdjacentDuplicates(s);        // Call recursive function
    cout << result << endl;                              // Print result string
    return 0;                                           // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
removeAdjacentDuplicates("aaabbcddd", index=0)
s[0]='a', s[1]='a' -> skip
s[1]='a', s[2]='a' -> skip
s[2]='a', s[3]='b' -> keep 'a' + recurse
s[3]='b', s[4]='b' -> skip
s[4]='b', s[5]='c' -> keep 'b' + recurse
...
Output: "abcd"

```

---

## **Question: 31 Sum of digits of a number last_digit + recurse on remaining number**

**Approach:**
-- Question: Sum of Digits of a Number Recursively
-- Approach:
-- 1. Base case: if number is 0, return 0
-- 2. Get last digit using n % 10
-- 3. Recurse on remaining number n / 10
-- 4. Sum last digit with recursive result

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to calculate sum of digits
int sumOfDigits(int n) {
    if (n == 0) return 0;                 // Base case: no digits left
    return (n % 10) + sumOfDigits(n / 10); // Add last digit + sum of remaining digits
}

int main() {
    int n;
    cin >> n;                             // Read input number
    cout << sumOfDigits(n) << endl;      // Print sum of digits
    return 0;                             // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
sumOfDigits(1234)
Last digit = 4 -> 4 + sumOfDigits(123)
Last digit = 3 -> 3 + sumOfDigits(12)
Last digit = 2 -> 2 + sumOfDigits(1)
Last digit = 1 -> 1 + sumOfDigits(0)
Base case reached -> return 0
Sum = 1+2+3+4 = 10
Output: 10

```

---

## **Question: 32 Check if number contains a digit X Compare last digit, recurse on remaining**

**Approach:**
-- Question: Check if a Number Contains a Digit X Recursively
-- Approach:
-- 1. Base case: if number is 0, return false (digit not found)
-- 2. Check last digit n % 10:
-- a) If equal to X, return true
-- b) Else, recurse on remaining number n / 10

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to check if number contains digit x
bool containsDigit(int n, int x) {
    if (n == 0) return false;               // Base case: no digits left
    if (n % 10 == x) return true;           // Last digit matches x
    return containsDigit(n / 10, x);        // Recurse on remaining number
}

int main() {
    int n, x;
    cin >> n >> x;                           // Read number and digit to check
    cout << (containsDigit(n, x) ? "Yes" : "No") << endl; // Print result
    return 0;                                // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
containsDigit(12345, 3)
Last digit 5 != 3 -> recurse 1234
Last digit 4 != 3 -> recurse 123
Last digit 3 == 3 -> return true
Output: Yes

```

---

## **Question: 33 Find maximum digit in a number Compare last digit with recursive max of remaining digits**

**Approach:**
-- Question: Find Maximum Digit in a Number Recursively
-- Approach:
-- 1. Base case: if number is 0, return 0 (no digits left)
-- 2. Get last digit using n % 10
-- 3. Recurse on remaining number n / 10 to find max digit in rest
-- 4. Return maximum of last digit and recursive result

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to find maximum digit
int maxDigit(int n) {
    if (n == 0) return 0;                         // Base case: no digits left
    int last = n % 10;                             // Get last digit
    int maxRest = maxDigit(n / 10);               // Max in remaining digits
    return max(last, maxRest);                    // Return maximum
}

int main() {
    int n;
    cin >> n;                                     // Read input number
    cout << maxDigit(n) << endl;                 // Print maximum digit
    return 0;                                    // End program
}
// End of code

// End of code
```

**Dry Run:**

```cpp
maxDigit(4937)
Last digit = 7, recurse maxDigit(493)
Last digit = 3, recurse maxDigit(49)
Last digit = 9, recurse maxDigit(4)
Last digit = 4, recurse maxDigit(0) -> return 0
Compare: max(4,0)=4, max(9,4)=9, max(3,9)=9, max(7,9)=9
Output: 9

```

---

## **Question: 34 Print numbers from 1 to N Print recurse(n-1), then print n 35 Print numbers from N to 1 Print n, recurse(n-1)**

**Approach:**
-- Question 34: Print Numbers from 1 to N Recursively
-- Approach:
-- 1. Base case: if n <= 0, stop recursion
-- 2. Recurse on n-1 first
-- 3. Print n after recursion (ensures 1 to N order)

-- Question 35: Print Numbers from N to 1 Recursively
-- Approach:
-- 1. Base case: if n <= 0, stop recursion
-- 2. Print n first
-- 3. Recurse on n-1 (ensures N to 1 order)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Recursive function to print numbers from 1 to N
void print1toN(int n) {
    if (n <= 0) return;           // Base case: stop if n <= 0
    print1toN(n - 1);             // Recurse for numbers before n
    cout << n << " ";             // Print current number
}

int main() {
    int n;
    cin >> n;                     // Read N
    print1toN(n);                 // Call recursive function
    cout << endl;
    return 0;                     // End program
}
// End of code
#include <iostream>
using namespace std;

// Recursive function to print numbers from N to 1
void printNto1(int n) {
    if (n <= 0) return;          // Base case: stop if n <= 0
    cout << n << " ";            // Print current number first
    printNto1(n - 1);            // Recurse for remaining numbers
}

int main() {
    int n;
    cin >> n;                     // Read N
    printNto1(n);                 // Call recursive function
    cout << endl;
    return 0;                     // End program
}
// End of code

```

**Dry Run:**

```cpp
// Dry run example here
```

---
