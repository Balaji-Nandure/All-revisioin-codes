# Detect Cycle in a Linked List

## Problem Statement

Given the head of a singly linked list, determine if the linked list contains a cycle.

---

## Approach: Floyd’s Cycle Detection Algorithm (Tortoise and Hare)

We use two pointers:

- `slow`: advances one step at a time
- `fast`: advances two steps at a time

### Logic

- If the list has a cycle, `slow` and `fast` will eventually meet.
- If the list has no cycle, `fast` will reach the end (`nullptr`) first.

This algorithm runs in **O(n)** time and uses **O(1)** space.

---

## C++ Implementation

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool hasCycle(ListNode *head) {
    if (!head || !head->next) return false;

    ListNode *slow = head;
    ListNode *fast = head;

    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast)
            return true;
    }

    return false;
}
```

---

## Dry Run (Example Explanation)

Consider a linked list:

```
3 → 2 → 0 → -4
      ↑       ↓
      ←←←←←←←←
```

- **Step 1**: `slow` and `fast` both at node 3
- **Step 2**: `slow` moves to 2, `fast` moves to 0
- **Step 3**: `slow` moves to 0, `fast` moves to -4
- **Step 4**: `slow` moves to -4, `fast` moves to 0
- **Eventually**: `slow` and `fast` meet inside the cycle → cycle detected

---

## Conclusion

Floyd's algorithm is a space-efficient and optimal way to detect cycles in linked lists. It's a commonly asked technique in coding interviews and real-world system design.
