## **Question: 1 Traverse a Linked List Iterative / Recursive**

**Approach:**
-- Problem: Traverse a singly linked list and print all its elements.
-- Approach:
-- 1. Use iterative traversal: start from head, move to next node until NULL.
-- 2. Alternatively, use recursion: print current node, then recursively call on next node.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Iterative traversal
void traverseIterative(Node* head) {
    Node* temp = head; // Start from head
    while(temp != nullptr) { // Traverse until end
        cout << temp->data << " "; // Print current node's data
        temp = temp->next; // Move to next node
    }
    cout << endl;
}

// Recursive traversal
void traverseRecursive(Node* head) {
    if(head == nullptr) return; // Base case: end of list
    cout << head->data << " "; // Print current node
    traverseRecursive(head->next); // Recurse for next node
}

// Driver code
int main() {
    // Creating Linked List: 1->2->3->4->5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Iterative Traversal: ";
    traverseIterative(head);

    cout << "Recursive Traversal: ";
    traverseRecursive(head);
    cout << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Linked List: 1->2->3->4->5

// Iterative:
// temp = 1 -> print 1
// temp = 2 -> print 2
// temp = 3 -> print 3
// temp = 4 -> print 4
// temp = 5 -> print 5
// temp = nullptr -> stop

// Recursive:
// Call traverseRecursive(1):
// print 1
// Call traverseRecursive(2):
// print 2
// Call traverseRecursive(3):
// print 3
// Call traverseRecursive(4):
// print 4
// Call traverseRecursive(5):
// print 5
// Call traverseRecursive(nullptr) -> return

```

---

## **Question: 2 Find length of Linked List Iterative / Recursive**

**Approach:**
-- Problem: Find the number of nodes in a singly linked list.
-- Approach:
-- 1. Iterative: Start from head, traverse each node, increment a counter until NULL.
-- 2. Recursive: Base case - if node is NULL return 0; otherwise, return 1 + length(next node).

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Iterative method to find length
int lengthIterative(Node* head) {
    int count = 0; // Initialize counter
    Node* temp = head; // Start from head
    while(temp != nullptr) { // Traverse until end
        count++; // Increment counter
        temp = temp->next; // Move to next node
    }
    return count;
}

// Recursive method to find length
int lengthRecursive(Node* head) {
    if(head == nullptr) return 0; // Base case: end of list
    return 1 + lengthRecursive(head->next); // Count current node + rest
}

// Driver code
int main() {
    // Creating Linked List: 1->2->3->4->5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Length (Iterative): " << lengthIterative(head) << endl;
    cout << "Length (Recursive): " << lengthRecursive(head) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Linked List: 1->2->3->4->5

// Iterative:
// count=0, temp=1 -> count=1
// temp=2 -> count=2
// temp=3 -> count=3
// temp=4 -> count=4
// temp=5 -> count=5
// temp=nullptr -> stop, return 5

// Recursive:
// lengthRecursive(1) = 1 + lengthRecursive(2)
// lengthRecursive(2) = 1 + lengthRecursive(3)
// lengthRecursive(3) = 1 + lengthRecursive(4)
// lengthRecursive(4) = 1 + lengthRecursive(5)
// lengthRecursive(5) = 1 + lengthRecursive(nullptr)
// lengthRecursive(nullptr) = 0
// => Total length = 5

```

---

## **Question: 3 Search for an element Linear search**

**Approach:**
-- Problem: Search for a given value in a singly linked list and return its position (0-based index or -1 if not found).
-- Approach:
-- 1. Iterative (Linear search): Traverse each node, compare value, return index if found.
-- 2. Recursive: Check current node's value; if matches return 0, else recurse on next node and add 1 if found.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Iterative linear search
int searchIterative(Node* head, int key) {
    Node* temp = head;
    int index = 0; // Start from index 0
    while(temp != nullptr) { // Traverse until end
        if(temp->data == key) return index; // Found key
        temp = temp->next; // Move to next node
        index++; // Increment index
    }
    return -1; // Key not found
}

// Recursive search
int searchRecursive(Node* head, int key) {
    if(head == nullptr) return -1; // Base case: end of list
    if(head->data == key) return 0; // Found key at current node
    int res = searchRecursive(head->next, key); // Recurse on next node
    if(res == -1) return -1; // Key not found in rest
    return res + 1; // Add 1 for current node index
}

// Driver code
int main() {
    // Creating Linked List: 10->20->30->40->50
    Node* head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);
    head->next->next->next = new Node(40);
    head->next->next->next->next = new Node(50);

    int key = 30;
    cout << "Iterative Search Index: " << searchIterative(head, key) << endl;
    cout << "Recursive Search Index: " << searchRecursive(head, key) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Linked List: 10->20->30->40->50, key=30

// Iterative:
// temp=10, index=0 -> not 30
// temp=20, index=1 -> not 30
// temp=30, index=2 -> found, return 2

// Recursive:
// searchRecursive(10) -> head=10 !=30 -> recurse(20)
// searchRecursive(20) -> head=20 !=30 -> recurse(30)
// searchRecursive(30) -> head=30 == key -> return 0
// Backtrack: 0+1=1 (from 20), 1+1=2 (from 10) -> index=2

```

---

## **Question: 4 Insert at head Pointer manipulation**

**Approach:**
-- Problem: Insert a new node at the beginning (head) of a singly linked list.
-- Approach:
-- 1. Create a new node with given value.
-- 2. Point its next to current head.
-- 3. Update head to point to the new node.
-- This is an O(1) operation.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Function to insert a node at head
void insertAtHead(Node*& head, int val) {
    Node* newNode = new Node(val); // Create new node
    newNode->next = head; // Point new node's next to current head
    head = newNode; // Update head to new node
}

// Function to print linked list
void printList(Node* head) {
    Node* temp = head;
    while(temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr; // Empty list

    insertAtHead(head, 10); // List: 10
    insertAtHead(head, 20); // List: 20->10
    insertAtHead(head, 30); // List: 30->20->10

    cout << "Linked List after inserting at head: ";
    printList(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Initially: head = nullptr

// insertAtHead(10):
// newNode=10, newNode->next=nullptr, head=newNode
// List: 10

// insertAtHead(20):
// newNode=20, newNode->next=head(10), head=newNode
// List: 20->10

// insertAtHead(30):
// newNode=30, newNode->next=head(20), head=newNode
// List: 30->20->10

```

---

## Question: -- Problem: Insert a new node at the end (tail) of a singly linked list.

**Approach:**
-- Problem: Insert a new node at the end (tail) of a singly linked list.
-- Approach:
-- 1. Create a new node with the given value.
-- 2. If list is empty, update head to new node.
-- 3. Otherwise, traverse to the last node.
-- 4. Point last node's next to the new node.
-- Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Function to insert at tail
void insertAtTail(Node*& head, int val) {
    Node* newNode = new Node(val); // Create new node
    if(head == nullptr) { // If list is empty
        head = newNode;
        return;
    }
    Node* temp = head;
    while(temp->next != nullptr) { // Traverse to last node
        temp = temp->next;
    }
    temp->next = newNode; // Point last node's next to new node
}

// Function to print linked list
void printList(Node* head) {
    Node* temp = head;
    while(temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr; // Empty list

    insertAtTail(head, 10); // List: 10
    insertAtTail(head, 20); // List: 10->20
    insertAtTail(head, 30); // List: 10->20->30

    cout << "Linked List after inserting at tail: ";
    printList(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Initially: head = nullptr

// insertAtTail(10):
// List empty -> head = 10
// List: 10

// insertAtTail(20):
// Traverse to last node (10)
// 10->next = 20
// List: 10->20

// insertAtTail(30):
// Traverse to last node (20)
// 20->next = 30
// List: 10->20->30

```

---

## **Question: 6 Insert at given position Pointer adjustment**

**Approach:**
-- Problem: Insert a new node at a specified position (0-based index) in a singly linked list.
-- Approach:
-- 1. If position = 0, insert at head.
-- 2. Otherwise, traverse to (pos-1)th node.
-- 3. Adjust pointers: newNode->next = current->next, current->next = newNode.
-- Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Function to insert at given position
void insertAtPosition(Node*& head, int val, int pos) {
    Node* newNode = new Node(val); // Create new node
    if(pos == 0) { // Insert at head
        newNode->next = head;
        head = newNode;
        return;
    }
    Node* temp = head;
    int index = 0;
    while(temp != nullptr && index < pos-1) { // Traverse to (pos-1)th node
        temp = temp->next;
        index++;
    }
    if(temp == nullptr) { // Position out of bounds
        cout << "Position out of range!" << endl;
        delete newNode;
        return;
    }
    newNode->next = temp->next; // Adjust pointers
    temp->next = newNode;
}

// Function to print linked list
void printList(Node* head) {
    Node* temp = head;
    while(temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr;

    insertAtPosition(head, 10, 0); // List: 10
    insertAtPosition(head, 20, 1); // List: 10->20
    insertAtPosition(head, 30, 1); // List: 10->30->20
    insertAtPosition(head, 40, 0); // List: 40->10->30->20

    cout << "Linked List after inserting at given positions: ";
    printList(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Initially: head = nullptr

// insertAtPosition(10,0): head = 10
// List: 10

// insertAtPosition(20,1): traverse to node 0 (10)
// 10->next = 20
// List: 10->20

// insertAtPosition(30,1): traverse to node 0 (10)
// newNode->next = 10->next(20)
// 10->next = 30
// List: 10->30->20

// insertAtPosition(40,0): newNode->next = head(10)
// head = 40
// List: 40->10->30->20

```

---

## **Question: 7 Delete head node Pointer adjustment**

**Approach:**
-- Problem: Delete the first node (head) of a singly linked list.
-- Approach:
-- 1. If list is empty, do nothing.
-- 2. Store current head in a temporary pointer.
-- 3. Move head to next node.
-- 4. Delete the old head to free memory.
-- Time Complexity: O(1), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Function to delete head node
void deleteHead(Node*& head) {
    if(head == nullptr) return; // Empty list
    Node* temp = head; // Store current head
    head = head->next; // Move head to next node
    delete temp; // Free old head memory
}

// Function to print linked list
void printList(Node* head) {
    Node* temp = head;
    while(temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr;

    // Create list: 10->20->30
    head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);

    cout << "Original List: ";
    printList(head);

    deleteHead(head); // Delete 10
    cout << "After deleting head: ";
    printList(head);

    deleteHead(head); // Delete 20
    cout << "After deleting head: ";
    printList(head);

    deleteHead(head); // Delete 30
    cout << "After deleting head: ";
    printList(head);

    deleteHead(head); // Empty list, nothing happens

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original List: 10->20->30

// deleteHead():
// temp = 10, head = 20, delete 10
// List: 20->30

// deleteHead():
// temp = 20, head = 30, delete 20
// List: 30

// deleteHead():
// temp = 30, head = nullptr, delete 30
// List: empty

```

---

## **Question: 8 Delete tail node Pointer adjustment**

**Approach:**
-- Problem: Delete the last node (tail) of a singly linked list.
-- Approach:
-- 1. If list is empty, do nothing.
-- 2. If only one node, delete head and set head = nullptr.
-- 3. Otherwise, traverse to the second-last node.
-- 4. Delete last node and set second-last node's next = nullptr.
-- Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Function to delete tail node
void deleteTail(Node*& head) {
    if(head == nullptr) return; // Empty list
    if(head->next == nullptr) { // Only one node
        delete head;
        head = nullptr;
        return;
    }
    Node* temp = head;
    while(temp->next->next != nullptr) { // Traverse to second-last node
        temp = temp->next;
    }
    delete temp->next; // Delete last node
    temp->next = nullptr; // Update second-last node's next
}

// Function to print linked list
void printList(Node* head) {
    Node* temp = head;
    while(temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr;

    // Create list: 10->20->30
    head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);

    cout << "Original List: ";
    printList(head);

    deleteTail(head); // Delete 30
    cout << "After deleting tail: ";
    printList(head);

    deleteTail(head); // Delete 20
    cout << "After deleting tail: ";
    printList(head);

    deleteTail(head); // Delete 10
    cout << "After deleting tail: ";
    printList(head);

    deleteTail(head); // Empty list, nothing happens

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original List: 10->20->30

// deleteTail():
// Traverse to 20 (second-last)
// Delete 30, 20->next = nullptr
// List: 10->20

// deleteTail():
// Traverse to 10 (second-last)
// Delete 20, 10->next = nullptr
// List: 10

// deleteTail():
// Only one node 10
// Delete 10, head = nullptr
// List: empty

```

---

## **Question: 9 Delete node at given position Pointer adjustment**

**Approach:**
-- Problem: Delete the node at a specified position (0-based index) in a singly linked list.
-- Approach:
-- 1. If list is empty, do nothing.
-- 2. If position = 0, delete head.
-- 3. Otherwise, traverse to (pos-1)th node.
-- 4. Adjust pointers: temp->next = node_to_delete->next and delete node_to_delete.
-- Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Function to delete node at given position
void deleteAtPosition(Node*& head, int pos) {
    if(head == nullptr) return; // Empty list
    if(pos == 0) { // Delete head
        Node* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    Node* temp = head;
    int index = 0;
    while(temp->next != nullptr && index < pos-1) { // Traverse to (pos-1)th node
        temp = temp->next;
        index++;
    }
    if(temp->next == nullptr) { // Position out of bounds
        cout << "Position out of range!" << endl;
        return;
    }
    Node* nodeToDelete = temp->next; // Node to delete
    temp->next = nodeToDelete->next; // Adjust pointers
    delete nodeToDelete; // Free memory
}

// Function to print linked list
void printList(Node* head) {
    Node* temp = head;
    while(temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr;

    // Create list: 10->20->30->40
    head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);
    head->next->next->next = new Node(40);

    cout << "Original List: ";
    printList(head);

    deleteAtPosition(head, 2); // Delete 30
    cout << "After deleting position 2: ";
    printList(head);

    deleteAtPosition(head, 0); // Delete 10
    cout << "After deleting position 0: ";
    printList(head);

    deleteAtPosition(head, 5); // Out of range
    cout << "After deleting position 5: ";
    printList(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original List: 10->20->30->40

// deleteAtPosition(2):
// Traverse to node 20 (index 1)
// nodeToDelete = 30
// temp->next = 30->next (40)
// Delete 30
// List: 10->20->40

// deleteAtPosition(0):
// Delete head 10
// head = 20
// List: 20->40

// deleteAtPosition(5):
// Traverse fails, temp->next = nullptr
// Position out of range
// List unchanged: 20->40

```

---

## **Question: 10 Delete a key (first occurrence) Linear search + pointer update**

**Approach:**
-- Problem: Delete the first node with a given key in a singly linked list.
-- Approach:
-- 1. If list is empty, do nothing.
-- 2. If head contains the key, delete head.
-- 3. Otherwise, traverse the list to find the first node with key, keeping track of previous node.
-- 4. Adjust previous->next = current->next and delete current node.
-- Time Complexity: O(n), Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Function to delete first occurrence of a key
void deleteKey(Node*& head, int key) {
    if(head == nullptr) return; // Empty list
    if(head->data == key) { // Key at head
        Node* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    Node* prev = head;
    Node* curr = head->next;
    while(curr != nullptr && curr->data != key) { // Traverse to find key
        prev = curr;
        curr = curr->next;
    }
    if(curr == nullptr) { // Key not found
        cout << "Key not found!" << endl;
        return;
    }
    prev->next = curr->next; // Update pointer
    delete curr; // Free memory
}

// Function to print linked list
void printList(Node* head) {
    Node* temp = head;
    while(temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr;

    // Create list: 10->20->30->20->40
    head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);
    head->next->next->next = new Node(20);
    head->next->next->next->next = new Node(40);

    cout << "Original List: ";
    printList(head);

    deleteKey(head, 20); // Delete first 20
    cout << "After deleting key 20: ";
    printList(head);

    deleteKey(head, 50); // Key not present
    cout << "After deleting key 50: ";
    printList(head);

    deleteKey(head, 10); // Delete head key
    cout << "After deleting key 10: ";
    printList(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original List: 10->20->30->20->40

// deleteKey(20):
// Key at 20 (first occurrence)
// prev=10, curr=20
// prev->next = 30
// List: 10->30->20->40

// deleteKey(50):
// Traverse list, key not found
// List unchanged: 10->30->20->40

// deleteKey(10):
// Key at head
// head = 30
// List: 30->20->40

```

---

## **Question: 11 Introduction to DLL: traverse, length, search Iterative / Recursive**

**Approach:**
-- Problem: Perform basic operations on a Doubly Linked List (DLL):
-- 1. Traverse the DLL forward and backward
-- 2. Find the length of DLL
-- 3. Search for an element
-- Approach:
-- - Traverse: Start from head, move using next pointer (forward) or tail using prev pointer (backward)
-- - Length: Count nodes while traversing
-- - Search: Compare each node's data with key while traversing
-- Time Complexity: O(n) for all operations, Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure for DLL
struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};

// Function to traverse DLL forward
void traverseForward(Node* head) {
    Node* temp = head;
    cout << "Forward: ";
    while(temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next; // Move to next node
    }
    cout << endl;
}

// Function to traverse DLL backward
void traverseBackward(Node* tail) {
    Node* temp = tail;
    cout << "Backward: ";
    while(temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->prev; // Move to previous node
    }
    cout << endl;
}

// Function to find length of DLL
int lengthDLL(Node* head) {
    int count = 0;
    Node* temp = head;
    while(temp != nullptr) {
        count++;
        temp = temp->next; // Move to next node
    }
    return count;
}

// Function to search for a key
bool searchDLL(Node* head, int key) {
    Node* temp = head;
    while(temp != nullptr) {
        if(temp->data == key) return true; // Key found
        temp = temp->next;
    }
    return false; // Key not found
}

// Driver code
int main() {
    // Creating DLL: 10 <-> 20 <-> 30 <-> 40
    Node* head = new Node(10);
    Node* node2 = new Node(20);
    Node* node3 = new Node(30);
    Node* tail = new Node(40);

    head->next = node2; node2->prev = head;
    node2->next = node3; node3->prev = node2;
    node3->next = tail; tail->prev = node3;

    traverseForward(head);
    traverseBackward(tail);
    cout << "Length of DLL: " << lengthDLL(head) << endl;
    cout << "Search 30: " << (searchDLL(head, 30) ? "Found" : "Not Found") << endl;
    cout << "Search 50: " << (searchDLL(head, 50) ? "Found" : "Not Found") << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// DLL: 10 <-> 20 <-> 30 <-> 40

// traverseForward:
// Prints: 10 20 30 40

// traverseBackward:
// Prints: 40 30 20 10

// lengthDLL:
// Counts nodes while traversing: 4

// searchDLL(30):
// Found at third node -> returns true

// searchDLL(50):
// Traverses entire list -> not found -> returns false

```

---

## **Question: 12: Insertions in DLL**

**Approach:**
-- Problem: Insert a node in a Doubly Linked List (DLL) at:
-- 1. Head
-- 2. Tail
-- 3. Given position
-- Approach:
-- - Head: new_node->next = head; head->prev = new_node; head = new_node
-- - Tail: traverse to last node, last->next = new_node; new_node->prev = last
-- - Position: traverse to pos-1 node, adjust pointers for prev and next
-- Time Complexity: O(n) for position/tail, O(1) for head; Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure for DLL
struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};

// Insert at head
void insertHead(Node*& head, int val) {
    Node* new_node = new Node(val);
    new_node->next = head;
    if(head != nullptr) head->prev = new_node; // Adjust prev pointer of old head
    head = new_node; // Update head
}

// Insert at tail
void insertTail(Node*& head, int val) {
    Node* new_node = new Node(val);
    if(head == nullptr) { head = new_node; return; }
    Node* temp = head;
    while(temp->next != nullptr) temp = temp->next; // Traverse to last node
    temp->next = new_node;
    new_node->prev = temp; // Adjust prev pointer
}

// Insert at given position (1-based)
void insertAtPosition(Node*& head, int val, int pos) {
    if(pos == 1) { insertHead(head, val); return; }
    Node* temp = head;
    for(int i=1; i<pos-1 && temp!=nullptr; i++) temp = temp->next;
    if(temp == nullptr) { cout<<"Position out of bounds\n"; return; }
    Node* new_node = new Node(val);
    new_node->next = temp->next;
    if(temp->next != nullptr) temp->next->prev = new_node;
    temp->next = new_node;
    new_node->prev = temp;
}

// Print DLL
void printDLL(Node* head) {
    Node* temp = head;
    while(temp) { cout << temp->data << " "; temp = temp->next; }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr;

    insertHead(head, 10);
    insertTail(head, 20);
    insertAtPosition(head, 15, 2); // Insert 15 at position 2

    cout << "DLL after insertions: ";
    printDLL(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// insertHead(10): 10
// insertTail(20): 10 <-> 20
// insertAtPosition(15,2): 10 <-> 15 <-> 20

```

---

## **Question: Deletions in DLL**

**Approach:**
-- Problem: Delete a node in DLL from:
-- 1. Head
-- 2. Tail
-- 3. Given position
-- Approach:
-- - Head: head = head->next; delete old head; adjust new head->prev = nullptr
-- - Tail: traverse to last node; adjust prev->next = nullptr; delete last
-- - Position: traverse to pos node; adjust prev->next and next->prev; delete node
-- Time Complexity: O(n) for tail/position, O(1) for head; Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure for DLL
struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};

// Delete head
void deleteHead(Node*& head) {
    if(head == nullptr) return;
    Node* temp = head;
    head = head->next;
    if(head != nullptr) head->prev = nullptr;
    delete temp;
}

// Delete tail
void deleteTail(Node*& head) {
    if(head == nullptr) return;
    if(head->next == nullptr) { delete head; head = nullptr; return; }
    Node* temp = head;
    while(temp->next != nullptr) temp = temp->next; // Traverse to last
    temp->prev->next = nullptr;
    delete temp;
}

// Delete at given position (1-based)
void deleteAtPosition(Node*& head, int pos) {
    if(head == nullptr) return;
    if(pos == 1) { deleteHead(head); return; }
    Node* temp = head;
    for(int i=1; i<pos && temp!=nullptr; i++) temp = temp->next;
    if(temp == nullptr) { cout<<"Position out of bounds\n"; return; }
    if(temp->next != nullptr) temp->next->prev = temp->prev;
    if(temp->prev != nullptr) temp->prev->next = temp->next;
    delete temp;
}

// Print DLL
void printDLL(Node* head) {
    Node* temp = head;
    while(temp) { cout << temp->data << " "; temp = temp->next; }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr;

    // DLL: 10 <-> 15 <-> 20
    head = new Node(10);
    head->next = new Node(15); head->next->prev = head;
    head->next->next = new Node(20); head->next->next->prev = head->next;

    deleteHead(head); // Delete 10
    deleteTail(head); // Delete 20
    deleteAtPosition(head, 1); // Delete 15

    cout << "DLL after deletions: ";
    printDLL(head); // Should be empty

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// DLL before deletion: 10 <-> 15 <-> 20
// deleteHead: 15 <-> 20
// deleteTail: 15
// deleteAtPosition(1): empty list


```

---

## **Question: 14 Reverse a DLL Iterative / Recursive**

**Approach:**
-- Problem: Reverse a doubly linked list (DLL) iteratively and recursively
-- Approach Iterative:
-- - Traverse the DLL
-- - Swap next and prev pointers for each node
-- - Move head to last node
-- Approach Recursive:
-- - Swap next and prev for current node
-- - Recurse for previous node (original next)
-- Time Complexity: O(n)
-- Space Complexity: O(1) for iterative, O(n) for recursive call stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure for DLL
struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};

// Iterative reverse
void reverseDLLIterative(Node*& head) {
    Node* temp = nullptr;
    Node* current = head;

    while(current != nullptr) {
        // Swap next and prev pointers
        temp = current->prev;
        current->prev = current->next;
        current->next = temp;

        // Move to next node (was prev)
        current = current->prev;
    }

    // Adjust head to last node
    if(temp != nullptr) head = temp->prev;
}

// Recursive reverse
void reverseDLLRecursive(Node*& head, Node* curr) {
    if(curr == nullptr) return;

    // Swap next and prev
    Node* temp = curr->prev;
    curr->prev = curr->next;
    curr->next = temp;

    if(curr->prev == nullptr) { head = curr; return; } // New head found

    reverseDLLRecursive(head, curr->prev);
}

// Print DLL
void printDLL(Node* head) {
    Node* temp = head;
    while(temp) { cout << temp->data << " "; temp = temp->next; }
    cout << endl;
}

// Driver code
int main() {
    Node* head = new Node(10);
    head->next = new Node(20); head->next->prev = head;
    head->next->next = new Node(30); head->next->next->prev = head->next;

    cout << "Original DLL: ";
    printDLL(head);

    reverseDLLIterative(head);
    cout << "Reversed DLL (Iterative): ";
    printDLL(head);

    reverseDLLRecursive(head, head);
    cout << "Reversed DLL (Recursive): ";
    printDLL(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Dry run example here
```

---

## **Question: 15 Remove duplicates from sorted DLL Traversal + pointer updates**

**Approach:**
-- Problem: Remove all duplicate nodes from a sorted doubly linked list (DLL)
-- Approach:
-- - Traverse the DLL from head to tail
-- - If current node's data == next node's data, remove next node
-- - Adjust next and prev pointers accordingly
-- Time Complexity: O(n)
-- Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure for DLL
struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};

// Function to remove duplicates from sorted DLL
void removeDuplicates(Node* head) {
    Node* current = head;

    while(current && current->next) {
        if(current->data == current->next->data) {
            // Duplicate found; remove next node
            Node* dup = current->next;
            current->next = dup->next;
            if(dup->next) dup->next->prev = current;
            delete dup; // Free memory
        } else {
            current = current->next; // Move to next node
        }
    }
}

// Print DLL
void printDLL(Node* head) {
    Node* temp = head;
    while(temp) { cout << temp->data << " "; temp = temp->next; }
    cout << endl;
}

// Driver code
int main() {
    Node* head = new Node(10);
    head->next = new Node(10); head->next->prev = head;
    head->next->next = new Node(20); head->next->next->prev = head->next;
    head->next->next->next = new Node(30); head->next->next->next->prev = head->next->next;
    head->next->next->next->next = new Node(30); head->next->next->next->next->prev = head->next->next->next;

    cout << "Original DLL: ";
    printDLL(head);

    removeDuplicates(head);
    cout << "DLL after removing duplicates: ";
    printDLL(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original DLL: 10 <-> 10 <-> 20 <-> 30 <-> 30
// After removing duplicates: 10 <-> 20 <-> 30

```

---

## **Question: 16 Delete all occurrences of a key in DLL Traverse + delete**

**Approach:**
-- Problem: Delete all nodes from a doubly linked list (DLL) that contain a given key
-- Approach:
-- - Traverse the DLL from head to tail
-- - If current node's data == key, remove node
-- - Adjust next and prev pointers accordingly
-- - Free memory of deleted nodes
-- Time Complexity: O(n)
-- Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure for DLL
struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};

// Function to delete all occurrences of a key
void deleteAllKey(Node*& head, int key) {
    Node* current = head;

    while(current) {
        if(current->data == key) {
            Node* toDelete = current;

            // Adjust head if needed
            if(current == head) head = current->next;

            // Adjust pointers
            if(current->prev) current->prev->next = current->next;
            if(current->next) current->next->prev = current->prev;

            current = current->next; // Move to next node
            delete toDelete; // Free memory
        } else {
            current = current->next; // Move to next node
        }
    }
}

// Print DLL
void printDLL(Node* head) {
    Node* temp = head;
    while(temp) { cout << temp->data << " "; temp = temp->next; }
    cout << endl;
}

// Driver code
int main() {
    Node* head = new Node(10);
    head->next = new Node(20); head->next->prev = head;
    head->next->next = new Node(10); head->next->next->prev = head->next;
    head->next->next->next = new Node(30); head->next->next->next->prev = head->next->next;
    head->next->next->next->next = new Node(10); head->next->next->next->next->prev = head->next->next->next;

    cout << "Original DLL: ";
    printDLL(head);

    deleteAllKey(head, 10);
    cout << "DLL after deleting all 10s: ";
    printDLL(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original DLL: 10 <-> 20 <-> 10 <-> 30 <-> 10
// After deleting all 10s: 20 <-> 30

```

---

## **Question: 17 Reverse a Linked List Iterative / Recursive**

**Approach:**
-- Problem: Reverse a singly linked list (iteratively and recursively)
-- Approach Iterative:
-- - Initialize three pointers: prev=null, curr=head, next=null
-- - Traverse list, reverse links: curr->next = prev
-- - Move prev and curr forward
-- - Set head = prev at end
-- Approach Recursive:
-- - Base case: head is null or head->next is null
-- - Recurse on head->next
-- - After recursion, set head->next->next = head and head->next = null
-- Time Complexity: O(n)
-- Space Complexity: O(1) iterative, O(n) recursive call stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure for singly linked list
struct Node {
    int data;
    Node* next;
    Node(int val) { data = val; next = nullptr; }
};

// Iterative reverse
void reverseIterative(Node*& head) {
    Node* prev = nullptr;
    Node* curr = head;
    Node* next = nullptr;

    while(curr) {
        next = curr->next;    // Store next node
        curr->next = prev;    // Reverse current link
        prev = curr;          // Move prev forward
        curr = next;          // Move curr forward
    }
    head = prev;             // Update head
}

// Recursive reverse
Node* reverseRecursive(Node* head) {
    if(!head || !head->next) return head; // Base case

    Node* newHead = reverseRecursive(head->next);
    head->next->next = head;  // Reverse link
    head->next = nullptr;     // Set current next to null

    return newHead;
}

// Print list
void printList(Node* head) {
    Node* temp = head;
    while(temp) { cout << temp->data << " "; temp = temp->next; }
    cout << endl;
}

// Driver code
int main() {
    Node* head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);

    cout << "Original List: ";
    printList(head);

    reverseIterative(head);
    cout << "Reversed List (Iterative): ";
    printList(head);

    head = reverseRecursive(head);
    cout << "Reversed List (Recursive): ";
    printList(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original List: 10 -> 20 -> 30
// After iterative reverse: 30 -> 20 -> 10
// After recursive reverse: 10 -> 20 -> 30

```

---

## **Question: 18 Reverse nodes in K-group Recursion / Iteration**

**Approach:**
-- Problem: Reverse every k nodes in a singly linked list
-- Approach:
-- - Iterative:
-- 1. Use three pointers: prev, curr, next
-- 2. Reverse first k nodes, then connect with next group
-- 3. Repeat for remaining nodes
-- - Recursive:
-- 1. Reverse first k nodes recursively
-- 2. Call function on remaining list and connect
-- Time Complexity: O(n)
-- Space Complexity: O(1) iterative, O(n/k) recursive

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) { data = val; next = nullptr; }
};

// Function to reverse k nodes (recursive)
Node* reverseKGroup(Node* head, int k) {
    Node* curr = head;
    Node* prev = nullptr;
    Node* next = nullptr;
    int count = 0;

    // Check if there are at least k nodes
    Node* temp = head;
    for(int i = 0; i < k; i++) {
        if(!temp) return head; // Less than k nodes, return as is
        temp = temp->next;
    }

    // Reverse k nodes
    while(curr && count < k) {
        next = curr->next;   // Store next node
        curr->next = prev;   // Reverse link
        prev = curr;         // Move prev forward
        curr = next;         // Move curr forward
        count++;
    }

    // Recurse for remaining list
    if(next) head->next = reverseKGroup(next, k);

    return prev; // New head after reversing k nodes
}

// Print list
void printList(Node* head) {
    while(head) { cout << head->data << " "; head = head->next; }
    cout << endl;
}

// Driver code
int main() {
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    int k = 2;
    cout << "Original List: ";
    printList(head);

    head = reverseKGroup(head, k);
    cout << "List after reversing every " << k << " nodes: ";
    printList(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original List: 1 -> 2 -> 3 -> 4 -> 5
// k = 2
// After reversing every 2 nodes: 2 -> 1 -> 4 -> 3 -> 5

```

---

## **Question: 19 Rotate Linked List by K positions Pointer manipulation**

**Approach:**
-- Problem: Rotate a singly linked list to the right by k positions
-- Approach:
-- 1. Find length of the list (n)
-- 2. Connect tail to head to make it circular
-- 3. Move (n - k % n) steps to find new tail
-- 4. Break the circle to set new head
-- Time Complexity: O(n)
-- Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) { data = val; next = nullptr; }
};

// Function to rotate list by k positions
Node* rotateK(Node* head, int k) {
    if(!head || !head->next || k == 0) return head;

    // Compute length and get last node
    Node* tail = head;
    int len = 1;
    while(tail->next) {
        tail = tail->next;
        len++;
    }

    k = k % len;           // Adjust k if k > length
    if(k == 0) return head;

    tail->next = head;     // Make it circular
    int stepsToNewHead = len - k;
    Node* newTail = tail;

    // Find new tail
    while(stepsToNewHead--) {
        newTail = newTail->next;
    }

    Node* newHead = newTail->next;
    newTail->next = nullptr; // Break the circle

    return newHead;
}

// Print list
void printList(Node* head) {
    while(head) { cout << head->data << " "; head = head->next; }
    cout << endl;
}

// Driver code
int main() {
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    int k = 2;
    cout << "Original List: ";
    printList(head);

    head = rotateK(head, k);
    cout << "Rotated List by " << k << " positions: ";
    printList(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original List: 1 -> 2 -> 3 -> 4 -> 5
// k = 2
// Rotated List: 4 -> 5 -> 1 -> 2 -> 3

```

---

## **Question: 20 Odd-Even Linked List Pointer reordering**

**Approach:**
-- Problem: Rearrange linked list such that all odd-position nodes come before even-position nodes
-- Approach:
-- 1. Use two pointers: odd and even
-- 2. Keep track of even head for later connection
-- 3. Traverse the list, link odd nodes together and even nodes together
-- 4. Connect last odd node to even head
-- Time Complexity: O(n)
-- Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) { data = val; next = nullptr; }
};

// Function to rearrange odd-even nodes
Node* oddEvenList(Node* head) {
    if(!head || !head->next) return head;

    Node* odd = head;            // Pointer for odd nodes
    Node* even = head->next;     // Pointer for even nodes
    Node* evenHead = even;       // Store start of even nodes

    while(even && even->next) {
        odd->next = even->next;  // Link current odd to next odd
        odd = odd->next;         // Move odd pointer
        even->next = odd->next;  // Link current even to next even
        even = even->next;       // Move even pointer
    }

    odd->next = evenHead;        // Connect last odd to first even
    return head;
}

// Print list
void printList(Node* head) {
    while(head) { cout << head->data << " "; head = head->next; }
    cout << endl;
}

// Driver code
int main() {
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Original List: ";
    printList(head);

    head = oddEvenList(head);
    cout << "Odd-Even List: ";
    printList(head);

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
// Original List: 1 -> 2 -> 3 -> 4 -> 5
// Odd-Even List: 1 -> 3 -> 5 -> 2 -> 4

```

---

## **Question: 21 Add 2 numbers represented by Linked List Dummy node / carry handling**

**Approach:**
PROBLEM STATEMENT:
You are given two non-empty linked lists representing two non-negative integers.

- The digits are stored in REVERSE ORDER (i.e., 1’s digit comes first).
- Each node contains a single digit.
- Add the two numbers and return the sum as a linked list (also in reverse order).

Example:
Input: l1 = (2 → 4 → 3), l2 = (5 → 6 → 4)
Meaning: 342 + 465 = 807
Output: (7 → 0 → 8)

APPROACH:

Brute Force:

- Convert both linked lists to numbers, add them, then convert back to linked list.
- Problem: May cause overflow if numbers are very large. Not safe.

Optimal (Carry Handling + Dummy Node):

1. Use a dummy node to simplify result list creation.
2. Traverse both linked lists simultaneously.
3. At each step:
   - Add digit from l1 + digit from l2 + carry.
   - Create a new node with (sum % 10).
   - Update carry = sum / 10.
4. Continue until both lists are processed and carry = 0.
5. Return dummy->next (skipping dummy).

Time Complexity: O(max(m, n))
Space Complexity: O(max(m, n))

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;           // Value stored in this node (digit)
    ListNode* next;    // Pointer to next node
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // Step 1: Create a dummy node to simplify result list creation
        ListNode* dummy = new ListNode(0);

        // Pointer to build the result list starting from dummy
        ListNode* current = dummy;

        // Variable to store carry from addition
        int carry = 0;

        // Step 2: Traverse both lists until both are fully processed
        // OR until carry is non-zero
        while (l1 != NULL || l2 != NULL || carry != 0) {
            // Get values from current nodes (if present), else 0
            int val1 = (l1 != NULL) ? l1->val : 0;
            int val2 = (l2 != NULL) ? l2->val : 0;

            // Add digits along with carry
            int sum = val1 + val2 + carry;

            // New digit to store = sum % 10 (single digit only)
            current->next = new ListNode(sum % 10);

            // Update carry for next step = sum / 10
            carry = sum / 10;

            // Move current pointer forward
            current = current->next;

            // Move forward in input lists if possible
            if (l1 != NULL) l1 = l1->next;
            if (l2 != NULL) l2 = l2->next;
        }

        // Step 3: Return the head of the result list (skip dummy node)
        return dummy->next;
    }
};

// -------------------------
// Helper functions for testing
// -------------------------

// Function to print linked list
void printList(ListNode* head) {
    while (head != NULL) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// Function to create linked list from array
ListNode* createList(int arr[], int n) {
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    // Example: l1 = 2 -> 4 -> 3 (represents 342)
    //          l2 = 5 -> 6 -> 4 (represents 465)
    int arr1[] = {2, 4, 3};
    int arr2[] = {5, 6, 4};

    ListNode* l1 = createList(arr1, 3);
    ListNode* l2 = createList(arr2, 3);

    Solution sol;
    ListNode* result = sol.addTwoNumbers(l1, l2);

    // Print result
    cout << "Result Linked List: ";
    printList(result);  // Expected: 7 -> 0 -> 8

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input:
 l1 = 2 → 4 → 3   (represents 342)
 l2 = 5 → 6 → 4   (represents 465)

Step | l1.val | l2.val | carry | sum = val1+val2+carry | New Node (sum % 10) | New carry (sum / 10)
--------------------------------------------------------------------------------------------
 1   |   2    |   5    |   0   |          7             |          7          |        0
 2   |   4    |   6    |   0   |         10             |          0          |        1
 3   |   3    |   4    |   1   |          8             |          8          |        0

Final Result:
 7 → 0 → 8   (represents 807, which is correct)

```

---

## **Question: 22 Add 1 to a number represented by Linked List Similar to add 2 numbers**

**Approach:**
PROBLEM STATEMENT:
You are given a non-empty linked list representing a non-negative integer.

- The digits are stored in REVERSE ORDER (i.e., 1’s digit comes first).
- Each node contains a single digit.
- Add 1 to the number and return the result as a linked list (in the same reverse order).

Example 1:
Input: (1 → 2 → 3) // represents 321
Meaning: 321 + 1 = 322
Output: (2 → 2 → 3)

Example 2:
Input: (9 → 9 → 9) // represents 999
Meaning: 999 + 1 = 1000
Output: (0 → 0 → 0 → 1)

APPROACH:

We can use the same technique as "Add 2 numbers" but with only one list and an initial carry = 1.

Steps:

1. Create a dummy node to simplify result list creation.
2. Start traversal from head with an initial carry = 1.
3. For each node:
   - Add node value + carry.
   - New digit = (sum % 10).
   - Update carry = (sum / 10).
4. If carry remains after the last node, create a new node for it.
5. Return dummy->next (skip dummy).

Time Complexity: O(n) (where n = number of digits)
Space Complexity: O(n) (result list size)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* addOne(ListNode* head) {
        // Step 1: Create dummy node
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;

        // Carry starts as 1 because we are adding +1
        int carry = 1;

        // Step 2: Traverse through the linked list
        while (head != NULL || carry != 0) {
            // Take value from current node if available
            int val = (head != NULL) ? head->val : 0;

            // Compute sum = digit + carry
            int sum = val + carry;

            // Create new node with single digit (sum % 10)
            current->next = new ListNode(sum % 10);

            // Update carry for next step
            carry = sum / 10;

            // Move forward in result list
            current = current->next;

            // Move head pointer if possible
            if (head != NULL) head = head->next;
        }

        // Return the new list (skip dummy node)
        return dummy->next;
    }
};

// -------------------------
// Helper functions
// -------------------------

void printList(ListNode* head) {
    while (head != NULL) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

ListNode* createList(int arr[], int n) {
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    // Example: (9 -> 9 -> 9) represents 999
    int arr[] = {9, 9, 9};
    ListNode* head = createList(arr, 3);

    Solution sol;
    ListNode* result = sol.addOne(head);

    cout << "Result Linked List: ";
    printList(result);  // Expected: 0 -> 0 -> 0 -> 1

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Let’s take input: 9 → 9 → 9  (represents 999)

Step 1:
Carry starts as 1.
First node = 9.
Sum = 9 + 1 = 10.
So we put digit 0 in the new list and carry becomes 1.

Step 2:
Next node = 9.
Sum = 9 + 1 (carry) = 10.
So we put another 0 and carry remains 1.

Step 3:
Next node = 9.
Sum = 9 + 1 = 10.
We again put 0 and carry is still 1.

Step 4:
Now the list is finished but carry = 1 is still left.
So we create one more node with value 1.

Final result linked list = 0 → 0 → 0 → 1
Which represents 1000, correct.


```

---

## **Question: 23 Find middle of Linked List Slow-Fast pointers**

**Approach:**
PROBLEM STATEMENT:
You are given the head of a singly linked list.
Find the middle node of the list and return it.

If the list has an even number of nodes,
return the second middle node.

Examples:

Input: 1 → 2 → 3 → 4 → 5
Output: 3 (middle is 3)

Input: 1 → 2 → 3 → 4 → 5 → 6
Output: 4 (two middles are 3 and 4, take 4)

---

APPROACH:

Brute Force:

1. First traverse the list to count total nodes (say n).
2. Traverse again till n/2 and return that node.
   Time = O(n), Space = O(1), but requires 2 passes.

Optimized (Slow-Fast Pointer Technique):

1. Use two pointers: slow and fast.
2. Initially both point to head.
3. Move slow by 1 step, fast by 2 steps in each iteration.
4. When fast reaches end (NULL), slow will be at the middle.
   - If even nodes → slow will point to second middle (as required).
5. Return slow.

Time Complexity: O(n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition of singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        // Two pointers: slow and fast
        ListNode* slow = head;
        ListNode* fast = head;

        // Move slow by 1, fast by 2
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;         // Move slow one step
            fast = fast->next->next;   // Move fast two steps
        }

        // When fast reaches end, slow is at middle
        return slow;
    }
};

// -------------------------
// Helper functions
// -------------------------
void printList(ListNode* head) {
    while (head != NULL) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

ListNode* createList(int arr[], int n) {
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    int arr[] = {1, 2, 3, 4, 5, 6};
    ListNode* head = createList(arr, 6);

    Solution sol;
    ListNode* middle = sol.middleNode(head);

    cout << "Middle Node Value: " << middle->val << endl;  // Expected: 4

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 3 → 4 → 5 → 6

Step 1:
slow = 1, fast = 1

Step 2:
slow moves to 2
fast moves to 3

Step 3:
slow moves to 3
fast moves to 5

Step 4:
slow moves to 4
fast moves to NULL (end reached)

Stop loop. slow = 4
That’s the middle node (for even length list, it correctly gives second middle).

```

---

## **Question: 24 Detect cycle/loop Floyd’s Tortoise & Hare**

**Approach:**
PROBLEM STATEMENT:
You are given the head of a singly linked list.
Determine if the linked list contains a cycle (loop).

- A cycle exists if a node’s next pointer points to a previous node in the list.

Example 1:
Input: 1 → 2 → 3 → 4 → 2 (loop back to 2)
Output: true

Example 2:
Input: 1 → 2 → 3 → 4 → NULL
Output: false

---

APPROACH:

Brute Force:

1. Use a hash set to store visited nodes.
2. Traverse the list and check if a node is already in the set.
   Time = O(n), Space = O(n).

Optimized (Floyd’s Tortoise & Hare):

1. Use two pointers: slow and fast, both start at head.
2. Move slow by 1 step, fast by 2 steps in each iteration.
3. If slow == fast at any point → cycle exists.
4. If fast reaches NULL → no cycle.
5. Return true if cycle exists, false otherwise.

Time Complexity: O(n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    bool hasCycle(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;

        // Traverse list
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;          // move 1 step
            fast = fast->next->next;    // move 2 steps

            if (slow == fast) {         // cycle detected
                return true;
            }
        }

        // fast reached end → no cycle
        return false;
    }
};

// -------------------------
// Helper functions
// -------------------------
void printList(ListNode* head, int limit=20) {
    // Print first 'limit' nodes to avoid infinite loop
    int count = 0;
    while (head != NULL && count < limit) {
        cout << head->val << " -> ";
        head = head->next;
        count++;
    }
    if (head != NULL) cout << "... (loop detected)" << endl;
    else cout << "NULL" << endl;
}

ListNode* createList(int arr[], int n) {
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    int arr[] = {1, 2, 3, 4};
    ListNode* head = createList(arr, 4);

    // Create a cycle: 4 -> 2
    head->next->next->next->next = head->next;

    Solution sol;
    bool cycle = sol.hasCycle(head);

    cout << "Cycle detected? " << (cycle ? "Yes" : "No") << endl;  // Expected: Yes

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 3 → 4 → 2 (cycle)

Step 1:
slow = 1, fast = 1

Step 2:
slow moves to 2
fast moves to 3

Step 3:
slow moves to 3
fast moves to 2 (after skipping 4)

Step 4:
slow moves to 4
fast moves to 4

slow == fast → cycle detected → return true

If there were no cycle, fast would reach NULL and return false.

```

---

## **Question: 25 Find length of loop Floyd’s algorithm extension**

**Approach:**
PROBLEM STATEMENT:
You are given the head of a singly linked list.
If the linked list contains a cycle (loop), find the length of the loop.

- A cycle exists if a node’s next pointer points to a previous node in the list.
- Return 0 if no cycle exists.

Example 1:
Input: 1 → 2 → 3 → 4 → 2 (loop back to 2)
Output: 3 (nodes in loop: 2 → 3 → 4)

Example 2:
Input: 1 → 2 → 3 → 4 → NULL
Output: 0 (no loop)

---

APPROACH:

We extend Floyd’s Tortoise & Hare:

1. Use two pointers: slow and fast, both start at head.
2. Move slow by 1 step, fast by 2 steps.
3. If slow == fast → cycle detected.
   - Now, to find loop length:
     - Keep one pointer fixed at meeting point.
     - Move the other pointer step by step until it meets the first pointer again.
     - Count steps → length of loop.
4. If fast reaches NULL → no cycle, return 0.

Time Complexity: O(n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    int loopLength(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;

        // Detect cycle using Floyd's Tortoise & Hare
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;          // move 1 step
            fast = fast->next->next;    // move 2 steps

            if (slow == fast) {         // cycle detected
                // Count loop length
                int count = 1;
                ListNode* temp = slow->next;
                while (temp != slow) {
                    count++;
                    temp = temp->next;
                }
                return count;
            }
        }

        // No cycle
        return 0;
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(int arr[], int n) {
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    int arr[] = {1, 2, 3, 4, 5};
    ListNode* head = createList(arr, 5);

    // Create a loop: 5 -> 3
    head->next->next->next->next->next = head->next->next;

    Solution sol;
    int length = sol.loopLength(head);

    cout << "Length of loop: " << length << endl;  // Expected: 3

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 3 → 4 → 5 → 3 (loop starts at 3)

Step 1:
slow = 1, fast = 1

Step 2:
slow moves to 2
fast moves to 3

Step 3:
slow moves to 3
fast moves to 5

Step 4:
slow moves to 4
fast moves to 4 → slow == fast → cycle detected

Step 5:
Count loop length:
- temp = 4->next = 5, count = 1
- temp = 5->next = 3, count = 2
- temp = 3->next = 4, count = 3 → temp == slow
Loop length = 3

```

---

## **Question: 26 Find start of cycle Floyd’s + proof**

**Approach:**
PROBLEM STATEMENT:
You are given the head of a singly linked list.
If the linked list contains a cycle (loop), find the node where the cycle begins.
Return NULL if there is no cycle.

Example 1:
Input: 1 → 2 → 3 → 4 → 2 (loop back to 2)
Output: Node with value 2

Example 2:
Input: 1 → 2 → 3 → 4 → NULL
Output: NULL (no cycle)

---

APPROACH (Floyd’s Tortoise & Hare + Proof):

1. Detect Cycle:
   - Use two pointers: slow and fast.
   - Move slow by 1 step, fast by 2 steps.

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;

        // Step 1: Detect cycle
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;          // move 1 step
            fast = fast->next->next;    // move 2 steps

            if (slow == fast) {         // cycle detected
                // Step 2: Find start of cycle
                slow = head;
                while (slow != fast) {
                    slow = slow->next;
                    fast = fast->next;
                }
                return slow;  // start of cycle
            }
        }

        // No cycle
        return NULL;
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(int arr[], int n) {
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    int arr[] = {1, 2, 3, 4, 5};
    ListNode* head = createList(arr, 5);

    // Create a loop: 5 -> 3
    head->next->next->next->next->next = head->next->next;

    Solution sol;
    ListNode* start = sol.detectCycle(head);

    if (start != NULL)
        cout << "Start of cycle: " << start->val << endl;  // Expected: 3
    else
        cout << "No cycle detected" << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 3 → 4 → 5 → 3 (cycle starts at 3)

Step 1: Detect cycle
- slow = 1, fast = 1
- slow = 2, fast = 3
- slow = 3, fast = 5
- slow = 4, fast = 4 → slow == fast → cycle detected

Step 2: Find start
- Move slow to head (1), fast at meeting point (4)
- Move both 1 step at a time:
  - slow = 1 → 2 → 3
  - fast = 4 → 5 → 3
- They meet at node 3 → start of cycle

Output: Node with value 3

```

---

## **Question: 27 Intersection of two Y-shaped Linked Lists Pointer traversal / length adjustment**

**Approach:**
PROBLEM STATEMENT:
You are given the heads of two singly linked lists, which may intersect at some point forming a Y-shape.
Find the node at which the intersection begins. Return NULL if there is no intersection.

Example 1:

List A: 1 → 2 → 3
\
 6 → 7
/
List B: 4 → 5

Output: Node with value 6 (intersection starts at 6)

Example 2:

List A: 1 → 2 → 3 → NULL
List B: 4 → 5 → 6 → NULL

Output: NULL (no intersection)

---

APPROACH (Pointer Traversal / Length Adjustment):

Method 1: Length Adjustment (Optimal)

1. Find lengths of both lists: lenA and lenB.
2. Advance the head of the longer list by |lenA - lenB| steps.
3. Now traverse both lists together step by step.
4. The first node where both pointers are equal is the intersection.
5. If no intersection, both will reach NULL simultaneously.

Alternative Method (Two-pointer traversal without lengths):

- Use two pointers, pA and pB.
- Traverse each list; when reaching the end, switch to the head of the other list.
- If they intersect, pA and pB will meet at intersection.
- If no intersection, both reach NULL together.

Time Complexity: O(n + m)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        if (!headA || !headB) return NULL;

        ListNode* pA = headA;
        ListNode* pB = headB;

        // Traverse both lists, switching heads at end
        while (pA != pB) {
            pA = (pA != NULL) ? pA->next : headB;
            pB = (pB != NULL) ? pB->next : headA;
        }

        // Either intersection node or NULL if no intersection
        return pA;
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(int arr[], int n) {
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    // Create two lists
    int arrA[] = {1, 2, 3};
    int arrB[] = {4, 5};
    int arrCommon[] = {6, 7};

    ListNode* headA = createList(arrA, 3);
    ListNode* headB = createList(arrB, 2);
    ListNode* common = createList(arrCommon, 2);

    // Attach common part
    ListNode* temp = headA;
    while (temp->next != NULL) temp = temp->next;
    temp->next = common;

    temp = headB;
    while (temp->next != NULL) temp = temp->next;
    temp->next = common;

    Solution sol;
    ListNode* intersection = sol.getIntersectionNode(headA, headB);

    if (intersection)
        cout << "Intersection Node: " << intersection->val << endl;  // Expected: 6
    else
        cout << "No intersection" << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
List A: 1 → 2 → 3 → 6 → 7
List B: 4 → 5 → 6 → 7

Step 1: Initialize pointers
pA = 1, pB = 4

Step 2: Traverse both
- pA = 2, pB = 5
- pA = 3, pB = 6
- pA = 6, pB = 7
- pA = 7, pB = NULL
- pA = NULL, pB = headA (1)
- pA = headB (4), pB = 2
- pA = 5, pB = 3
- pA = 6, pB = 6 → pA == pB

Intersection found at node with value 6.

```

---

## **Question: 28 Merge two sorted Linked Lists Iterative / Recursive**

**Approach:**
PROBLEM STATEMENT:
You are given the heads of two sorted singly linked lists.
Merge them into a single sorted linked list and return its head.

Example 1:
Input: l1 = 1 → 3 → 5, l2 = 2 → 4 → 6
Output: 1 → 2 → 3 → 4 → 5 → 6

Example 2:
Input: l1 = 1 → 2 → 4, l2 = 1 → 3 → 4
Output: 1 → 1 → 2 → 3 → 4 → 4

---

APPROACH:

Iterative Method:

1. Create a dummy node to simplify merging.
2. Maintain a pointer 'current' starting at dummy.
3. Compare l1 and l2 nodes:
   - Append the smaller value to current->next.
   - Move that list forward.
4. Continue until one list is exhausted.
5. Append remaining nodes from the non-empty list.
6. Return dummy->next.

Recursive Method:

1. Base case: if l1 is NULL, return l2; if l2 is NULL, return l1.
2. Compare l1 and l2 values:
   - If l1->val < l2->val: l1->next = merge(l1->next, l2); return l1
   - Else: l2->next = merge(l1, l2->next); return l2

Time Complexity: O(n + m)  
Space Complexity: O(1) for iterative, O(n + m) for recursive (due to call stack)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    // Iterative method
    ListNode* mergeTwoListsIterative(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0);  // dummy node
        ListNode* current = dummy;

        while (l1 != NULL && l2 != NULL) {
            if (l1->val < l2->val) {
                current->next = l1;
                l1 = l1->next;
            } else {
                current->next = l2;
                l2 = l2->next;
            }
            current = current->next;
        }

        // Append remaining nodes
        if (l1 != NULL) current->next = l1;
        if (l2 != NULL) current->next = l2;

        return dummy->next;
    }

    // Recursive method
    ListNode* mergeTwoListsRecursive(ListNode* l1, ListNode* l2) {
        if (l1 == NULL) return l2;
        if (l2 == NULL) return l1;

        if (l1->val < l2->val) {
            l1->next = mergeTwoListsRecursive(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoListsRecursive(l1, l2->next);
            return l2;
        }
    }
};

// -------------------------
// Helper functions
// -------------------------
void printList(ListNode* head) {
    while (head != NULL) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

ListNode* createList(int arr[], int n) {
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    int arr1[] = {1, 3, 5};
    int arr2[] = {2, 4, 6};

    ListNode* l1 = createList(arr1, 3);
    ListNode* l2 = createList(arr2, 3);

    Solution sol;
    ListNode* mergedIterative = sol.mergeTwoListsIterative(l1, l2);

    cout << "Merged List (Iterative): ";
    printList(mergedIterative);

    // For recursive, recreate lists because previous merge modified them
    l1 = createList(arr1, 3);
    l2 = createList(arr2, 3);

    ListNode* mergedRecursive = sol.mergeTwoListsRecursive(l1, l2);
    cout << "Merged List (Recursive): ";
    printList(mergedRecursive);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input:
l1 = 1 → 3 → 5
l2 = 2 → 4 → 6

Iterative method:
- Compare 1 and 2 → 1 smaller → add 1, move l1 to 3
- Compare 3 and 2 → 2 smaller → add 2, move l2 to 4
- Compare 3 and 4 → 3 smaller → add 3, move l1 to 5
- Compare 5 and 4 → 4 smaller → add 4, move l2 to 6
- Compare 5 and 6 → 5 smaller → add 5, move l1 to NULL
- l1 is NULL, append remaining l2 node 6

Final merged list: 1 → 2 → 3 → 4 → 5 → 6

Recursive method works similarly:
- Compare 1 & 2 → 1 smaller → 1->next = merge(3→5, 2→4→6)
- Compare 3 & 2 → 2 smaller → 2->next = merge(3→5, 4→6)
- Continue recursively until all nodes are merged
- Result: 1 → 2 → 3 → 4 → 5 → 6

```

---

## **Question: 29 Merge K sorted Linked Lists Priority queue / Divide & Conquer**

**Approach:**
PROBLEM STATEMENT:
You are given an array of k sorted singly linked lists.
Merge all the linked lists into one sorted linked list and return its head.

Example 1:
Input: [[1→4→5], [1→3→4], [2→6]]
Output: 1→1→2→3→4→4→5→6

Example 2:
Input: []
Output: NULL

Example 3:
Input: [[]]
Output: NULL

---

APPROACH:

Method 1: Priority Queue (Min-Heap)

1. Create a min-heap (priority queue) that stores nodes based on node value.
2. Push the head of each list into the heap.
3. While heap is not empty:
   - Pop the smallest node.
   - Append it to result list.
   - If popped node has next, push next into heap.
4. Return merged list head.

Time Complexity: O(N log k)

- N = total number of nodes, k = number of lists  
  Space Complexity: O(k) (heap size)

Method 2: Divide & Conquer

1. Pairwise merge lists:
   - Merge list 0 & 1, 2 & 3, ... repeat until one list remains.
2. Each merge uses the mergeTwoLists method.
3. Efficient when k is large.

Time Complexity: O(N log k)  
Space Complexity: O(1) for iterative merges (or O(log k) for recursion)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

// Comparison object for priority queue
struct Compare {
    bool operator()(ListNode* a, ListNode* b) {
        return a->val > b->val;  // min-heap
    }
};

class Solution {
public:
    // Method 1: Priority Queue (Min-Heap)
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, Compare> pq;

        // Push first node of each list
        for (auto node : lists) {
            if (node) pq.push(node);
        }

        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;

        while (!pq.empty()) {
            ListNode* top = pq.top();
            pq.pop();

            current->next = top;
            current = current->next;

            if (top->next) pq.push(top->next);
        }

        return dummy->next;
    }

    // Method 2: Divide & Conquer
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;
        while (l1 && l2) {
            if (l1->val < l2->val) { current->next = l1; l1 = l1->next; }
            else { current->next = l2; l2 = l2->next; }
            current = current->next;
        }
        current->next = (l1) ? l1 : l2;
        return dummy->next;
    }

    ListNode* mergeKListsDivideAndConquer(vector<ListNode*>& lists) {
        if (lists.empty()) return NULL;
        int interval = 1;
        int n = lists.size();
        while (interval < n) {
            for (int i = 0; i + interval < n; i += interval * 2) {
                lists[i] = mergeTwoLists(lists[i], lists[i + interval]);
            }
            interval *= 2;
        }
        return lists[0];
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(vector<int> arr) {
    if (arr.empty()) return NULL;
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < arr.size(); i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    vector<ListNode*> lists;

    lists.push_back(createList({1,4,5}));
    lists.push_back(createList({1,3,4}));
    lists.push_back(createList({2,6}));

    Solution sol;

    ListNode* mergedPQ = sol.mergeKLists(lists);
    cout << "Merged List (Priority Queue): ";
    printList(mergedPQ);

    // Recreate lists for divide & conquer
    lists.clear();
    lists.push_back(createList({1,4,5}));
    lists.push_back(createList({1,3,4}));
    lists.push_back(createList({2,6}));

    ListNode* mergedDC = sol.mergeKListsDivideAndConquer(lists);
    cout << "Merged List (Divide & Conquer): ";
    printList(mergedDC);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input lists:
List 1: 1 → 4 → 5
List 2: 1 → 3 → 4
List 3: 2 → 6

Priority Queue method:
- Push 1,1,2 → smallest = 1 → add to result
- Push next from list 1 → 4 → heap: 1,2,4 → smallest = 1 → add
- Push next from list 2 → 3 → heap: 2,3,4 → smallest = 2 → add
- Push next from list 3 → 6 → heap: 3,4,6 → smallest = 3 → add
- Continue popping and pushing next nodes until heap empty
Final merged list: 1 → 1 → 2 → 3 → 4 → 4 → 5 → 6

Divide & Conquer method:
- Merge list1 & list2 → 1 → 1 → 3 → 4 → 4 → 5
- Merge result with list3 → 1 → 1 → 2 → 3 → 4 → 4 → 5 → 6
Final merged list is the same.

```

---

## **Question: 30 Sort a Linked List Merge sort / Brute force**

**Approach:**
PROBLEM STATEMENT:
You are given the head of a singly linked list.
Sort the linked list in ascending order and return its head.

Example 1:
Input: 4 → 2 → 1 → 3
Output: 1 → 2 → 3 → 4

Example 2:
Input: -1 → 5 → 3 → 4 → 0
Output: -1 → 0 → 3 → 4 → 5

---

APPROACH:

Brute Force:

1. Traverse the linked list and store all values in an array/vector.
2. Sort the array/vector.
3. Reconstruct the linked list from the sorted array.

Time Complexity: O(n log n) (due to sort)  
Space Complexity: O(n) (array storage)

Optimal (Merge Sort on Linked List):

1. Base case: if head is NULL or only one node → return head.
2. Split the list into two halves using slow-fast pointer method.
3. Recursively sort the left and right halves.
4. Merge the two sorted halves using mergeTwoLists function.
5. Return the merged sorted list.

Time Complexity: O(n log n)  
Space Complexity: O(log n) due to recursion stack

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    // Merge two sorted linked lists
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;
        while (l1 && l2) {
            if (l1->val < l2->val) { current->next = l1; l1 = l1->next; }
            else { current->next = l2; l2 = l2->next; }
            current = current->next;
        }
        current->next = (l1) ? l1 : l2;
        return dummy->next;
    }

    // Merge Sort on Linked List
    ListNode* sortList(ListNode* head) {
        if (!head || !head->next) return head; // base case

        // Step 1: Split list into two halves
        ListNode* slow = head;
        ListNode* fast = head;
        ListNode* prev = NULL;

        while (fast && fast->next) {
            prev = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        prev->next = NULL; // cut the list into two halves

        // Step 2: Recursively sort both halves
        ListNode* l1 = sortList(head);
        ListNode* l2 = sortList(slow);

        // Step 3: Merge sorted halves
        return mergeTwoLists(l1, l2);
    }

    // Optional: Brute Force method
    ListNode* sortListBruteForce(ListNode* head) {
        vector<int> vals;
        ListNode* temp = head;
        while (temp) {
            vals.push_back(temp->val);
            temp = temp->next;
        }

        sort(vals.begin(), vals.end());

        temp = head;
        int i = 0;
        while (temp) {
            temp->val = vals[i++];
            temp = temp->next;
        }
        return head;
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(vector<int> arr) {
    if (arr.empty()) return NULL;
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < arr.size(); i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    vector<int> arr = {4, 2, 1, 3};
    ListNode* head = createList(arr);

    Solution sol;
    ListNode* sorted = sol.sortList(head);

    cout << "Sorted Linked List: ";
    printList(sorted);  // Expected: 1 -> 2 -> 3 -> 4

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 4 → 2 → 1 → 3

Step 1: Split
- slow/fast → find middle: slow stops at 1
- Cut list: Left = 4 → 2, Right = 1 → 3

Step 2: Recursively sort halves
- Left 4 → 2:
    - Split → 4 and 2
    - Merge → 2 → 4
- Right 1 → 3:
    - Split → 1 and 3
    - Merge → 1 → 3

Step 3: Merge sorted halves
- Merge 2 → 4 and 1 → 3:
    - Compare 2 and 1 → pick 1
    - Compare 2 and 3 → pick 2
    - Compare 4 and 3 → pick 3
    - Append remaining 4

Final sorted list: 1 → 2 → 3 → 4

```

---

## **Question: 31 Sort a Linked List of 0’s,1’s,2’s Counting / pointer reordering**

**Approach:**
PROBLEM STATEMENT:
You are given the head of a singly linked list containing only 0s, 1s, and 2s.
Sort the linked list such that all 0s appear first, then 1s, then 2s.

Example 1:
Input: 1 → 2 → 0 → 1 → 2 → 0
Output: 0 → 0 → 1 → 1 → 2 → 2

Example 2:
Input: 0 → 0 → 1 → 2 → 1
Output: 0 → 0 → 1 → 1 → 2

---

APPROACH:

Method 1: Counting

1. Traverse the list once and count number of 0s, 1s, and 2s.
2. Traverse again and overwrite node values:
   - Fill 0s first, then 1s, then 2s.

Time Complexity: O(n)  
Space Complexity: O(1)

Method 2: Pointer Reordering (Dutch National Flag)

1. Create three dummy lists: zeroD, oneD, twoD for 0s, 1s, 2s.
2. Traverse original list and append nodes to respective lists.
3. Connect zero, one, two lists sequentially.
4. Return the head of zero list (or one/two if zero list empty).

Time Complexity: O(n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    // Method 1: Counting
    ListNode* sortListCounting(ListNode* head) {
        int count[3] = {0, 0, 0};
        ListNode* temp = head;

        // Count 0s,1s,2s
        while (temp) {
            count[temp->val]++;
            temp = temp->next;
        }

        // Overwrite list with sorted values
        temp = head;
        for (int i = 0; i < 3; i++) {
            while (count[i]--) {
                temp->val = i;
                temp = temp->next;
            }
        }
        return head;
    }

    // Method 2: Pointer Reordering (Dutch National Flag)
    ListNode* sortListPointers(ListNode* head) {
        ListNode zeroD(0), oneD(0), twoD(0);
        ListNode *zero = &zeroD, *one = &oneD, *two = &twoD;

        ListNode* curr = head;
        while (curr) {
            if (curr->val == 0) { zero->next = curr; zero = zero->next; }
            else if (curr->val == 1) { one->next = curr; one = one->next; }
            else { two->next = curr; two = two->next; }
            curr = curr->next;
        }

        // Connect three lists
        zero->next = (oneD.next) ? oneD.next : twoD.next;
        one->next = twoD.next;
        two->next = NULL;

        return zeroD.next;
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(vector<int> arr) {
    if (arr.empty()) return NULL;
    ListNode* head = new ListNode(arr[0]);
    ListNode* curr = head;
    for (int i = 1; i < arr.size(); i++) {
        curr->next = new ListNode(arr[i]);
        curr = curr->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    vector<int> arr = {1, 2, 0, 1, 2, 0};
    ListNode* head = createList(arr);

    Solution sol;
    ListNode* sortedCounting = sol.sortListCounting(head);
    cout << "Sorted List (Counting): ";
    printList(sortedCounting);

    // Recreate list for pointer method
    head = createList(arr);
    ListNode* sortedPointers = sol.sortListPointers(head);
    cout << "Sorted List (Pointers): ";
    printList(sortedPointers);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 0 → 1 → 2 → 0

Method 1: Counting
- Count: 0 → 2, 1 → 2, 2 → 2
- Overwrite nodes:
  1st node → 0
  2nd node → 0
  3rd node → 1
  4th node → 1
  5th node → 2
  6th node → 2
Final list: 0 → 0 → 1 → 1 → 2 → 2

Method 2: Pointer Reordering
- Create three dummy lists:
  zero: 0 → 0
  one: 1 → 1
  two: 2 → 2
- Connect: zero->next = one, one->next = two
Final list: 0 → 0 → 1 → 1 → 2 → 2

```

---

## **Question: 32 Clone Linked List with next & random pointers HashMap / Interweaving nodes**

**Approach:**
PROBLEM STATEMENT:
You are given a linked list where each node has:

- next pointer to the next node
- random pointer to any node in the list or NULL.

Create a deep copy (clone) of this linked list.

Example:
Original List: 1 -> 2 -> 3
Random pointers: 1.random -> 3, 2.random -> 1, 3.random -> 2
Output: New cloned list with same next and random connections.

---

APPROACH:

Method 1: Using HashMap

1. Traverse original list and create new nodes (clone) while storing mapping from original -> clone in a hash map.
2. Traverse again and assign next and random pointers using the hash map.

Time Complexity: O(n)  
Space Complexity: O(n) (hash map)

Method 2: Interweaving Nodes (Optimal)

1. For each original node, insert its clone right after it.
   e.g., original: 1 → 2 → 3  
    interweaved: 1 → 1' → 2 → 2' → 3 → 3'
2. Assign random pointers of clones:
   - cloneNode->random = original->random->next (if original->random exists)
3. Separate original and cloned lists.

Time Complexity: O(n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

// Definition for Node with random pointer
struct Node {
    int val;
    Node* next;
    Node* random;
    Node(int x) : val(x), next(NULL), random(NULL) {}
};

class Solution {
public:
    // Method 1: Using HashMap
    Node* copyRandomListHashMap(Node* head) {
        if (!head) return NULL;

        unordered_map<Node*, Node*> map; // map original node -> clone

        Node* curr = head;
        while (curr) {
            map[curr] = new Node(curr->val); // create clone
            curr = curr->next;
        }

        curr = head;
        while (curr) {
            map[curr]->next = map[curr->next];       // set clone's next
            map[curr]->random = map[curr->random];   // set clone's random
            curr = curr->next;
        }

        return map[head]; // return cloned head
    }

    // Method 2: Interweaving Nodes (Optimal)
    Node* copyRandomListInterweave(Node* head) {
        if (!head) return NULL;

        Node* curr = head;

        // Step 1: Insert cloned nodes after originals
        while (curr) {
            Node* copy = new Node(curr->val); // create clone
            copy->next = curr->next;           // clone points to next node
            curr->next = copy;                 // insert clone after original
            curr = copy->next;                 // move to next original
        }

        // Step 2: Assign random pointers
        curr = head;
        while (curr) {
            if (curr->random)
                curr->next->random = curr->random->next; // clone.random points to clone of original.random
            curr = curr->next->next; // move to next original
        }

        // Step 3: Separate original and cloned lists
        Node* dummy = new Node(0);
        Node* copyCurr = dummy;
        curr = head;
        while (curr) {
            copyCurr->next = curr->next;       // add clone to new list
            curr->next = curr->next->next;     // restore original list
            curr = curr->next;                 // move to next original
            copyCurr = copyCurr->next;         // move to next clone
        }

        return dummy->next; // return cloned head
    }
};

// -------------------------
// Helper functions
// -------------------------
Node* createList(vector<int> vals, vector<int> randomIndex) {
    if (vals.empty()) return NULL;
    vector<Node*> nodes;
    for (int val : vals) nodes.push_back(new Node(val));

    for (int i = 0; i < nodes.size(); i++) {
        if (i + 1 < nodes.size()) nodes[i]->next = nodes[i + 1];
        if (randomIndex[i] != -1) nodes[i]->random = nodes[randomIndex[i]];
    }

    return nodes[0];
}

void printList(Node* head) {
    Node* curr = head;
    while (curr) {
        cout << "Node: " << curr->val;
        if (curr->random) cout << ", Random: " << curr->random->val;
        else cout << ", Random: NULL";
        cout << endl;
        curr = curr->next;
    }
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    // Original list: 1->2->3, random = [2,0,1] (indexes)
    vector<int> vals = {1,2,3};
    vector<int> randomIndex = {2,0,1};
    Node* head = createList(vals, randomIndex);

    Solution sol;
    Node* clonedHash = sol.copyRandomListHashMap(head);
    cout << "Cloned List (HashMap method):\n";
    printList(clonedHash);

    Node* clonedInterweave = sol.copyRandomListInterweave(head);
    cout << "Cloned List (Interweave method):\n";
    printList(clonedInterweave);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 -> 2 -> 3
Random: 1.random->3, 2.random->1, 3.random->2

Interweaving method steps:
Step 1: Insert clones
1 -> 1' -> 2 -> 2' -> 3 -> 3'

Step 2: Assign randoms
- 1'.random = 1.random->next = 3
- 2'.random = 2.random->next = 1
- 3'.random = 3.random->next = 2

Step 3: Separate lists
Original restored: 1->2->3
Cloned list: 1'->2'->3', with same next and random as original

```

---

## **Question: 33 Design Browser History Linked List implementation**

**Approach:**
PROBLEM STATEMENT:
Design a browser history system with the following functionality:

1. visit(url): Visits a new URL from the current page. Clears forward history.
2. back(steps): Moves back by steps and returns the current page.
3. forward(steps): Moves forward by steps and returns the current page.

Constraints:

- There is an initial homepage at creation.
- If steps exceed available history, stop at first/last page.

---

APPROACH (Linked List Implementation):

1. Each page is represented as a node in a doubly linked list:
   - prev points to previous page
   - next points to next page
2. Maintain a current pointer to track current page.
3. visit(url):
   - Create a new node with url.
   - Set current->next = new node.
   - new node->prev = current.
   - Move current to new node.
   - Forward history (old current->next) is discarded.
4. back(steps):
   - Move current = current->prev up to steps times.
   - Stop at head if steps exceed.
5. forward(steps):
   - Move current = current->next up to steps times.
   - Stop at last page if steps exceed.

Time Complexity: O(steps) per back/forward, O(1) for visit  
Space Complexity: O(n) for n visited pages

**Code:**

```cpp
#include <iostream>
#include <string>
using namespace std;

// Doubly Linked List Node
struct Node {
    string url;
    Node* prev;
    Node* next;
    Node(string u) : url(u), prev(NULL), next(NULL) {}
};

class BrowserHistory {
private:
    Node* current;  // pointer to current page
public:
    // Constructor with homepage
    BrowserHistory(string homepage) {
        current = new Node(homepage); // initial page
    }

    // Visit a new page
    void visit(string url) {
        Node* newNode = new Node(url);    // create new node
        current->next = newNode;          // link current->next to new page
        newNode->prev = current;          // link new page->prev to current
        current = newNode;                // move current pointer to new page
    }

    // Move back 'steps' pages
    string back(int steps) {
        while (steps-- && current->prev) {
            current = current->prev;      // move current pointer backward
        }
        return current->url;              // return current page
    }

    // Move forward 'steps' pages
    string forward(int steps) {
        while (steps-- && current->next) {
            current = current->next;      // move current pointer forward
        }
        return current->url;              // return current page
    }
};

// -------------------------
// Driver Code
// -------------------------
int main() {
    BrowserHistory browser("leetcode.com"); // homepage

    browser.visit("google.com");    // visit google
    browser.visit("facebook.com");  // visit facebook
    browser.visit("youtube.com");   // visit youtube

    cout << browser.back(1) << endl;    // move back 1 step → facebook.com
    cout << browser.back(1) << endl;    // move back 1 step → google.com
    cout << browser.forward(1) << endl; // move forward 1 step → facebook.com

    browser.visit("linkedin.com");      // visit linkedin, forward history cleared
    cout << browser.forward(2) << endl; // cannot move forward → linkedin.com
    cout << browser.back(2) << endl;    // move back 2 steps → google.com
    cout << browser.back(7) << endl;    // move back beyond start → leetcode.com

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Homepage: leetcode.com

Step 1: visit google.com → current = google.com
Step 2: visit facebook.com → current = facebook.com
Step 3: visit youtube.com → current = youtube.com

Step 4: back(1) → move to facebook.com
Step 5: back(1) → move to google.com
Step 6: forward(1) → move to facebook.com

Step 7: visit linkedin.com → forward history (youtube.com) cleared → current = linkedin.com
Step 8: forward(2) → cannot move forward → current = linkedin.com
Step 9: back(2) → move to google.com
Step 10: back(7) → move to start → leetcode.com

```

---

## **Question: 34 Check if Linked List is palindrome Slow-Fast + Reverse second half**

**Approach:**
PROBLEM STATEMENT:
Given the head of a singly linked list, determine if it is a palindrome.
Return true if it is, false otherwise.

Example 1:
Input: 1 → 2 → 2 → 1
Output: true

Example 2:
Input: 1 → 2
Output: false

---

APPROACH:

1. Find the middle of the linked list using slow-fast pointers:
   - Slow moves 1 step, fast moves 2 steps.
   - When fast reaches end, slow is at middle.
2. Reverse the second half of the list starting from slow.
3. Compare first half and reversed second half node by node.
4. Restore the list (optional) by reversing the second half again.
5. Return true if all matched, false if mismatch found.

Time Complexity: O(n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    // Reverse linked list starting from head
    ListNode* reverse(ListNode* head) {
        ListNode* prev = NULL;
        ListNode* curr = head;
        while (curr) {
            ListNode* nextNode = curr->next; // store next node
            curr->next = prev;               // reverse pointer
            prev = curr;                     // move prev forward
            curr = nextNode;                 // move curr forward
        }
        return prev; // new head of reversed list
    }

    bool isPalindrome(ListNode* head) {
        if (!head || !head->next) return true; // single node or empty

        // Step 1: Find middle
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            slow = slow->next;       // move 1 step
            fast = fast->next->next; // move 2 steps
        }

        // Step 2: Reverse second half
        ListNode* secondHalf = reverse(slow->next);

        // Step 3: Compare first and second halves
        ListNode* firstHalf = head;
        ListNode* tempSecond = secondHalf;
        bool palindrome = true;
        while (tempSecond) {
            if (firstHalf->val != tempSecond->val) {
                palindrome = false;
                break;
            }
            firstHalf = firstHalf->next;
            tempSecond = tempSecond->next;
        }

        // Step 4 (Optional): Restore list
        slow->next = reverse(secondHalf);

        return palindrome;
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(vector<int> arr) {
    if (arr.empty()) return NULL;
    ListNode* head = new ListNode(arr[0]);
    ListNode* curr = head;
    for (int i = 1; i < arr.size(); i++) {
        curr->next = new ListNode(arr[i]);
        curr = curr->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    vector<int> arr = {1, 2, 2, 1};
    ListNode* head = createList(arr);

    Solution sol;
    bool result = sol.isPalindrome(head);
    cout << "Is Palindrome? " << (result ? "True" : "False") << endl; // True

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 2 → 1

Step 1: Find middle
- slow = 2 (second node), fast = end
- slow points at first 2

Step 2: Reverse second half
- Second half before reverse: 2 → 1
- After reverse: 1 → 2

Step 3: Compare halves
- First half: 1 → 2
- Second half: 1 → 2
- Compare nodes one by one → all match

Step 4: (Optional) Restore list
- Reverse second half again → original list restored

Result: True

```

---

## **Question: 35 Remove Nth node from end Two-pointer / dummy node**

**Approach:**
PROBLEM STATEMENT:
Given the head of a singly linked list and an integer n,
remove the n-th node from the end of the list and return its head.

Example 1:
Input: 1 → 2 → 3 → 4 → 5, n = 2
Output: 1 → 2 → 3 → 5

Example 2:
Input: 1, n = 1
Output: NULL

---

APPROACH (Two-pointer + Dummy Node):

1. Create a dummy node before head to handle edge cases (like removing head).
2. Initialize two pointers: first and second, both pointing to dummy.
3. Move first pointer n+1 steps ahead.
4. Move first and second together until first reaches NULL.
5. Now, second points to node before the target node.
6. Remove target node: second->next = second->next->next.
7. Return dummy->next as the new head.

Time Complexity: O(L) where L is the length of list  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0); // create dummy before head
        dummy->next = head;

        ListNode* first = dummy;
        ListNode* second = dummy;

        // Step 1: Move first pointer n+1 steps ahead
        for (int i = 0; i <= n; i++) {
            first = first->next;
        }

        // Step 2: Move first and second together
        while (first) {
            first = first->next;
            second = second->next;
        }

        // Step 3: Remove target node
        ListNode* toDelete = second->next; // node to remove
        second->next = second->next->next; // bypass node
        delete toDelete;                   // free memory

        return dummy->next; // return new head
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(vector<int> arr) {
    if (arr.empty()) return NULL;
    ListNode* head = new ListNode(arr[0]);
    ListNode* curr = head;
    for (int i = 1; i < arr.size(); i++) {
        curr->next = new ListNode(arr[i]);
        curr = curr->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    ListNode* head = createList(arr);

    Solution sol;
    int n = 2;
    ListNode* newHead = sol.removeNthFromEnd(head, n);

    cout << "List after removing " << n << "-th node from end: ";
    printList(newHead); // Expected: 1 -> 2 -> 3 -> 5

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 3 → 4 → 5, n = 2

Step 1: Create dummy → 0 → 1 → 2 → 3 → 4 → 5
Step 2: Move first pointer n+1=3 steps → first points to 3
Step 3: Move first & second together until first reaches NULL
- first=3, second=0
- first=4, second=1
- first=5, second=2
- first=NULL, second=3

Step 4: Remove second->next → second points to 3, second->next = 4
- Bypass 4 → 3->next = 5

Final list: 1 → 2 → 3 → 5

```

---

## **Question: 36 Delete middle node Slow-Fast pointer**

**Approach:**
PROBLEM STATEMENT:
Given the head of a singly linked list, delete the middle node and return the head.

- If the list has even number of nodes, delete the second middle node.

Example 1:
Input: 1 → 2 → 3 → 4 → 5
Output: 1 → 2 → 4 → 5

Example 2:
Input: 1 → 2 → 3 → 4
Output: 1 → 2 → 4

---

APPROACH (Slow-Fast pointer):

1. Handle edge case: if list has only 1 node, return NULL.
2. Initialize two pointers: slow and fast at head, and a prev pointer before slow.
3. Move fast 2 steps and slow 1 step until fast reaches end.
4. prev now points to node before middle (slow).
5. Delete slow: prev->next = slow->next.
6. Free slow node memory.
7. Return head.

Time Complexity: O(n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        if (!head || !head->next) return NULL; // if 0 or 1 node, return NULL

        ListNode* slow = head;
        ListNode* fast = head;
        ListNode* prev = NULL; // to keep track of node before slow

        // Step 1: Find middle using slow-fast
        while (fast && fast->next) {
            prev = slow;          // store previous node
            slow = slow->next;    // move slow 1 step
            fast = fast->next->next; // move fast 2 steps
        }

        // Step 2: Delete middle node
        prev->next = slow->next; // bypass middle
        delete slow;             // free memory

        return head;
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(vector<int> arr) {
    if (arr.empty()) return NULL;
    ListNode* head = new ListNode(arr[0]);
    ListNode* curr = head;
    for (int i = 1; i < arr.size(); i++) {
        curr->next = new ListNode(arr[i]);
        curr = curr->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    ListNode* head = createList(arr);

    Solution sol;
    ListNode* newHead = sol.deleteMiddle(head);

    cout << "List after deleting middle node: ";
    printList(newHead); // Expected: 1 -> 2 -> 4 -> 5

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 3 → 4 → 5

Step 1: Initialize slow=head=1, fast=head=1, prev=NULL
Step 2: Move pointers:
- fast=3, slow=2, prev=1
- fast=5, slow=3, prev=2
- fast=NULL → stop

Step 3: Delete middle
- prev=2, slow=3
- prev->next = slow->next → 2->next=4
- Delete node 3

Final list: 1 → 2 → 4 → 5

```

---

## **Question: 37 Find all pairs with given sum in DLL Two-pointer technique**

**Approach:**
PROBLEM STATEMENT:
Given a sorted doubly linked list and an integer sum,
find all pairs of nodes whose values add up to the given sum.

Example:
Input: 1 ⇄ 2 ⇄ 4 ⇄ 5 ⇄ 6 ⇄ 8 ⇄ 9, sum = 7
Output: (1,6), (2,5), (3,4)

---

APPROACH (Two-pointer technique):

1. Initialize two pointers:
   - left = head (start of DLL)
   - right = tail (end of DLL)
2. Traverse while left != right and left->prev != right:
   - If left->val + right->val == sum → store pair, move both pointers
   - If sum < target → move left forward
   - If sum > target → move right backward
3. Continue until pointers meet or cross.

Time Complexity: O(n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Definition for doubly linked list
struct Node {
    int val;
    Node* next;
    Node* prev;
    Node(int x) : val(x), next(NULL), prev(NULL) {}
};

class Solution {
public:
    vector<pair<int,int>> findPairsWithSum(Node* head, int target) {
        vector<pair<int,int>> result;
        if (!head) return result;

        // Step 1: Find tail of DLL
        Node* tail = head;
        while (tail->next) tail = tail->next;

        Node* left = head; // start pointer
        Node* right = tail; // end pointer

        // Step 2: Two-pointer traversal
        while (left != right && left->prev != right) {
            int sum = left->val + right->val;
            if (sum == target) {
                result.push_back({left->val, right->val}); // store pair
                left = left->next;   // move left forward
                right = right->prev; // move right backward
            } else if (sum < target) {
                left = left->next;   // need larger sum
            } else {
                right = right->prev; // need smaller sum
            }
        }

        return result;
    }
};

// -------------------------
// Helper functions
// -------------------------
Node* createDLL(vector<int> arr) {
    if (arr.empty()) return NULL;
    Node* head = new Node(arr[0]);
    Node* curr = head;
    for (int i = 1; i < arr.size(); i++) {
        Node* node = new Node(arr[i]);
        curr->next = node;
        node->prev = curr;
        curr = node;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    vector<int> arr = {1, 2, 4, 5, 6, 8, 9};
    Node* head = createDLL(arr);
    int target = 7;

    Solution sol;
    vector<pair<int,int>> pairs = sol.findPairsWithSum(head, target);

    cout << "Pairs with sum " << target << ": ";
    for (auto &p : pairs) {
        cout << "(" << p.first << "," << p.second << ") ";
    }
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input DLL: 1 ⇄ 2 ⇄ 4 ⇄ 5 ⇄ 6 ⇄ 8 ⇄ 9, target = 7

Step 1: Initialize left=head=1, right=tail=9

Step 2: Traverse
- left=1, right=9 → sum=10 >7 → move right backward → right=8
- left=1, right=8 → sum=9 >7 → right=6
- left=1, right=6 → sum=7 → store (1,6), left=2, right=5
- left=2, right=5 → sum=7 → store (2,5), left=4, right=4 → stop

Final pairs: (1,6), (2,5)

```

---

## **Question: 38 Flattening a multilevel Linked List Recursion / Iteration**

**Approach:**
PROBLEM STATEMENT:
Given a linked list where each node has:

- next pointer to the next node
- child pointer to another linked list (may be NULL)

Flatten the list so that all nodes appear in a single-level linked list,
preserving the order.

Example:
Input:
1 - 2 - 3
|
4 - 5
Output:
1 - 2 - 4 - 5 - 3

---

APPROACH:

Method 1: Recursion

1. Start from head and traverse nodes.
2. If a node has a child:
   - Recursively flatten the child list.
   - Insert the flattened child between current node and current->next.
   - Update tail of flattened child to point to current->next.
   - Set current->child = NULL.
3. Continue traversal until end of list.

Time Complexity: O(n)  
Space Complexity: O(depth) recursion stack

Method 2: Iteration (Using stack)

1. Use a stack to store next pointers before going to child.
2. Traverse the list:
   - If node has a child:
     - If node->next exists, push it onto stack.
     - Set node->next = child, child->prev = node, child=NULL
   - If node->next is NULL and stack not empty, pop from stack and connect.
3. Continue until all nodes are connected in one level.

**Code:**

```cpp
#include <iostream>
#include <stack>
using namespace std;

// Definition for multilevel linked list node
struct Node {
    int val;
    Node* next;
    Node* child;
    Node(int x) : val(x), next(NULL), child(NULL) {}
};

class Solution {
public:
    // Recursive approach
    Node* flattenRecursive(Node* head) {
        if (!head) return NULL;

        Node* curr = head;
        while (curr) {
            if (curr->child) {
                Node* nextNode = curr->next;           // store next
                Node* childHead = flattenRecursive(curr->child); // flatten child
                curr->next = childHead;                // link child
                curr->child = NULL;                    // remove child pointer

                Node* tail = childHead;
                while (tail->next) tail = tail->next;  // find tail of flattened child
                tail->next = nextNode;                 // connect tail to next
            }
            curr = curr->next; // move forward
        }
        return head;
    }

    // Iterative approach using stack
    Node* flattenIterative(Node* head) {
        if (!head) return NULL;

        stack<Node*> st;
        Node* curr = head;

        while (curr) {
            if (curr->child) {
                if (curr->next) st.push(curr->next); // save next node
                curr->next = curr->child;           // link child as next
                curr->child = NULL;                 // remove child pointer
            }
            if (!curr->next && !st.empty()) {
                curr->next = st.top(); st.pop();   // pop from stack
            }
            curr = curr->next;                     // move forward
        }
        return head;
    }
};

// -------------------------
// Helper functions
// -------------------------
Node* createList(vector<int> vals) {
    if (vals.empty()) return NULL;
    Node* head = new Node(vals[0]);
    Node* curr = head;
    for (int i = 1; i < vals.size(); i++) {
        curr->next = new Node(vals[i]);
        curr = curr->next;
    }
    return head;
}

void printList(Node* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->child = new Node(4);
    head->next->child->next = new Node(5);

    Solution sol;
    Node* flattened = sol.flattenRecursive(head);
    cout << "Flattened List (Recursive): ";
    printList(flattened);

    // For iterative, recreate list
    head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->child = new Node(4);
    head->next->child->next = new Node(5);

    Node* flattenedIter = sol.flattenIterative(head);
    cout << "Flattened List (Iterative): ";
    printList(flattenedIter);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 - 2 - 3
           |
           4 - 5

Step 1: Start at 1 → no child → move to 2
Step 2: Node 2 has child → flatten 4-5 → insert between 2 and 3
- 2->next = 4
- 4->next = 5
- 5->next = 3
- remove 2->child

Step 3: Move to 4 → no child → move to 5 → no child → move to 3 → no child → end

Output flattened list: 1 → 2 → 4 → 5 → 3

```

---

## **Question: 39 Count occurrences of a key in Linked List Traversal**

**Approach:**
PROBLEM STATEMENT:
Given the head of a singly linked list and an integer key,
count how many times the key occurs in the linked list.

Example:
Input: 1 → 2 → 3 → 2 → 4 → 2, key = 2
Output: 3

---

APPROACH (Traversal):

1. Initialize a counter to 0.
2. Traverse the linked list from head to end:
   - If current node's value == key, increment counter.
3. After traversal, return counter.

Time Complexity: O(n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    int countOccurrences(ListNode* head, int key) {
        int count = 0;               // initialize counter
        ListNode* curr = head;       // start from head
        while (curr) {               // traverse until end
            if (curr->val == key) {  // check if node matches key
                count++;             // increment counter
            }
            curr = curr->next;       // move to next node
        }
        return count;                // return total occurrences
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(vector<int> arr) {
    if (arr.empty()) return NULL;
    ListNode* head = new ListNode(arr[0]);
    ListNode* curr = head;
    for (int i = 1; i < arr.size(); i++) {
        curr->next = new ListNode(arr[i]);
        curr = curr->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    vector<int> arr = {1, 2, 3, 2, 4, 2};
    ListNode* head = createList(arr);

    Solution sol;
    int key = 2;
    int occurrences = sol.countOccurrences(head, key);

    cout << "Number of occurrences of " << key << ": " << occurrences << endl; // Expected: 3

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 3 → 2 → 4 → 2, key = 2

Step 1: Initialize count = 0
Step 2: Traverse:
- Node 1 → not key → count = 0
- Node 2 → key → count = 1
- Node 3 → not key → count = 1
- Node 2 → key → count = 2
- Node 4 → not key → count = 2
- Node 2 → key → count = 3

Output: 3

```

---

## **Question: 40 Reverse print Linked List Recursion / Stack**

**Approach:**
40 Reverse print Linked List Recursion / Stack

**Code:**

```cpp
#include <iostream>
#include <stack>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    // Method 1: Recursion
    void reversePrintRecursive(ListNode* head) {
        if (!head) return;             // base case
        reversePrintRecursive(head->next); // recursive call
        cout << head->val << " ";      // print after recursion
    }

    // Method 2: Using stack
    void reversePrintStack(ListNode* head) {
        stack<int> st;
        ListNode* curr = head;
        while (curr) {                 // traverse list
            st.push(curr->val);        // push value onto stack
            curr = curr->next;         // move forward
        }
        while (!st.empty()) {          // print in reverse
            cout << st.top() << " ";
            st.pop();
        }
    }
};

// -------------------------
// Helper functions
// -------------------------
ListNode* createList(vector<int> arr) {
    if (arr.empty()) return NULL;
    ListNode* head = new ListNode(arr[0]);
    ListNode* curr = head;
    for (int i = 1; i < arr.size(); i++) {
        curr->next = new ListNode(arr[i]);
        curr = curr->next;
    }
    return head;
}

// -------------------------
// Driver Code
// -------------------------
int main() {
    vector<int> arr = {1, 2, 3, 4};
    ListNode* head = createList(arr);

    Solution sol;

    cout << "Reverse Print (Recursive): ";
    sol.reversePrintRecursive(head);
    cout << endl;

    cout << "Reverse Print (Stack): ";
    sol.reversePrintStack(head);
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 1 → 2 → 3 → 4

Method 1: Recursion
- Call reversePrintRecursive(1)
  - Call reversePrintRecursive(2)
    - Call reversePrintRecursive(3)
      - Call reversePrintRecursive(4)
        - Call reversePrintRecursive(NULL) → return
      - Print 4
    - Print 3
  - Print 2
- Print 1
Output: 4 3 2 1

Method 2: Stack
- Push 1,2,3,4 onto stack → stack top = 4
- Pop 4 → print 4
- Pop 3 → print 3
- Pop 2 → print 2
- Pop 1 → print 1
Output: 4 3 2 1

```

---
