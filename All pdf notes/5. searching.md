## **Question: 1 Find element in unsorted array Linear search**

**Approach:**
Question: Find Element in Unsorted Array

Approach:
We are given an unsorted array and a target element. We need to find whether the element exists in the array.

Steps:

1. Traverse the array from start to end.
2. Compare each element with the target.
3. If a match is found, return its index (or true if only existence is needed).
4. If the end is reached without finding the element, return -1 (or false).

Time Complexity: O(n) → need to check all elements in worst case
Space Complexity: O(1) → no extra space required

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to search an element in unsorted array
int linearSearch(const vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); i++) { // Traverse array
        if (arr[i] == target) {            // Compare with target
            return i;                      // Element found
        }
    }
    return -1;                             // Element not found
}

int main() {
    vector<int> arr = {5, 3, 7, 1, 9};
    int target = 7;

    int index = linearSearch(arr, target);
    if (index != -1)
        cout << "Element " << target << " found at index " << index << endl;
    else
        cout << "Element not found" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [5, 3, 7, 1, 9], target = 7
Step 1: arr[0]=5 → not equal → continue
Step 2: arr[1]=3 → not equal → continue
Step 3: arr[2]=7 → equal → return 2
Output: Element 7 found at index 2

```

---

## **Question: 2 Find first occurrence of an element Linear search**

**Approach:**
Question: Find First Occurrence of an Element in an Array

Approach:
We are given an array and a target element. We need to find the index of the first occurrence of the target.

Steps:

1. Traverse the array from start to end.
2. Compare each element with the target.
3. As soon as the target is found, return its index.
4. If the end is reached without finding the element, return -1.

Time Complexity: O(n) → worst case traverse all elements
Space Complexity: O(1) → no extra space required

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find first occurrence of an element
int firstOccurrence(const vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); i++) { // Traverse the array
        if (arr[i] == target) {            // Check if element equals target
            return i;                      // First occurrence found
        }
    }
    return -1;                             // Target not found
}

int main() {
    vector<int> arr = {5, 3, 7, 3, 9, 3};
    int target = 3;

    int index = firstOccurrence(arr, target);
    if (index != -1)
        cout << "First occurrence of " << target << " is at index " << index << endl;
    else
        cout << "Element not found" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [5, 3, 7, 3, 9, 3], target = 3
Step 1: arr[0]=5 → not equal → continue
Step 2: arr[1]=3 → equal → return 1
Output: First occurrence of 3 is at index 1

```

---

## **Question: 3 Find last occurrence of an element Linear search**

**Approach:**
Question: Find Last Occurrence of an Element in an Array

Approach:
We are given an array and a target element. We need to find the index of the last occurrence of the target.

Steps:

1. Traverse the array from start to end.
2. Keep track of the index whenever an element equals the target.
3. Continue until the end of the array to ensure the last occurrence is captured.
4. If the target was never found, return -1.

Time Complexity: O(n) → traverse all elements in worst case
Space Complexity: O(1) → no extra space required

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find last occurrence of an element
int lastOccurrence(const vector<int>& arr, int target) {
    int index = -1; // Initialize to -1, meaning not found
    for (int i = 0; i < arr.size(); i++) { // Traverse the array
        if (arr[i] == target) {            // Check if element equals target
            index = i;                     // Update index
        }
    }
    return index;                           // Return last occurrence or -1
}

int main() {
    vector<int> arr = {5, 3, 7, 3, 9, 3};
    int target = 3;

    int index = lastOccurrence(arr, target);
    if (index != -1)
        cout << "Last occurrence of " << target << " is at index " << index << endl;
    else
        cout << "Element not found" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [5, 3, 7, 3, 9, 3], target = 3
Step 1: arr[0]=5 → not equal → index=-1
Step 2: arr[1]=3 → equal → index=1
Step 3: arr[2]=7 → not equal → index=1
Step 4: arr[3]=3 → equal → index=3
Step 5: arr[4]=9 → not equal → index=3
Step 6: arr[5]=3 → equal → index=5
Output: Last occurrence of 3 is at index 5

```

---

## **Question: 4 Count frequency of a given element Linear search**

**Approach:**
Question: Count Frequency of a Given Element in an Array

Approach:
We are given an array and a target element. We need to count how many times the target occurs.

Steps:

1. Initialize a counter to 0.
2. Traverse the array from start to end.
3. For each element, check if it is equal to the target.
4. If yes, increment the counter.
5. After traversal, return the counter as the frequency.

Time Complexity: O(n) → need to check all elements in worst case
Space Complexity: O(1) → no extra space required

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to count frequency of a target element
int countFrequency(const vector<int>& arr, int target) {
    int count = 0;                         // Initialize counter
    for (int i = 0; i < arr.size(); i++) { // Traverse the array
        if (arr[i] == target) {            // Check if element equals target
            count++;                        // Increment counter
        }
    }
    return count;                           // Return frequency
}

int main() {
    vector<int> arr = {5, 3, 7, 3, 9, 3};
    int target = 3;

    int freq = countFrequency(arr, target);
    cout << "Frequency of " << target << " is " << freq << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [5, 3, 7, 3, 9, 3], target = 3
Step 1: arr[0]=5 → not equal → count=0
Step 2: arr[1]=3 → equal → count=1
Step 3: arr[2]=7 → not equal → count=1
Step 4: arr[3]=3 → equal → count=2
Step 5: arr[4]=9 → not equal → count=2
Step 6: arr[5]=3 → equal → count=3
Output: Frequency of 3 is 3

```

---

## **Question: 5 Find minimum element Linear search**

**Approach:**
Question: Find Minimum Element in an Array

Approach:
We are given an array and we need to find the minimum element.

Steps:

1. Initialize a variable minVal with the first element of the array.
2. Traverse the array from the second element to the end.
3. For each element, compare it with minVal.
4. If the element is smaller than minVal, update minVal.
5. After traversal, minVal will contain the minimum element.

Time Complexity: O(n) → need to check all elements in worst case
Space Complexity: O(1) → no extra space required

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find minimum element in an array
int findMinimum(const vector<int>& arr) {
    if (arr.empty()) return -1; // Handle empty array

    int minVal = arr[0];                  // Initialize min with first element
    for (int i = 1; i < arr.size(); i++) { // Traverse rest of the array
        if (arr[i] < minVal) {            // Compare current element with minVal
            minVal = arr[i];              // Update minVal if smaller
        }
    }
    return minVal;                        // Return minimum element
}

int main() {
    vector<int> arr = {5, 3, 7, 1, 9};

    int minElement = findMinimum(arr);
    if (minElement != -1)
        cout << "Minimum element is " << minElement << endl;
    else
        cout << "Array is empty" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [5, 3, 7, 1, 9]
Step 1: minVal=5
Step 2: arr[1]=3 → 3<5 → minVal=3
Step 3: arr[2]=7 → 7>3 → minVal=3
Step 4: arr[3]=1 → 1<3 → minVal=1
Step 5: arr[4]=9 → 9>1 → minVal=1
Output: Minimum element is 1

```

---

## **Question: Title**

**Approach:**
Question: Find Maximum Element in an Array

Approach:
We are given an array and need to find the maximum element.

Steps:

1. Initialize a variable maxVal with the first element of the array.
2. Traverse the array from the second element to the end.
3. For each element, compare it with maxVal.
4. If the element is greater than maxVal, update maxVal.
5. After traversal, maxVal will contain the maximum element.

Time Complexity: O(n) → need to check all elements in worst case
Space Complexity: O(1) → no extra space required

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find maximum element in an array
int findMaximum(const vector<int>& arr) {
    if (arr.empty()) return -1; // Handle empty array

    int maxVal = arr[0];                   // Initialize max with first element
    for (int i = 1; i < arr.size(); i++) { // Traverse rest of the array
        if (arr[i] > maxVal) {             // Compare current element with maxVal
            maxVal = arr[i];               // Update maxVal if greater
        }
    }
    return maxVal;                         // Return maximum element
}

int main() {
    vector<int> arr = {5, 3, 7, 1, 9};

    int maxElement = findMaximum(arr);
    if (maxElement != -1)
        cout << "Maximum element is " << maxElement << endl;
    else
        cout << "Array is empty" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [5, 3, 7, 1, 9]
Step 1: maxVal=5
Step 2: arr[1]=3 → 3<5 → maxVal=5
Step 3: arr[2]=7 → 7>5 → maxVal=7
Step 4: arr[3]=1 → 1<7 → maxVal=7
Step 5: arr[4]=9 → 9>7 → maxVal=9
Output: Maximum element is 9

```

---

## **Question: 7 Check if array is sorted Linear scan**

**Approach:**
Question: Check if an Array is Sorted

Approach:
We are given an array and need to determine whether it is sorted in non-decreasing order.

Steps:

1. Traverse the array from the first element to the second last element.
2. Compare each element with the next element.
3. If any element is greater than the next element, the array is not sorted → return false.
4. If the traversal completes without finding any such pair, the array is sorted → return true.

Time Complexity: O(n) → traverse all elements in worst case
Space Complexity: O(1) → no extra space required

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to check if an array is sorted in non-decreasing order
bool isSorted(const vector<int>& arr) {
    for (int i = 0; i < arr.size() - 1; i++) { // Traverse array
        if (arr[i] > arr[i + 1]) {             // Compare current with next
            return false;                      // Not sorted
        }
    }
    return true;                               // Sorted
}

int main() {
    vector<int> arr1 = {1, 2, 2, 4, 5};
    vector<int> arr2 = {5, 3, 7, 1};

    cout << "Array 1 sorted? " << (isSorted(arr1) ? "Yes" : "No") << endl;
    cout << "Array 2 sorted? " << (isSorted(arr2) ? "Yes" : "No") << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array 1: [1, 2, 2, 4, 5]
Step 1: 1 <= 2 → OK
Step 2: 2 <= 2 → OK
Step 3: 2 <= 4 → OK
Step 4: 4 <= 5 → OK
Output: Yes

Array 2: [5, 3, 7, 1]
Step 1: 5 <= 3 → No
Output: No

```

---

## **Question: 8 Linear search with sentinel Optimization trick**

**Approach:**
Question: Linear Search with Sentinel

Approach:
Linear search can be optimized by using a "sentinel" to avoid checking array bounds in each iteration.

Steps:

1. Append the target element at the end of the array (sentinel).
2. Traverse the array from start:
   - Compare each element with the target.
3. If the element is found before the last index, return its index.
4. If only the sentinel (last element) matches, the target is not in the original array → return -1.

Advantages:

- Avoids the need for `i < n` check in every iteration.
- Slightly faster for large arrays.

Time Complexity: O(n) → worst case traverse all elements
Space Complexity: O(1) → only temporary variable, original array modified temporarily

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to perform linear search with sentinel
int linearSearchSentinel(vector<int>& arr, int target) {
    int n = arr.size();
    arr.push_back(target);                  // Append sentinel
    int i = 0;

    // Loop until we find the target
    while (arr[i] != target) {
        i++;
    }

    arr.pop_back();                         // Remove sentinel to restore array

    if (i == n)                             // If index reached original size → not found
        return -1;
    return i;                               // Found at index i
}

int main() {
    vector<int> arr = {5, 3, 7, 1, 9};
    int target1 = 7, target2 = 4;

    cout << "Index of " << target1 << ": " << linearSearchSentinel(arr, target1) << endl;
    cout << "Index of " << target2 << ": " << linearSearchSentinel(arr, target2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [5, 3, 7, 1, 9], target = 7
Step 1: Append 7 → [5, 3, 7, 1, 9, 7]
Step 2: i=0 → 5!=7 → i=1
Step 3: i=1 → 3!=7 → i=2
Step 4: i=2 → 7==7 → found → pop sentinel → return 2
Output: Index of 7: 2

Target = 4
Step 1: Append 4 → [5,3,7,1,9,4]
Step 2: i=0 → 5!=4 → i=1
Step 3: i=1 → 3!=4 → i=2
Step 4: i=2 → 7!=4 → i=3
Step 5: i=3 → 1!=4 → i=4
Step 6: i=4 → 9!=4 → i=5
Step 7: i=5 → 4==4 → reached sentinel → pop → return -1
Output: Index of 4: -1

```

---

## **Question: 9 Search in a rotated sorted array (small array) Brute-force**

**Approach:**
Question: Search in a Rotated Sorted Array (Brute-force)

Approach:
We are given a sorted array rotated at some pivot. We need to find the index of a target element using brute-force.

Steps:

1. Traverse the array from start to end.
2. Compare each element with the target.
3. If the element matches the target, return its index.
4. If the end is reached without a match, return -1.

Note:

- This is the brute-force approach.
- Time Complexity: O(n) → linear scan
- Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to search in a rotated sorted array using brute-force
int searchRotatedBruteForce(const vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); i++) { // Traverse array
        if (arr[i] == target) {            // Compare with target
            return i;                      // Found
        }
    }
    return -1;                             // Not found
}

int main() {
    vector<int> arr = {4, 5, 6, 7, 0, 1, 2};
    int target1 = 0, target2 = 3;

    cout << "Index of " << target1 << ": " << searchRotatedBruteForce(arr, target1) << endl;
    cout << "Index of " << target2 << ": " << searchRotatedBruteForce(arr, target2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [4, 5, 6, 7, 0, 1, 2], target = 0
Step 1: i=0 → arr[0]=4 → not equal
Step 2: i=1 → arr[1]=5 → not equal
Step 3: i=2 → arr[2]=6 → not equal
Step 4: i=3 → arr[3]=7 → not equal
Step 5: i=4 → arr[4]=0 → equal → return 4
Output: Index of 0: 4

Target = 3
Traverse all → not found → return -1
Output: Index of 3: -1

```

---

## **Question: 10 Search in sorted array (binary search classic) Binary search**

**Approach:**
Question: Search in a Sorted Array Using Binary Search

Approach:
We are given a sorted array and a target element. We need to find its index using binary search.

Steps:

1. Initialize two pointers: low = 0, high = n-1.
2. While low <= high:
   a. Compute mid = low + (high - low)/2.
   b. If arr[mid] == target → return mid.
   c. If arr[mid] < target → search right half (low = mid + 1).
   d. If arr[mid] > target → search left half (high = mid - 1).
3. If loop ends without finding target → return -1.

Time Complexity: O(log n) → binary search
Space Complexity: O(1) → iterative approach

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to search in a sorted array using binary search
int binarySearch(const vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;

    while (low <= high) {                 // Loop until pointers cross
        int mid = low + (high - low) / 2; // Prevent overflow

        if (arr[mid] == target)           // Target found
            return mid;
        else if (arr[mid] < target)       // Search right half
            low = mid + 1;
        else                              // Search left half
            high = mid - 1;
    }
    return -1;                             // Target not found
}

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    int target1 = 7, target2 = 4;

    cout << "Index of " << target1 << ": " << binarySearch(arr, target1) << endl;
    cout << "Index of " << target2 << ": " << binarySearch(arr, target2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [1, 3, 5, 7, 9, 11], target = 7
Step 1: low=0, high=5, mid=2 → arr[2]=5 < 7 → low=3
Step 2: low=3, high=5, mid=4 → arr[4]=9 > 7 → high=3
Step 3: low=3, high=3, mid=3 → arr[3]=7 == 7 → return 3
Output: Index of 7: 3

Target = 4
Step 1: low=0, high=5, mid=2 → arr[2]=5 > 4 → high=1
Step 2: low=0, high=1, mid=0 → arr[0]=1 < 4 → low=1
Step 3: low=1, high=1, mid=1 → arr[1]=3 < 4 → low=2
Step 4: low > high → return -1
Output: Index of 4: -1

```

---

## **Question: 11 First occurrence in sorted array Binary search variant**

**Approach:**
Question: Find First Occurrence of an Element in a Sorted Array Using Binary Search

Approach:
We are given a sorted array and a target element. We need to find the index of the first occurrence using binary search.

Steps:

1. Initialize low = 0, high = n-1, result = -1.
2. While low <= high:
   a. Compute mid = low + (high - low)/2.
   b. If arr[mid] == target → update result = mid, move left half (high = mid - 1) to find first occurrence.
   c. If arr[mid] < target → search right half (low = mid + 1).
   d. If arr[mid] > target → search left half (high = mid - 1).
3. Return result.

Time Complexity: O(log n)
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find first occurrence in sorted array
int firstOccurrenceSorted(const vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    int result = -1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == target) {
            result = mid;      // Update first occurrence
            high = mid - 1;    // Move left to find earlier occurrence
        } else if (arr[mid] < target) {
            low = mid + 1;     // Move right
        } else {
            high = mid - 1;    // Move left
        }
    }

    return result;            // Return index or -1
}

int main() {
    vector<int> arr = {1, 2, 2, 2, 3, 4, 5};
    int target1 = 2, target2 = 6;

    cout << "First occurrence of " << target1 << ": " << firstOccurrenceSorted(arr, target1) << endl;
    cout << "First occurrence of " << target2 << ": " << firstOccurrenceSorted(arr, target2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [1, 2, 2, 2, 3, 4, 5], target = 2
Step 1: low=0, high=6, mid=3 → arr[3]=2 == target → result=3, high=2
Step 2: low=0, high=2, mid=1 → arr[1]=2 == target → result=1, high=0
Step 3: low=0, high=0, mid=0 → arr[0]=1 < 2 → low=1
Step 4: low > high → return result=1
Output: First occurrence of 2: 1

Target = 6
Traverse → no match → return -1
Output: First occurrence of 6: -1

```

---

## **Question: 12 Last occurrence in sorted array Binary search variant**

**Approach:**
Question: Find Last Occurrence of an Element in a Sorted Array Using Binary Search

Approach:
We are given a sorted array and a target element. We need to find the index of the last occurrence using binary search.

Steps:

1. Initialize low = 0, high = n-1, result = -1.
2. While low <= high:
   a. Compute mid = low + (high - low)/2.
   b. If arr[mid] == target → update result = mid, move right half (low = mid + 1) to find last occurrence.
   c. If arr[mid] < target → search right half (low = mid + 1).
   d. If arr[mid] > target → search left half (high = mid - 1).
3. Return result.

Time Complexity: O(log n)
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find last occurrence in sorted array
int lastOccurrenceSorted(const vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    int result = -1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == target) {
            result = mid;      // Update last occurrence
            low = mid + 1;     // Move right to find later occurrence
        } else if (arr[mid] < target) {
            low = mid + 1;     // Move right
        } else {
            high = mid - 1;    // Move left
        }
    }

    return result;            // Return index or -1
}

int main() {
    vector<int> arr = {1, 2, 2, 2, 3, 4, 5};
    int target1 = 2, target2 = 6;

    cout << "Last occurrence of " << target1 << ": " << lastOccurrenceSorted(arr, target1) << endl;
    cout << "Last occurrence of " << target2 << ": " << lastOccurrenceSorted(arr, target2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [1, 2, 2, 2, 3, 4, 5], target = 2
Step 1: low=0, high=6, mid=3 → arr[3]=2 == target → result=3, low=4
Step 2: low=4, high=6, mid=5 → arr[5]=4 > 2 → high=4
Step 3: low=4, high=4, mid=4 → arr[4]=3 > 2 → high=3
Step 4: low > high → return result=3
Output: Last occurrence of 2: 3

Target = 6
Traverse → no match → return -1
Output: Last occurrence of 6: -1

```

---

## **Question: 13 Floor of a number in sorted array Binary search variant**

**Approach:**
Question: Find Floor of a Number in a Sorted Array Using Binary Search

Approach:
We are given a sorted array and a target number x. The floor of x is the greatest element in the array smaller than or equal to x.

Steps:

1. Initialize low = 0, high = n-1, floorIndex = -1.
2. While low <= high:
   a. Compute mid = low + (high - low)/2.
   b. If arr[mid] == x → floor is x → return mid.
   c. If arr[mid] < x → arr[mid] can be floor → update floorIndex = mid, search right half (low = mid + 1).
   d. If arr[mid] > x → search left half (high = mid - 1).
3. After loop ends, floorIndex contains the index of floor or -1 if no floor exists.

Time Complexity: O(log n)
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find floor of x in sorted array
int floorInSortedArray(const vector<int>& arr, int x) {
    int low = 0, high = arr.size() - 1;
    int floorIndex = -1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == x) {
            return mid;         // Exact match
        } else if (arr[mid] < x) {
            floorIndex = mid;   // arr[mid] can be floor
            low = mid + 1;      // Search right half
        } else {
            high = mid - 1;     // Search left half
        }
    }

    return floorIndex;          // Index of floor or -1
}

int main() {
    vector<int> arr = {1, 2, 4, 6, 8, 10};
    int target1 = 5, target2 = 0, target3 = 10;

    cout << "Floor of " << target1 << ": " << floorInSortedArray(arr, target1) << endl;
    cout << "Floor of " << target2 << ": " << floorInSortedArray(arr, target2) << endl;
    cout << "Floor of " << target3 << ": " << floorInSortedArray(arr, target3) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [1, 2, 4, 6, 8, 10], target = 5
Step 1: low=0, high=5, mid=2 → arr[2]=4 < 5 → floorIndex=2, low=3
Step 2: low=3, high=5, mid=4 → arr[4]=8 > 5 → high=3
Step 3: low=3, high=3, mid=3 → arr[3]=6 > 5 → high=2
Step 4: low>high → return floorIndex=2 → arr[2]=4
Output: Floor of 5: 4

Target=0 → all elements >0 → return -1 (no floor)
Target=10 → exact match → return index 5 → arr[5]=10

```

---

## **Question: 14 Ceiling of a number in sorted array Binary search variant**

**Approach:**
Question: Find Ceiling of a Number in a Sorted Array Using Binary Search

Approach:
We are given a sorted array and a target number x. The ceiling of x is the smallest element in the array greater than or equal to x.

Steps:

1. Initialize low = 0, high = n-1, ceilIndex = -1.
2. While low <= high:
   a. Compute mid = low + (high - low)/2.
   b. If arr[mid] == x → ceiling is x → return mid.
   c. If arr[mid] > x → arr[mid] can be ceiling → update ceilIndex = mid, search left half (high = mid - 1).
   d. If arr[mid] < x → search right half (low = mid + 1).
3. After loop ends, ceilIndex contains the index of ceiling or -1 if no ceiling exists.

Time Complexity: O(log n)
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find ceiling of x in sorted array
int ceilingInSortedArray(const vector<int>& arr, int x) {
    int low = 0, high = arr.size() - 1;
    int ceilIndex = -1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == x) {
            return mid;         // Exact match
        } else if (arr[mid] > x) {
            ceilIndex = mid;    // arr[mid] can be ceiling
            high = mid - 1;     // Search left half
        } else {
            low = mid + 1;      // Search right half
        }
    }

    return ceilIndex;           // Index of ceiling or -1
}

int main() {
    vector<int> arr = {1, 2, 4, 6, 8, 10};
    int target1 = 5, target2 = 11, target3 = 4;

    cout << "Ceiling of " << target1 << ": " << ceilingInSortedArray(arr, target1) << endl;
    cout << "Ceiling of " << target2 << ": " << ceilingInSortedArray(arr, target2) << endl;
    cout << "Ceiling of " << target3 << ": " << ceilingInSortedArray(arr, target3) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [1, 2, 4, 6, 8, 10], target = 5
Step 1: low=0, high=5, mid=2 → arr[2]=4 < 5 → low=3
Step 2: low=3, high=5, mid=4 → arr[4]=8 > 5 → ceilIndex=4, high=3
Step 3: low=3, high=3, mid=3 → arr[3]=6 > 5 → ceilIndex=3, high=2
Step 4: low>high → return ceilIndex=3 → arr[3]=6
Output: Ceiling of 5: 6

Target=11 → all elements <11 → return -1 (no ceiling)
Target=4 → exact match → return index 2 → arr[2]=4

```

---

## **Question: 15 Count occurrences of a number in sorted array Binary search**

**Approach:**
Question: Count Occurrences of a Number in a Sorted Array Using Binary Search

Approach:
We are given a sorted array and a target number x. To count occurrences:

Steps:

1. Find the first occurrence of x using binary search variant.
2. Find the last occurrence of x using binary search variant.
3. If x is not found (first occurrence = -1) → count = 0.
4. Otherwise, count = lastIndex - firstIndex + 1.

Time Complexity: O(log n) → two binary searches
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Binary search variant to find first occurrence
int firstOccurrence(const vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1, result = -1;
    while (low <= high) {
        int mid = low + (high - low)/2;
        if (arr[mid] == target) { result = mid; high = mid - 1; }
        else if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return result;
}

// Binary search variant to find last occurrence
int lastOccurrence(const vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1, result = -1;
    while (low <= high) {
        int mid = low + (high - low)/2;
        if (arr[mid] == target) { result = mid; low = mid + 1; }
        else if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return result;
}

// Function to count occurrences
int countOccurrences(const vector<int>& arr, int target) {
    int first = firstOccurrence(arr, target);
    if (first == -1) return 0; // Not found
    int last = lastOccurrence(arr, target);
    return last - first + 1;
}

int main() {
    vector<int> arr = {1, 2, 2, 2, 3, 4, 5};
    int target1 = 2, target2 = 6;

    cout << "Occurrences of " << target1 << ": " << countOccurrences(arr, target1) << endl;
    cout << "Occurrences of " << target2 << ": " << countOccurrences(arr, target2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [1, 2, 2, 2, 3, 4, 5], target = 2
First occurrence: index=1
Last occurrence: index=3
Count = 3 - 1 + 1 = 3
Output: Occurrences of 2: 3

Target=6
First occurrence = -1 → count=0
Output: Occurrences of 6: 0

```

---

## **Question: 16 Search element in row-wise sorted matrix Staircase search**

**Approach:**
Question: Search Element in Row-wise Sorted Matrix Using Staircase Search

Approach:
We are given a matrix where each row is sorted in ascending order. We need to find a target element efficiently.

Steps:

1. Start from the top-right corner (row=0, col=last column).
2. While row < rows and col >= 0:
   a. If matrix[row][col] == target → found → return coordinates.
   b. If matrix[row][col] > target → move left (col--).
   c. If matrix[row][col] < target → move down (row++).
3. If the loop ends without finding the element → return not found.

Time Complexity: O(n + m) → at most n down moves + m left moves
Space Complexity: O(1) → no extra space

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to search in a row-wise sorted matrix using staircase search
pair<int,int> searchRowWiseMatrix(const vector<vector<int>>& matrix, int target) {
    int rows = matrix.size();
    if (rows == 0) return {-1,-1};
    int cols = matrix[0].size();

    int row = 0, col = cols - 1; // Start from top-right corner

    while (row < rows && col >= 0) {
        if (matrix[row][col] == target) {
            return {row, col};    // Element found
        } else if (matrix[row][col] > target) {
            col--;                // Move left
        } else {
            row++;                // Move down
        }
    }

    return {-1,-1};                // Not found
}

int main() {
    vector<vector<int>> matrix = {
        {1, 4, 7, 11},
        {2, 5, 8, 12},
        {3, 6, 9, 16},
        {10, 13, 14, 17}
    };
    int target1 = 9, target2 = 15;

    auto res1 = searchRowWiseMatrix(matrix, target1);
    if (res1.first != -1) cout << "Element " << target1 << " found at (" << res1.first << "," << res1.second << ")\n";
    else cout << "Element " << target1 << " not found\n";

    auto res2 = searchRowWiseMatrix(matrix, target2);
    if (res2.first != -1) cout << "Element " << target2 << " found at (" << res2.first << "," << res2.second << ")\n";
    else cout << "Element " << target2 << " not found\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 4 7 11
2 5 8 12
3 6 9 16
10 13 14 17
Target=9

Step 1: start at (0,3)=11 → 11>9 → move left to (0,2)=7
Step 2: 7<9 → move down to (1,2)=8
Step 3: 8<9 → move down to (2,2)=9 → found
Output: Element 9 found at (2,2)

Target=15
Step 1: start at (0,3)=11 → 11<15 → move down (1,3)=12
Step 2: 12<15 → move down (2,3)=16
Step 3: 16>15 → move left (2,2)=9
Step 4: 9<15 → move down (3,2)=14
Step 5: 14<15 → move down (4,2) → out of bounds → not found
Output: Element 15 not found

```

---

## **Question: 17 Search element in row+column sorted matrix Staircase search**

**Approach:**
Question: Search Element in Row & Column-wise Sorted Matrix Using Staircase Search

Approach:
We are given a matrix where each row and each column is sorted in ascending order. We need to find a target element efficiently.

Steps:

1. Start from the top-right corner (row=0, col=last column).
2. While row < rows and col >= 0:
   a. If matrix[row][col] == target → found → return coordinates.
   b. If matrix[row][col] > target → move left (col--).
   c. If matrix[row][col] < target → move down (row++).
3. If the loop ends without finding the element → return not found.

Time Complexity: O(n + m) → at most n down moves + m left moves
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to search in a row & column-wise sorted matrix using staircase search
pair<int,int> searchRowColSortedMatrix(const vector<vector<int>>& matrix, int target) {
    int rows = matrix.size();
    if (rows == 0) return {-1,-1};
    int cols = matrix[0].size();

    int row = 0, col = cols - 1; // Start from top-right corner

    while (row < rows && col >= 0) {
        if (matrix[row][col] == target) {
            return {row, col};    // Element found
        } else if (matrix[row][col] > target) {
            col--;                // Move left
        } else {
            row++;                // Move down
        }
    }

    return {-1,-1};                // Not found
}

int main() {
    vector<vector<int>> matrix = {
        {10, 20, 30, 40},
        {15, 25, 35, 45},
        {27, 29, 37, 48},
        {32, 33, 39, 50}
    };
    int target1 = 29, target2 = 100;

    auto res1 = searchRowColSortedMatrix(matrix, target1);
    if (res1.first != -1) cout << "Element " << target1 << " found at (" << res1.first << "," << res1.second << ")\n";
    else cout << "Element " << target1 << " not found\n";

    auto res2 = searchRowColSortedMatrix(matrix, target2);
    if (res2.first != -1) cout << "Element " << target2 << " found at (" << res2.first << "," << res2.second << ")\n";
    else cout << "Element " << target2 << " not found\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
10 20 30 40
15 25 35 45
27 29 37 48
32 33 39 50
Target=29

Step 1: start at (0,3)=40 → 40>29 → move left (0,2)=30
Step 2: 30>29 → move left (0,1)=20
Step 3: 20<29 → move down (1,1)=25
Step 4: 25<29 → move down (2,1)=29 → found
Output: Element 29 found at (2,1)

Target=100
Step 1: start at (0,3)=40 → 40<100 → down (1,3)=45
Step 2: 45<100 → down (2,3)=48
Step 3: 48<100 → down (3,3)=50
Step 4: 50<100 → down (4,3) → out of bounds → not found
Output: Element 100 not found

```

---

## **Question: 18 Count elements ≤ X in row-wise sorted matrix Binary search per row**

**Approach:**
Question: Count Elements ≤ X in a Row-wise Sorted Matrix Using Binary Search

Approach:
We are given a matrix where each row is sorted in ascending order. We need to count the number of elements ≤ X efficiently.

Steps:

1. Initialize count = 0.
2. For each row:
   a. Perform binary search to find the last index of element ≤ X.
   b. Number of elements ≤ X in this row = lastIndex + 1.
   c. Add to total count.
3. Return total count.

Time Complexity: O(n log m) → n rows, binary search in m columns per row
Space Complexity: O(1) → no extra space needed

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find number of elements ≤ X in a sorted row using binary search
int countLEInRow(const vector<int>& row, int X) {
    int low = 0, high = row.size() - 1;
    int result = -1;

    while (low <= high) {
        int mid = low + (high - low)/2;
        if (row[mid] <= X) {
            result = mid;    // Element ≤ X, move right
            low = mid + 1;
        } else {
            high = mid - 1;  // Element > X, move left
        }
    }

    return result + 1;      // Number of elements ≤ X
}

// Function to count elements ≤ X in row-wise sorted matrix
int countElementsLE(const vector<vector<int>>& matrix, int X) {
    int total = 0;
    for (const auto& row : matrix) {
        total += countLEInRow(row, X);
    }
    return total;
}

int main() {
    vector<vector<int>> matrix = {
        {1, 3, 5},
        {2, 4, 6},
        {3, 6, 9}
    };
    int X1 = 4, X2 = 10;

    cout << "Count of elements ≤ " << X1 << ": " << countElementsLE(matrix, X1) << endl;
    cout << "Count of elements ≤ " << X2 << ": " << countElementsLE(matrix, X2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 3 5
2 4 6
3 6 9
Target X=4

Row1: [1,3,5] → last ≤4 is 3 at index=1 → count=2
Row2: [2,4,6] → last ≤4 is 4 at index=1 → count=2 → total=4
Row3: [3,6,9] → last ≤4 is 3 at index=0 → count=1 → total=5
Output: Count of elements ≤4 = 5

Target X=10
Row1: last=5 index=2 → count=3
Row2: last=6 index=2 → count=3 → total=6
Row3: last=9 index=2 → count=3 → total=9
Output: Count of elements ≤10 = 9

```

---

## **Question: 19 Find kth smallest element in row-wise sorted matrix Flatten + sort (basic)**

**Approach:**
Question: Find kth Smallest Element in Row-wise Sorted Matrix Using Flatten + Sort

Approach:
We are given a matrix where each row is sorted. To find the kth smallest element:

Steps:

1. Flatten the matrix into a 1D array.
2. Sort the 1D array.
3. Return the element at index k-1 (0-based indexing).

Time Complexity: O(n*m log(n*m)) → flatten + sort
Space Complexity: O(n\*m) → for flattened array

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Function to find kth smallest element in row-wise sorted matrix
int kthSmallestElement(const vector<vector<int>>& matrix, int k) {
    vector<int> flat;
    for (const auto& row : matrix) {
        for (int num : row) {
            flat.push_back(num);  // Flatten matrix
        }
    }
    sort(flat.begin(), flat.end()); // Sort flattened array
    return flat[k-1];               // kth smallest (1-based)
}

int main() {
    vector<vector<int>> matrix = {
        {1, 5, 9},
        {2, 6, 10},
        {3, 7, 11}
    };
    int k1 = 5, k2 = 9;

    cout << "5th smallest element: " << kthSmallestElement(matrix, k1) << endl;
    cout << "9th smallest element: " << kthSmallestElement(matrix, k2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 5 9
2 6 10
3 7 11
Flattened: [1,5,9,2,6,10,3,7,11]
Sorted: [1,2,3,5,6,7,9,10,11]

k=5 → element at index 4 = 6
Output: 5th smallest element: 6

k=9 → element at index 8 = 11
Output: 9th smallest element: 11

```

---

## **Question: 20 Find kth smallest element in row-wise sorted matrix Optimized binary search**

**Approach:**
Question: Find kth Smallest Element in Row-wise Sorted Matrix Using Optimized Binary Search

Approach:
We are given a row-wise sorted matrix. Instead of flattening and sorting, we can use binary search on the value range:

Steps:

1. Find the minimum (start) and maximum (end) elements in the matrix.
2. While start <= end:
   a. mid = (start + end)/2
   b. Count elements ≤ mid in the matrix (use binary search in each row)
   c. If count < k → kth smallest is larger → start = mid + 1
   d. Else → kth smallest ≤ mid → end = mid - 1
3. After loop, start contains the kth smallest element.

Time Complexity: O(32 _ n _ log m) ≈ O(n*log m*log(max-min))  
Space Complexity: O(1) → no extra space

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Helper: count elements ≤ X in a sorted row
int countLE(const vector<int>& row, int X) {
    int low = 0, high = row.size()-1, res = -1;
    while(low <= high){
        int mid = low + (high-low)/2;
        if(row[mid] <= X){
            res = mid;
            low = mid + 1;
        } else high = mid - 1;
    }
    return res+1; // number of elements ≤ X
}

// Function to find kth smallest element in row-wise sorted matrix
int kthSmallestOptimized(const vector<vector<int>>& matrix, int k) {
    int n = matrix.size();
    int m = matrix[0].size();
    int start = matrix[0][0], end = matrix[n-1][m-1];

    while(start <= end){
        int mid = start + (end-start)/2;
        int cnt = 0;
        for(const auto& row : matrix){
            cnt += countLE(row, mid); // count elements ≤ mid
        }

        if(cnt < k) start = mid + 1;
        else end = mid - 1;
    }

    return start; // kth smallest
}

int main() {
    vector<vector<int>> matrix = {
        {1, 5, 9},
        {2, 6, 10},
        {3, 7, 11}
    };
    int k1 = 5, k2 = 9;

    cout << "5th smallest element: " << kthSmallestOptimized(matrix, k1) << endl;
    cout << "9th smallest element: " << kthSmallestOptimized(matrix, k2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 5 9
2 6 10
3 7 11
k=5
Start=1, End=11

Iteration 1: mid=6
Row1: [1,5,9] → ≤6 count=2
Row2: [2,6,10] → ≤6 count=2 → total=4
Row3: [3,7,11] → ≤6 count=1 → total=5
cnt=5 ≥ k → end=mid-1=5

Iteration 2: mid=3
Row1: count=1
Row2: count=1 → total=2
Row3: count=1 → total=3 < k → start=mid+1=4

Iteration 3: mid=4
Row1: count=2
Row2: count=1 → total=3 < k → start=5
Iteration 4: mid=5
Row1: count=2
Row2: count=1 → total=3 < k → start=6

Start=6 → kth smallest=6
Output: 5th smallest element: 6

k=9 → process similarly → start=11 → 9th smallest=11
Output: 9th smallest element: 11

```

---

## **Question: 21 Find kth largest element in row-wise sorted matrix Optimized binary search**

**Approach:**
Question: Find kth Largest Element in Row-wise Sorted Matrix Using Optimized Binary Search

Approach:
We are given a row-wise sorted matrix. To find the kth largest element efficiently:

Steps:

1. Note that kth largest = (total elements - k + 1)th smallest.
2. Use the same optimized binary search method as for kth smallest:
   a. Set start = minimum element, end = maximum element.
   b. While start <= end:
   i. mid = (start + end)/2
   ii. Count elements ≤ mid in the matrix (binary search per row)
   iii. If count < (total-k+1) → start = mid + 1
   iv. Else → end = mid - 1
3. After loop, start contains kth largest element.

Time Complexity: O(log(max-min) _ n _ log m)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Helper: count elements ≤ X in a sorted row
int countLE(const vector<int>& row, int X) {
    int low = 0, high = row.size()-1, res = -1;
    while(low <= high){
        int mid = low + (high-low)/2;
        if(row[mid] <= X){
            res = mid;
            low = mid + 1;
        } else high = mid - 1;
    }
    return res+1; // number of elements ≤ X
}

// Function to find kth largest element in row-wise sorted matrix
int kthLargestOptimized(const vector<vector<int>>& matrix, int k) {
    int n = matrix.size();
    int m = matrix[0].size();
    int total = n*m;
    int targetSmallest = total - k + 1; // Convert kth largest to kth smallest
    int start = matrix[0][0], end = matrix[n-1][m-1];

    while(start <= end){
        int mid = start + (end-start)/2;
        int cnt = 0;
        for(const auto& row : matrix){
            cnt += countLE(row, mid);
        }

        if(cnt < targetSmallest) start = mid + 1;
        else end = mid - 1;
    }

    return start; // kth largest
}

int main() {
    vector<vector<int>> matrix = {
        {1, 5, 9},
        {2, 6, 10},
        {3, 7, 11}
    };
    int k1 = 3, k2 = 7;

    cout << "3rd largest element: " << kthLargestOptimized(matrix, k1) << endl;
    cout << "7th largest element: " << kthLargestOptimized(matrix, k2) << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 5 9
2 6 10
3 7 11
Total elements = 9

k=3 → targetSmallest = 9-3+1 = 7th smallest
Apply kth smallest binary search → 7th smallest = 9
Output: 3rd largest element: 9

k=7 → targetSmallest = 9-7+1 = 3rd smallest
3rd smallest = 3
Output: 7th largest element: 3

```

---

## **Question: 22 Median of row-wise sorted matrix Flatten + sort**

**Approach:**
Question: Find Median of Row-wise Sorted Matrix Using Flatten + Sort

Approach:
We are given a row-wise sorted matrix. To find the median using the basic approach:

Steps:

1. Flatten the matrix into a 1D array.
2. Sort the flattened array.
3. If total elements = odd → median = element at index n\*m/2
4. If total elements = even → median = average of elements at indices (n*m-1)/2 and n*m/2
5. Return the median.

Time Complexity: O(n*m log(n*m)) → flatten + sort
Space Complexity: O(n\*m) → for flattened array

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Function to find median of a row-wise sorted matrix
double medianFlattenSort(const vector<vector<int>>& matrix) {
    int n = matrix.size();
    if(n == 0) return -1;                 // Edge case: empty matrix
    int m = matrix[0].size();

    vector<int> flat;                     // Vector to store all elements
    for(const auto& row : matrix){
        for(int val : row){
            flat.push_back(val);          // Flatten the matrix
        }
    }

    sort(flat.begin(), flat.end());       // Sort the flattened array

    int total = n * m;
    if(total % 2 != 0){
        // Odd number of elements → middle element
        return flat[total/2];
    } else {
        // Even number of elements → average of two middle elements
        return (flat[total/2 - 1] + flat[total/2]) / 2.0;
    }
}

int main() {
    vector<vector<int>> matrix = {
        {1, 3, 5},
        {2, 6, 9},
        {3, 6, 9}
    };

    double med = medianFlattenSort(matrix);
    cout << "Median of matrix: " << med << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 3 5
2 6 9
3 6 9

Flatten: [1,3,5,2,6,9,3,6,9]
Sorted:  [1,2,3,3,5,6,6,9,9]
Total elements = 9 (odd)
Median index = 9/2 = 4 → element at index 4 = 5
Output: Median of matrix = 5

```

---

## **Question: 23 Median of row-wise sorted matrix Optimized binary search**

**Approach:**
Question: Find Median of Row-wise Sorted Matrix Using Optimized Binary Search

Approach:
We are given a row-wise sorted matrix. Instead of flattening, we can find the median using binary search on the value range:

Steps:

1. Find the minimum (start) and maximum (end) elements in the matrix.
2. Total elements = n \* m, median position = (total+1)/2 (1-based index).
3. While start <= end:
   a. mid = (start + end)/2
   b. Count elements ≤ mid in the matrix (binary search per row)
   c. If count < median position → median is larger → start = mid + 1
   d. Else → median ≤ mid → end = mid - 1
4. After loop, start contains the median.

Time Complexity: O(32 _ n _ log m) ≈ O(n _ log m _ log(max-min))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Helper: count elements ≤ X in a sorted row
int countLE(const vector<int>& row, int X) {
    int low = 0, high = row.size() - 1, res = -1;
    while(low <= high){
        int mid = low + (high - low) / 2;
        if(row[mid] <= X){
            res = mid;         // Update last index ≤ X
            low = mid + 1;     // Search right half
        } else high = mid - 1; // Search left half
    }
    return res + 1;            // Number of elements ≤ X
}

// Function to find median in row-wise sorted matrix
int medianOptimized(const vector<vector<int>>& matrix) {
    int n = matrix.size();
    int m = matrix[0].size();
    int start = matrix[0][0];               // Minimum element
    int end = matrix[0][m-1];               // Will update max below

    // Find global maximum
    for(int i = 0; i < n; i++){
        if(matrix[i][m-1] > end) end = matrix[i][m-1];
    }

    int desired = (n*m + 1)/2;              // Median position (1-based)

    while(start <= end){
        int mid = start + (end - start)/2;
        int count = 0;
        for(const auto& row : matrix){
            count += countLE(row, mid);     // Count elements ≤ mid
        }

        if(count < desired) start = mid + 1; // Median is larger
        else end = mid - 1;                  // Median is ≤ mid
    }

    return start;                           // Median found
}

int main() {
    vector<vector<int>> matrix = {
        {1, 3, 5},
        {2, 6, 9},
        {3, 6, 9}
    };

    int med = medianOptimized(matrix);
    cout << "Median of matrix: " << med << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 3 5
2 6 9
3 6 9

Start = 1, End = 9
Total elements = 9 → desired = (9+1)/2 = 5

Iteration 1: mid = 5
Row1: ≤5 count=3
Row2: ≤5 count=2 → total=5
Row3: ≤5 count=1 → total=6 ≥ desired → end = mid-1 = 4

Iteration 2: mid = 2
Row1: ≤2 count=1
Row2: ≤2 count=1 → total=2 < desired → start=mid+1=3

Iteration 3: mid = 3
Row1: ≤3 count=2
Row2: ≤3 count=1 → total=3 < desired → start=mid+1=4

Iteration 4: mid = 4
Row1: ≤4 count=2
Row2: ≤4 count=1 → total=3 < desired → start=mid+1=5

Loop ends → start=5 → median=5
Output: Median of matrix = 5

```

---

## **Question: 24 Saddle point in matrix Row min / column max**

**Approach:**
Question: Find Saddle Point in a Matrix Using Row Minimum and Column Maximum

Approach:
A saddle point is an element which is minimum in its row and maximum in its column.

Steps:

1. For each row, find the minimum element and its column index.
2. Check if this minimum element is the maximum in its column.
   a. If yes → this is a saddle point → return it.
3. If no saddle point is found after checking all rows → return "None".

Time Complexity: O(n\*m) → check each row and corresponding column
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find saddle point in a matrix
pair<int,int> findSaddlePoint(const vector<vector<int>>& matrix) {
    int n = matrix.size();
    if(n == 0) return {-1,-1};             // Edge case: empty matrix
    int m = matrix[0].size();

    for(int i = 0; i < n; i++){
        // Find the minimum element in current row and its column index
        int rowMin = matrix[i][0];
        int colIndex = 0;
        for(int j = 1; j < m; j++){
            if(matrix[i][j] < rowMin){
                rowMin = matrix[i][j];
                colIndex = j;
            }
        }

        // Check if rowMin is maximum in its column
        bool isSaddle = true;
        for(int k = 0; k < n; k++){
            if(matrix[k][colIndex] > rowMin){
                isSaddle = false;
                break;
            }
        }

        if(isSaddle) return {i, colIndex}; // Saddle point found
    }

    return {-1,-1}; // No saddle point
}

int main() {
    vector<vector<int>> matrix = {
        {11, 12, 13},
        {14, 15, 16},
        {17, 18, 19}
    };

    auto sp = findSaddlePoint(matrix);
    if(sp.first != -1)
        cout << "Saddle point found at (" << sp.first << "," << sp.second << ") = " << matrix[sp.first][sp.second] << endl;
    else
        cout << "No saddle point in the matrix" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
11 12 13
14 15 16
17 18 19

Row0 min = 11 at col0
Check column0: 11,14,17 → max=17 ≠ 11 → not saddle

Row1 min = 14 at col0
Check column0: 11,14,17 → max=17 ≠ 14 → not saddle

Row2 min = 17 at col0
Check column0: 11,14,17 → max=17 = 17 → saddle point found
Output: Saddle point at (2,0) = 17

```

---

## **Question: 25 Search in sorted rotated matrix (row-wise sorted) Binary search per row**

**Approach:**
Question: Search in Sorted Rotated Row-wise Matrix Using Binary Search per Row

Approach:
We are given a matrix where each row is individually sorted but rotated. To search efficiently:

Steps:

1. For each row:
   a. Perform binary search in rotated sorted array (row) to find target.
2. If target is found → return its coordinates.
3. If target is not found in any row → return "not found".

Binary Search in Rotated Sorted Array:

1. Initialize low=0, high=n-1
2. While low <= high:
   a. mid = (low + high)/2
   b. If arr[mid] == target → found
   c. If left half sorted (arr[low] <= arr[mid]):
   i. If target ∈ [arr[low], arr[mid]] → high=mid-1
   ii. Else → low=mid+1
   d. Else (right half sorted):
   i. If target ∈ [arr[mid], arr[high]] → low=mid+1
   ii. Else → high=mid-1

Time Complexity: O(n \* log m) → binary search per row
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Binary search in a rotated sorted array
int searchRotatedArray(const vector<int>& arr, int target){
    int low = 0, high = arr.size()-1;

    while(low <= high){
        int mid = low + (high-low)/2;
        if(arr[mid] == target) return mid; // Found target

        // Check if left half is sorted
        if(arr[low] <= arr[mid]){
            if(target >= arr[low] && target < arr[mid]){
                high = mid - 1;  // Search left
            } else {
                low = mid + 1;   // Search right
            }
        }
        // Right half is sorted
        else {
            if(target > arr[mid] && target <= arr[high]){
                low = mid + 1;   // Search right
            } else {
                high = mid - 1;  // Search left
            }
        }
    }

    return -1; // Not found
}

// Search in sorted rotated row-wise matrix
pair<int,int> searchInRotatedMatrix(const vector<vector<int>>& matrix, int target){
    int n = matrix.size();
    if(n == 0) return {-1,-1};
    int m = matrix[0].size();

    for(int i = 0; i < n; i++){
        int col = searchRotatedArray(matrix[i], target);
        if(col != -1) return {i, col}; // Found in row i
    }

    return {-1,-1}; // Not found in any row
}

int main(){
    vector<vector<int>> matrix = {
        {5, 6, 1, 2, 3, 4},
        {11, 12, 7, 8, 9, 10},
        {20, 21, 15, 16, 17, 18}
    };
    int target1 = 8, target2 = 13;

    auto res1 = searchInRotatedMatrix(matrix, target1);
    if(res1.first != -1)
        cout << "Element " << target1 << " found at (" << res1.first << "," << res1.second << ")\n";
    else
        cout << "Element " << target1 << " not found\n";

    auto res2 = searchInRotatedMatrix(matrix, target2);
    if(res2.first != -1)
        cout << "Element " << target2 << " found at (" << res2.first << "," << res2.second << ")\n";
    else
        cout << "Element " << target2 << " not found\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
5 6 1 2 3 4
11 12 7 8 9 10
20 21 15 16 17 18

Target = 8
Row0: searchRotatedArray([5,6,1,2,3,4], 8) → not found
Row1: searchRotatedArray([11,12,7,8,9,10], 8) → found at index 3
Output: Element 8 found at (1,3)

Target = 13
Row0: not found
Row1: not found
Row2: not found
Output: Element 13 not found

```

---

## **Question: 26 Count zeros in row+column sorted binary matrix Staircase method**

**Approach:**
Question: Count Zeros in Row and Column Sorted Binary Matrix Using Staircase Method

Approach:
We are given a binary matrix (0s and 1s) sorted in each row and column. To count zeros efficiently:

Steps:

1. Start from the bottom-left corner (row=n-1, col=0).
2. Initialize count = 0.
3. While row >= 0 and col < m:
   a. If matrix[row][col] == 0 → all elements above in this column are also 0 → add (row+1) to count → move right (col++).
   b. Else (matrix[row][col] == 1) → move up (row--).
4. After loop ends, count contains total number of zeros.

Time Complexity: O(n + m) → each step moves either up or right
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to count zeros in a row+column sorted binary matrix
int countZerosStaircase(const vector<vector<int>>& matrix) {
    int n = matrix.size();
    if(n == 0) return 0;                  // Edge case: empty matrix
    int m = matrix[0].size();

    int row = n - 1;                       // Start at bottom-left
    int col = 0;
    int count = 0;

    while(row >= 0 && col < m){
        if(matrix[row][col] == 0){
            // All elements above in this column are also 0
            count += (row + 1);           // Add number of zeros in this column
            col++;                         // Move right
        } else {
            // Found 1 → move up
            row--;
        }
    }

    return count;                          // Total number of zeros
}

int main(){
    vector<vector<int>> matrix = {
        {0, 0, 0, 1},
        {0, 0, 1, 1},
        {0, 1, 1, 1},
        {0, 1, 1, 1}
    };

    int totalZeros = countZerosStaircase(matrix);
    cout << "Total zeros in matrix: " << totalZeros << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
0 0 0 1
0 0 1 1
0 1 1 1
0 1 1 1

Start at (3,0)=0 → count += 4 → col=1
(3,1)=1 → move up → row=2
(2,1)=1 → move up → row=1
(1,1)=0 → count += 2 → col=2 → count=6
(1,2)=1 → move up → row=0
(0,2)=0 → count += 1 → col=3 → count=7
(0,3)=1 → move up → row=-1 → loop ends

Output: Total zeros in matrix = 7

```

---

## **Question: 27 Search in infinite row-wise sorted array Binary search variant**

**Approach:**
Question: Search in Infinite Row-wise Sorted Array Using Binary Search Variant

Approach:
We are given a row-wise sorted array of unknown/infinite size. To search efficiently:

Steps:

1. Start with a small range: low=0, high=1.
2. Expand the range exponentially until target ≤ arr[high]:
   a. low = high + 1
   b. high = 2\*high
3. Perform binary search within the determined range [low, high] to find the target.

Time Complexity: O(log n) → range expansion + binary search
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Binary search in a finite range
int binarySearch(const vector<int>& arr, int low, int high, int target){
    while(low <= high){
        int mid = low + (high - low)/2;
        if(arr[mid] == target) return mid;    // Found target
        else if(arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;                                // Not found
}

// Search in infinite row-wise sorted array
int searchInfiniteArray(const vector<int>& arr, int target){
    if(arr.empty()) return -1;

    int low = 0, high = 1;

    // Expand the high index exponentially until target ≤ arr[high]
    while(high < arr.size() && arr[high] < target){
        low = high + 1;
        high = 2*high;
        if(high >= arr.size()) high = arr.size() - 1; // Prevent out-of-bounds
    }

    // Binary search in determined range
    return binarySearch(arr, low, high, target);
}

int main(){
    vector<int> arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21};
    int target1 = 13, target2 = 8;

    int idx1 = searchInfiniteArray(arr, target1);
    if(idx1 != -1) cout << "Element " << target1 << " found at index " << idx1 << endl;
    else cout << "Element " << target1 << " not found\n";

    int idx2 = searchInfiniteArray(arr, target2);
    if(idx2 != -1) cout << "Element " << target2 << " found at index " << idx2 << endl;
    else cout << "Element " << target2 << " not found\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array: [1,3,5,7,9,11,13,15,17,19,21]
Target = 13
Start low=0, high=1
arr[1]=3 < 13 → low=2, high=2
arr[2]=5 < 13 → low=3, high=4
arr[4]=9 < 13 → low=5, high=8
arr[8]=17 > 13 → stop expansion
Binary search in range [5,8]: mid=6 → arr[6]=13 → found at index 6
Output: Element 13 found at index 6

Target = 8
Expand: high=1→2→4→8 → arr[8]=17 > 8 → binary search [5,8]
Binary search: mid=6 → arr[6]=13>8 → high=5, mid=5 → arr[5]=11>8 → high=4 → not found
Output: Element 8 not found

```

---

## **Question: 28 Peak element in 2D matrix Binary search on row maxima**

**Approach:**
Question: Find Peak Element in 2D Matrix Using Binary Search on Row Maxima

Approach:
A peak element in a 2D matrix is an element which is greater than or equal to its neighbors (top, bottom, left, right).

Optimized Approach (Binary Search on Row Maxima):

1. Set start = 0, end = number of rows - 1.
2. While start <= end:
   a. Find mid row.
   b. Find index of maximum element in mid row (maxCol).
   c. Compare matrix[mid][maxCol] with neighbors above and below (if exist):
   i. If matrix[mid][maxCol] ≥ neighbors → this is peak → return coordinates.
   ii. If upper neighbor > current → move search up (end = mid-1)
   iii. If lower neighbor > current → move search down (start = mid+1)

Time Complexity: O(n log m) → binary search on rows, linear scan to find row maxima
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find column index of maximum in a row
int maxInRow(const vector<int>& row){
    int maxCol = 0;
    for(int j = 1; j < row.size(); j++){
        if(row[j] > row[maxCol]) maxCol = j;
    }
    return maxCol;
}

// Function to find a peak element in 2D matrix
pair<int,int> findPeak2D(const vector<vector<int>>& matrix){
    int n = matrix.size();
    if(n == 0) return {-1,-1};             // Edge case: empty matrix
    int m = matrix[0].size();

    int start = 0, end = n - 1;

    while(start <= end){
        int mid = start + (end - start)/2;
        int maxCol = maxInRow(matrix[mid]); // Column of maximum in mid row

        int up = (mid > 0) ? matrix[mid-1][maxCol] : -1;    // upper neighbor
        int down = (mid < n-1) ? matrix[mid+1][maxCol] : -1; // lower neighbor
        int curr = matrix[mid][maxCol];

        if(curr >= up && curr >= down){
            // Peak found
            return {mid, maxCol};
        } else if(up > curr){
            end = mid - 1; // Move search up
        } else {
            start = mid + 1; // Move search down
        }
    }

    return {-1,-1}; // Peak not found (should not happen)
}

int main(){
    vector<vector<int>> matrix = {
        {10, 8, 10, 10},
        {14, 13, 12, 11},
        {15, 9, 11, 21},
        {16, 17, 19, 20}
    };

    auto peak = findPeak2D(matrix);
    if(peak.first != -1)
        cout << "Peak element at (" << peak.first << "," << peak.second << ") = " << matrix[peak.first][peak.second] << endl;
    else
        cout << "No peak found\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
10  8 10 10
14 13 12 11
15  9 11 21
16 17 19 20

Start=0, End=3 → mid=1 → row1: 14 13 12 11 → max=14 at col0
up=10, down=15 → down>14 → move down → start=2

mid=2 → row2: 15 9 11 21 → max=21 at col3
up=11, down=20 → curr=21 ≥ up & ≥ down → peak found
Output: Peak element at (2,3) = 21

```

---

## **Question: 29 Find smallest element ≥ X in matrix Binary search per row**

**Approach:**
Question: Find Smallest Element Greater than or Equal to X in Row-wise Sorted Matrix Using Binary Search per Row

Approach:
We are given a row-wise sorted matrix. To find the smallest element ≥ X efficiently:

Steps:

1. Initialize minVal = INF (or a very large number).
2. For each row:
   a. Perform binary search to find the first element ≥ X in the row.
   b. If found → update minVal = min(minVal, found element).
3. After checking all rows:
   a. If minVal updated → return minVal.
   b. Else → return -1 (no element ≥ X exists).

Time Complexity: O(n \* log m) → binary search in each row
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

// Binary search in a row to find first element >= X
int firstGE(const vector<int>& row, int X){
    int low = 0, high = row.size() - 1;
    int res = -1; // Store index of first element >= X
    while(low <= high){
        int mid = low + (high - low)/2;
        if(row[mid] >= X){
            res = mid;       // Candidate found
            high = mid - 1;  // Look for smaller index on left
        } else {
            low = mid + 1;   // Search right
        }
    }
    return res;           // -1 if no element >= X
}

// Function to find smallest element >= X in matrix
int smallestGEInMatrix(const vector<vector<int>>& matrix, int X){
    int n = matrix.size();
    if(n == 0) return -1;       // Empty matrix
    int m = matrix[0].size();
    int minVal = INT_MAX;

    for(int i = 0; i < n; i++){
        int idx = firstGE(matrix[i], X);
        if(idx != -1){
            minVal = min(minVal, matrix[i][idx]); // Update minimum
        }
    }

    return (minVal == INT_MAX) ? -1 : minVal;
}

int main(){
    vector<vector<int>> matrix = {
        {1, 3, 5},
        {2, 6, 9},
        {3, 6, 9}
    };
    int X1 = 4, X2 = 10;

    int res1 = smallestGEInMatrix(matrix, X1);
    if(res1 != -1) cout << "Smallest element >= " << X1 << " is " << res1 << endl;
    else cout << "No element >= " << X1 << " found\n";

    int res2 = smallestGEInMatrix(matrix, X2);
    if(res2 != -1) cout << "Smallest element >= " << X2 << " is " << res2 << endl;
    else cout << "No element >= " << X2 << " found\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 3 5
2 6 9
3 6 9

X = 4
Row0: 1 3 5 → first ≥4 = 5 → minVal = 5
Row1: 2 6 9 → first ≥4 = 6 → minVal = min(5,6)=5
Row2: 3 6 9 → first ≥4 = 6 → minVal = min(5,6)=5
Output: Smallest element >=4 is 5

X = 10
Row0: 1 3 5 → none
Row1: 2 6 9 → none
Row2: 3 6 9 → none
Output: No element >= 10 found

```

---

## **Question: 30 Find largest element ≤ X in matrix Binary search per row**

**Approach:**
Question: Find Largest Element Less than or Equal to X in Row-wise Sorted Matrix Using Binary Search per Row

Approach:
We are given a row-wise sorted matrix. To find the largest element ≤ X efficiently:

Steps:

1. Initialize maxVal = -INF (or a very small number).
2. For each row:
   a. Perform binary search to find the last element ≤ X in the row.
   b. If found → update maxVal = max(maxVal, found element).
3. After checking all rows:
   a. If maxVal updated → return maxVal.
   b. Else → return -1 (no element ≤ X exists).

Time Complexity: O(n \* log m) → binary search in each row
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

// Binary search in a row to find last element <= X
int lastLE(const vector<int>& row, int X){
    int low = 0, high = row.size() - 1;
    int res = -1; // Store index of last element <= X
    while(low <= high){
        int mid = low + (high - low)/2;
        if(row[mid] <= X){
            res = mid;       // Candidate found
            low = mid + 1;   // Look for larger index on right
        } else {
            high = mid - 1;  // Search left
        }
    }
    return res;           // -1 if no element <= X
}

// Function to find largest element <= X in matrix
int largestLEInMatrix(const vector<vector<int>>& matrix, int X){
    int n = matrix.size();
    if(n == 0) return -1;       // Empty matrix
    int m = matrix[0].size();
    int maxVal = INT_MIN;

    for(int i = 0; i < n; i++){
        int idx = lastLE(matrix[i], X);
        if(idx != -1){
            maxVal = max(maxVal, matrix[i][idx]); // Update maximum
        }
    }

    return (maxVal == INT_MIN) ? -1 : maxVal;
}

int main(){
    vector<vector<int>> matrix = {
        {1, 3, 5},
        {2, 6, 9},
        {3, 6, 9}
    };
    int X1 = 7, X2 = 0;

    int res1 = largestLEInMatrix(matrix, X1);
    if(res1 != -1) cout << "Largest element <= " << X1 << " is " << res1 << endl;
    else cout << "No element <= " << X1 << " found\n";

    int res2 = largestLEInMatrix(matrix, X2);
    if(res2 != -1) cout << "Largest element <= " << X2 << " is " << res2 << endl;
    else cout << "No element <= " << X2 << " found\n";

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Matrix:
1 3 5
2 6 9
3 6 9

X = 7
Row0: 1 3 5 → last <=7 = 5 → maxVal = 5
Row1: 2 6 9 → last <=7 = 6 → maxVal = max(5,6)=6
Row2: 3 6 9 → last <=7 = 6 → maxVal = max(6,6)=6
Output: Largest element <=7 is 6

X = 0
Row0: 1 3 5 → none
Row1: 2 6 9 → none
Row2: 3 6 9 → none
Output: No element <= 0 found

```

---

## **Question: 31 Allocate minimum number of pages (book allocation) Binary search on answer**

**Approach:**
Question: Allocate Minimum Number of Pages Using Binary Search on Answer

Approach:
We are given an array of books with pages and m students. Allocate contiguous books to students such that the maximum pages assigned to any student is minimized.

Steps:

1. The search space:
   a. Minimum possible max pages = max(books) → at least one book per student
   b. Maximum possible max pages = sum(books) → one student takes all
2. Perform binary search on max pages:
   a. mid = (low + high)/2
   b. Check if allocation possible with maxPages = mid - Start assigning books to students - If pages exceed mid → assign to next student - If students required > m → not possible
   c. If possible → try smaller max (high = mid-1)
   d. Else → try larger max (low = mid+1)
3. Return low → minimum feasible maximum pages.

Time Complexity: O(n \* log(sum-max))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
using namespace std;

// Helper: check if allocation is possible with maxPages
bool isPossible(const vector<int>& books, int m, int maxPages){
    int students = 1;
    int currentSum = 0;

    for(int pages : books){
        if(pages > maxPages) return false; // Single book exceeds limit
        if(currentSum + pages <= maxPages){
            currentSum += pages;          // Assign book to current student
        } else {
            students++;                    // Assign to next student
            currentSum = pages;
        }
    }

    return students <= m;
}

// Function to find minimum maximum pages
int allocateBooks(const vector<int>& books, int m){
    if(books.size() < m) return -1;       // Not enough books for students

    int low = *max_element(books.begin(), books.end()); // max single book
    int high = accumulate(books.begin(), books.end(), 0); // sum of all books
    int result = high;

    while(low <= high){
        int mid = low + (high - low)/2;
        if(isPossible(books, m, mid)){
            result = mid;       // feasible, try smaller max
            high = mid - 1;
        } else {
            low = mid + 1;      // not feasible, increase max
        }
    }

    return result;
}

int main(){
    vector<int> books = {12, 34, 67, 90};
    int students = 2;

    int minMax = allocateBooks(books, students);
    cout << "Minimum maximum pages = " << minMax << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Books = {12,34,67,90}, m=2
Low = max(books)=90, High = sum=203

Iteration1: mid=(90+203)/2=146
Check possible with maxPages=146:
  Student1: 12+34+67=113 → next book 90 → new student2: 90 → total 2 students ≤2 → feasible → try smaller max → high=145

Iteration2: mid=(90+145)/2=117
Check possible with maxPages=117:
  Student1: 12+34+67=113 → next 90 → student2: 90 → total 2 ≤2 → feasible → high=116

Iteration3: mid=(90+116)/2=103
Check: Student1: 12+34+67=113>103 → student1 ends at 12+34=46 → next student2:67 → next 90 → student3: 90 → total 3>2 → not feasible → low=104

Iteration4: mid=(104+116)/2=110
Check: Student1:12+34+67=113>110 → student1 ends at 12+34=46 → student2:67 → next 90 → student3:90 → total 3>2 → not feasible → low=111

Iteration5: mid=(111+116)/2=113
Check: Student1:12+34+67=113 → student2:90 → total 2 ≤2 → feasible → high=112

Iteration6: mid=(111+112)/2=111
Check: Student1:12+34+67=113>111 → student1 ends at 12+34=46 → student2:67 → next 90 → student3:90 → total 3>2 → not feasible → low=112

Iteration7: mid=112 → similar → not feasible → low=113

Loop ends → minMax=113
Output: Minimum maximum pages = 113

```

---

## **Question: 32 Painters partition problem Binary search on answer**

**Approach:**
Question: Painter's Partition Problem Using Binary Search on Answer

Approach:
We are given an array of boards with lengths and k painters. Each painter paints contiguous boards. We need to minimize the maximum time taken by any painter.

Steps:

1. Time to paint a board = length (or can multiply by unit time if given).
2. Search space for maximum time:
   a. Low = max length of single board (at least one painter paints a board)
   b. High = sum of all board lengths (one painter paints all)
3. Binary search on maximum time (mid):
   a. Check if allocation possible with time <= mid: - Assign boards to painter sequentially - If current sum > mid → next painter - If painters required > k → not feasible
   b. If feasible → try smaller max (high = mid-1)
   c. Else → increase max (low = mid+1)
4. Return low → minimum possible maximum time.

Time Complexity: O(n \* log(sum-max))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
using namespace std;

// Helper: check if boards can be painted within maxTime by k painters
bool isPossible(const vector<int>& boards, int k, int maxTime){
    int painters = 1;
    int currentSum = 0;

    for(int length : boards){
        if(length > maxTime) return false; // Single board exceeds limit
        if(currentSum + length <= maxTime){
            currentSum += length;          // Assign to current painter
        } else {
            painters++;                     // Assign to next painter
            currentSum = length;
        }
    }

    return painters <= k;
}

// Function to find minimum maximum time
int painterPartition(const vector<int>& boards, int k){
    if(boards.size() < k) return -1; // Not enough boards for painters

    int low = *max_element(boards.begin(), boards.end()); // max single board
    int high = accumulate(boards.begin(), boards.end(), 0); // sum of all boards
    int result = high;

    while(low <= high){
        int mid = low + (high - low)/2;
        if(isPossible(boards, k, mid)){
            result = mid;       // feasible, try smaller max
            high = mid - 1;
        } else {
            low = mid + 1;      // not feasible, increase max
        }
    }

    return result;
}

int main(){
    vector<int> boards = {10, 20, 30, 40};
    int painters = 2;

    int minMaxTime = painterPartition(boards, painters);
    cout << "Minimum maximum time = " << minMaxTime << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Boards = {10,20,30,40}, k=2
Low = max(boards)=40, High = sum=100

Iteration1: mid=(40+100)/2=70
Check feasible: Painter1:10+20+30=60 → next 40 → Painter2:40 → total 2 ≤2 → feasible → high=69

Iteration2: mid=(40+69)/2=54
Check: Painter1:10+20+30=60>54 → Painter1 ends at 10+20=30 → Painter2:30 → next 40 → Painter3:40 → total 3>2 → not feasible → low=55

Iteration3: mid=(55+69)/2=62
Check: Painter1:10+20+30=60 → Painter2:40 → total 2 → feasible → high=61

Iteration4: mid=(55+61)/2=58
Check: Painter1:10+20+30=60>58 → Painter1 ends at 10+20=30 → Painter2:30 → next 40 → Painter3:40 → total 3>2 → not feasible → low=59

Iteration5: mid=(59+61)/2=60
Check: Painter1:10+20+30=60 → Painter2:40 → total 2 → feasible → high=59

Iteration6: mid=(59+59)/2=59
Check: Painter1:10+20+30=60>59 → Painter1 ends at 10+20=30 → Painter2:30 → next 40 → Painter3:40 → total 3>2 → not feasible → low=60

Loop ends → minMaxTime=60
Output: Minimum maximum time = 60

```

---

## **Question: 33 Aggressive cows / max distance problem Binary search on answer**

**Approach:**
Question: Aggressive Cows / Max Distance Problem Using Binary Search on Answer

Approach:
We are given n stalls at positions (sorted) and c cows. Place cows in stalls such that minimum distance between any two cows is maximized.

Steps:

1. Sort stall positions (if not already sorted).
2. Search space for minimum distance (dist):
   a. Low = 1 (minimum possible distance)
   b. High = max(stalls) - min(stalls)
3. Binary search on distance:
   a. mid = (low + high)/2 → candidate minimum distance
   b. Check if it’s possible to place all cows with ≥ mid distance: - Place first cow at first stall - For each next stall, place cow if distance ≥ mid - If all cows placed → feasible
   c. If feasible → try larger distance (low = mid+1)
   d. Else → decrease distance (high = mid-1)
4. Return high → largest minimum distance possible

Time Complexity: O(n log(maxDist))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Helper: check if cows can be placed with minDist distance
bool canPlaceCows(const vector<int>& stalls, int c, int minDist){
    int count = 1;                  // Place first cow
    int lastPos = stalls[0];

    for(int i = 1; i < stalls.size(); i++){
        if(stalls[i] - lastPos >= minDist){
            count++;
            lastPos = stalls[i];
        }
    }

    return count >= c;              // Can place all cows?
}

// Function to find largest minimum distance
int aggressiveCows(vector<int>& stalls, int c){
    sort(stalls.begin(), stalls.end());   // Ensure stalls sorted

    int low = 1;                          // Min possible distance
    int high = stalls.back() - stalls.front(); // Max possible distance
    int result = 0;

    while(low <= high){
        int mid = low + (high - low)/2;   // Candidate distance
        if(canPlaceCows(stalls, c, mid)){
            result = mid;                  // Feasible → try larger
            low = mid + 1;
        } else {
            high = mid - 1;                // Not feasible → try smaller
        }
    }

    return result;                        // Largest minimum distance
}

int main(){
    vector<int> stalls = {1, 2, 8, 4, 9};
    int cows = 3;

    int maxMinDist = aggressiveCows(stalls, cows);
    cout << "Largest minimum distance = " << maxMinDist << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Stalls (sorted): 1 2 4 8 9, cows=3
Low=1, High=8

Iteration1: mid=(1+8)/2=4
Place cows with minDist=4:
  Place first at 1 → next stall 2-1<4 → skip
  next 4-1=3<4 → skip
  next 8-1=7 ≥4 → place cow2 at 8
  next 9-8=1<4 → skip
Cows placed=2 < 3 → not feasible → high=3

Iteration2: mid=(1+3)/2=2
Place cows with minDist=2:
  Place at 1 → next 2-1=1<2 → skip
  next 4-1=3≥2 → cow2 at 4
  next 8-4=4≥2 → cow3 at 8
Placed 3 cows → feasible → result=2 → low=3

Iteration3: mid=(3+3)/2=3
Place cows with minDist=3:
  Place at 1 → 2-1=1<3 → skip
  4-1=3 → cow2 at 4
  8-4=4 → cow3 at 8
Placed 3 cows → feasible → result=3 → low=4

Loop ends → largest min distance = 3
Output: Largest minimum distance = 3

```

---

## **Question: 34 Minimum largest sum subarray Binary search on answer**

**Approach:**
Question: Minimum Largest Sum Subarray Using Binary Search on Answer

Approach:
We are given an array and need to split it into m contiguous subarrays such that the largest sum among subarrays is minimized.

Steps:

1. Search space for largest sum:
   a. Low = max element of array → at least one element per subarray
   b. High = sum of all elements → one subarray contains all
2. Binary search on maximum sum:
   a. mid = (low + high)/2 → candidate maximum subarray sum
   b. Check if array can be split into ≤ m subarrays with sum ≤ mid: - Keep adding elements to current subarray - If sum > mid → start new subarray - Count number of subarrays - If subarrays > m → not feasible
   c. If feasible → try smaller max sum (high = mid-1)
   d. Else → increase max sum (low = mid+1)
3. Return low → minimum largest sum possible

Time Complexity: O(n \* log(sum-max))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
using namespace std;

// Helper: check if array can be split into <= m subarrays with max sum <= maxSum
bool isValidSplit(const vector<int>& nums, int m, int maxSum){
    int subarrays = 1;
    int currentSum = 0;

    for(int num : nums){
        if(num > maxSum) return false;   // Single element exceeds maxSum
        if(currentSum + num <= maxSum){
            currentSum += num;           // Add to current subarray
        } else {
            subarrays++;                 // Start new subarray
            currentSum = num;
        }
    }

    return subarrays <= m;
}

// Function to find minimum largest sum
int minLargestSumSubarray(const vector<int>& nums, int m){
    int low = *max_element(nums.begin(), nums.end());   // max single element
    int high = accumulate(nums.begin(), nums.end(), 0); // sum of all elements
    int result = high;

    while(low <= high){
        int mid = low + (high - low)/2;
        if(isValidSplit(nums, m, mid)){
            result = mid;        // feasible → try smaller max
            high = mid - 1;
        } else {
            low = mid + 1;       // not feasible → increase max sum
        }
    }

    return result;
}

int main(){
    vector<int> nums = {7, 2, 5, 10, 8};
    int m = 2;

    int minLargestSum = minLargestSumSubarray(nums, m);
    cout << "Minimum largest sum = " << minLargestSum << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {7,2,5,10,8}, m=2
Low = max=10, High = sum=32

Iteration1: mid=(10+32)/2=21
Check split with maxSum=21:
  Subarray1: 7+2+5+10=24>21 → end at 7+2+5=14 → Subarray2:10 → next 8 → Subarray2 sum=18 ≤21 → total subarrays=2 ≤ m → feasible → result=21 → high=20

Iteration2: mid=(10+20)/2=15
Check split maxSum=15:
  Sub1:7+2+5=14 → next 10 → Sub2 sum=10 → next 8 → Sub3 sum=8 → total 3>2 → not feasible → low=16

Iteration3: mid=(16+20)/2=18
Check maxSum=18:
  Sub1:7+2+5=14 → next 10 → Sub2 sum=10 → next 8 → Sub2 sum=18 → total subarrays=2 → feasible → result=18 → high=17

Iteration4: mid=(16+17)/2=16
Check maxSum=16:
  Sub1:7+2+5=14 → next 10 → Sub2 sum=10 → next 8 → Sub3 sum=8 → total 3>2 → not feasible → low=17

Iteration5: mid=17
Check maxSum=17:
  Sub1:7+2+5=14 → next 10 → Sub2 sum=10 → next 8 → Sub2 sum=18>17 → Sub3 sum=8 → total subarrays=3>2 → not feasible → low=18

Loop ends → minLargestSum=18
Output: Minimum largest sum = 18

```

---

## **Question: 35 Minimum maximum element after increment/decrement Binary search on answer**

**Approach:**
Question: Minimum Maximum Element after Increment/Decrement Using Binary Search on Answer

Approach:
We are given an array. Each element can be increased or decreased by k exactly once. We need to minimize the maximum element after these operations.

Steps:

1. Search space:
   a. Low = min element after decreasing each by k = min(arr) - k
   b. High = max element after increasing each by k = max(arr) + k
2. Binary search on candidate maximum (mid):
   a. For each mid value, check if all elements can be transformed (increase or decrease by k) to be ≤ mid - For element arr[i], after transformation arr[i]-k ≤ mid and arr[i]+k ≤ mid - If any element cannot be ≤ mid → mid not feasible
   b. If feasible → try smaller maximum (high = mid-1)
   c. Else → increase maximum (low = mid+1)
3. Return low → minimum possible maximum after operations

Time Complexity: O(n log(max-min))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Function to check if we can make all elements <= maxVal after ±k operation
bool isFeasible(const vector<int>& arr, int k, int maxVal){
    for(int x : arr){
        // Each element can become x-k or x+k
        int lower = x - k;
        int upper = x + k;
        if(lower > maxVal) return false;  // Cannot reduce enough
    }
    return true;
}

// Function to find minimum maximum element after increment/decrement
int minimizeMaximum(vector<int>& arr, int k){
    int low = *min_element(arr.begin(), arr.end()) - k;  // minimal possible
    int high = *max_element(arr.begin(), arr.end()) + k; // maximal possible
    int result = high;

    while(low <= high){
        int mid = low + (high - low)/2;
        if(isFeasible(arr, k, mid)){
            result = mid;      // feasible → try smaller max
            high = mid - 1;
        } else {
            low = mid + 1;     // not feasible → increase max
        }
    }

    return result;
}

int main(){
    vector<int> arr = {1, 15, 10};
    int k = 6;

    int minMax = minimizeMaximum(arr, k);
    cout << "Minimum maximum element after ±" << k << " = " << minMax << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {1,15,10}, k=6
Initial low = min-6 = 1-6=-5, high = max+6=15+6=21

Check mid = (low+high)/2 = 8
Can each element ≤ 8 after ±6?
  1: 1-6=-5 ≤8 → ok
  15: 15-6=9>8 → cannot → mid=8 not feasible → low=9
Next mid= (9+21)/2=15
  1:1-6=-5 ≤15 → ok
  15:15-6=9 ≤15 → ok
  10:10-6=4 ≤15 → ok → feasible → result=15 → high=14
Next mid= (9+14)/2=11
  1: -5 ≤11 → ok
  15:15-6=9 ≤11 → ok
  10:10-6=4 ≤11 → ok → feasible → result=11 → high=10
Next mid=(9+10)/2=9
  1:-5≤9,15:9≤9,10:4≤9 → feasible → result=9 → high=8
Loop ends → minMax=9

Output: Minimum maximum element after ±6 = 9

```

---

## **Question: 36 Split array to minimize maximum sum Binary search on answer**

**Approach:**
Question: Split Array to Minimize Maximum Sum Using Binary Search on Answer

Approach:
We are given an array and need to split it into at most m contiguous subarrays such that the largest sum among subarrays is minimized.

Steps:

1. The search space for maximum subarray sum:
   a. Low = max element of array → at least one element per subarray
   b. High = sum of all elements → all elements in one subarray
2. Binary search on maximum subarray sum (mid):
   a. Check if array can be split into ≤ m subarrays with sum ≤ mid - Keep adding elements to current subarray - If current sum > mid → start new subarray - Count number of subarrays - If subarrays > m → mid not feasible
   b. If feasible → try smaller maximum sum (high = mid-1)
   c. Else → increase maximum sum (low = mid+1)
3. Return low → minimum possible maximum sum after splitting

Time Complexity: O(n \* log(sum-max))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
using namespace std;

// Helper: check if we can split array into <= m subarrays with sum <= maxSum
bool canSplit(const vector<int>& nums, int m, int maxSum){
    int subarrays = 1;
    int currentSum = 0;

    for(int num : nums){
        if(num > maxSum) return false; // single element exceeds maxSum
        if(currentSum + num <= maxSum){
            currentSum += num;          // Add to current subarray
        } else {
            subarrays++;                // Start new subarray
            currentSum = num;
        }
    }

    return subarrays <= m;
}

// Function to find minimum maximum sum after splitting
int splitArrayMinMaxSum(const vector<int>& nums, int m){
    int low = *max_element(nums.begin(), nums.end()); // max single element
    int high = accumulate(nums.begin(), nums.end(), 0); // sum of all elements
    int result = high;

    while(low <= high){
        int mid = low + (high - low)/2;
        if(canSplit(nums, m, mid)){
            result = mid;       // feasible → try smaller max
            high = mid - 1;
        } else {
            low = mid + 1;      // not feasible → increase max sum
        }
    }

    return result;
}

int main(){
    vector<int> nums = {7, 2, 5, 10, 8};
    int m = 2;

    int minMaxSum = splitArrayMinMaxSum(nums, m);
    cout << "Minimum maximum sum after splitting = " << minMaxSum << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {7,2,5,10,8}, m=2
Low = max=10, High = sum=32

Iteration1: mid=(10+32)/2=21
Check split with maxSum=21:
  Subarray1: 7+2+5+10=24>21 → end at 7+2+5=14 → Subarray2:10 → next 8 → sum=18 ≤21 → total subarrays=2 ≤ m → feasible → result=21 → high=20

Iteration2: mid=(10+20)/2=15
Check maxSum=15:
  Sub1:7+2+5=14 → next 10 → Sub2 sum=10 → next 8 → Sub3 sum=8 → total 3>2 → not feasible → low=16

Iteration3: mid=(16+20)/2=18
Check maxSum=18:
  Sub1:7+2+5=14 → next 10 → Sub2 sum=10 → next 8 → Sub2 sum=18 → total subarrays=2 → feasible → result=18 → high=17

Iteration4: mid=(16+17)/2=16
Check maxSum=16:
  Sub1:7+2+5=14 → next 10 → Sub2 sum=10 → next 8 → Sub3 sum=8 → total 3>2 → not feasible → low=17

Iteration5: mid=17
Check maxSum=17:
  Sub1:7+2+5=14 → next 10 → Sub2 sum=10 → next 8 → Sub3 sum=8 → total 3>2 → not feasible → low=18

Loop ends → minMaxSum=18
Output: Minimum maximum sum after splitting = 18

```

---

## **Question: 37 Koko eating bananas Binary search on answer**

**Approach:**
Question: Koko Eating Bananas Using Binary Search on Answer

Approach:
We are given piles of bananas and H hours. Koko can eat k bananas per hour. We need to find the minimum integer k (eating speed) to finish all bananas within H hours.

Steps:

1. Search space for eating speed k:
   a. Low = 1 (eat at least 1 banana/hour)
   b. High = max(piles) (eat all of the largest pile in 1 hour)
2. Binary search on k (mid):
   a. For each pile, hours required = ceil(pile/mid)
   b. Sum total hours for all piles
   c. If totalHours ≤ H → feasible → try smaller k (high = mid-1)
   d. Else → increase k (low = mid+1)
3. Return low → minimum eating speed to finish all piles

Time Complexity: O(n log(maxPile))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Helper: check if Koko can eat all bananas at speed k within H hours
bool canEatAll(const vector<int>& piles, int k, int H){
    long long hours = 0;
    for(int pile : piles){
        // Hours needed = ceil(pile/k) = (pile + k - 1)/k
        hours += (pile + k - 1)/k;
    }
    return hours <= H;
}

// Function to find minimum eating speed
int minEatingSpeed(vector<int>& piles, int H){
    int low = 1;
    int high = *max_element(piles.begin(), piles.end());
    int result = high;

    while(low <= high){
        int mid = low + (high - low)/2; // candidate speed
        if(canEatAll(piles, mid, H)){
            result = mid;      // feasible → try smaller speed
            high = mid - 1;
        } else {
            low = mid + 1;     // not feasible → increase speed
        }
    }

    return result;
}

int main(){
    vector<int> piles = {3, 6, 7, 11};
    int H = 8;

    int speed = minEatingSpeed(piles, H);
    cout << "Minimum eating speed = " << speed << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Piles = {3,6,7,11}, H=8
Low=1, High=11

Iteration1: mid=(1+11)/2=6
Hours needed: (3+6-1)/6=1, (6+6-1)/6=1, (7+6-1)/6=2, (11+6-1)/6=2 → total=6 ≤8 → feasible → result=6 → high=5

Iteration2: mid=(1+5)/2=3
Hours: (3+2)/3=1, (6+2)/3=2, (7+2)/3=3, (11+2)/3=4 → total=10>8 → not feasible → low=4

Iteration3: mid=(4+5)/2=4
Hours: (3+3)/4=1, (6+3)/4=2, (7+3)/4=2, (11+3)/4=3 → total=8 ≤8 → feasible → result=4 → high=3

Loop ends → minimum speed = 4
Output: Minimum eating speed = 4

```

---

## **Question: 38 Find sqrt/floor using binary search Binary search on value**

**Approach:**
Question: Find Square Root / Floor Using Binary Search on Value

Approach:
We are given a non-negative integer n. We need to find floor(sqrt(n)) using binary search.

Steps:

1. Search space:
   a. Low = 0
   b. High = n
2. Binary search:
   a. mid = (low + high)/2
   b. If mid*mid == n → exact sqrt → return mid
   c. If mid*mid < n → mid could be answer → store mid, try larger → low=mid+1
   d. Else → mid\*mid > n → too large → high=mid-1
3. Return stored answer → floor(sqrt(n))

Time Complexity: O(log n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Function to find floor of sqrt using binary search
int floorSqrt(int n){
    if(n==0 || n==1) return n;  // Handle 0 and 1

    int low = 0, high = n, ans = 0;

    while(low <= high){
        int mid = low + (high - low)/2;

        if((long long)mid*mid == n) return mid; // Exact sqrt
        else if((long long)mid*mid < n){
            ans = mid;          // Possible floor
            low = mid + 1;      // Try larger
        } else {
            high = mid - 1;     // mid too large
        }
    }

    return ans;                // Floor of sqrt
}

int main(){
    int n = 27;

    int sqrtFloor = floorSqrt(n);
    cout << "Floor of sqrt(" << n << ") = " << sqrtFloor << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
n=27
Low=0, High=27

Iteration1: mid=(0+27)/2=13 → 13*13=169>27 → high=12
Iteration2: mid=(0+12)/2=6 → 6*6=36>27 → high=5
Iteration3: mid=(0+5)/2=2 → 2*2=4<27 → ans=2 → low=3
Iteration4: mid=(3+5)/2=4 → 4*4=16<27 → ans=4 → low=5
Iteration5: mid=(5+5)/2=5 → 5*5=25<27 → ans=5 → low=6

Loop ends → floor sqrt = 5
Output: Floor of sqrt(27) = 5

```

---

## **Question: 39 Find cube root / nth root using binary search Binary search on value**

**Approach:**
Question: Find Cube Root / Nth Root Using Binary Search on Value

Approach:
We are given a number n and need to find floor(cbrt(n)) or floor(nth_root(n)) using binary search.

Steps:

1. For nth root, the search space:
   a. Low = 0
   b. High = n
2. Binary search:
   a. mid = (low + high)/2
   b. Compute mid^n (careful with large numbers using long long)
   c. If mid^n == n → exact root → return mid
   d. If mid^n < n → mid could be answer → store mid, try larger → low = mid+1
   e. Else → mid^n > n → too large → high = mid-1
3. Return stored answer → floor(nth_root(n))

Time Complexity: O(log n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Function to compute mid^n safely using long long
long long power(long long mid, int n){
    long long res = 1;
    for(int i = 0; i < n; i++){
        res *= mid;
        if(res < 0) return LLONG_MAX; // overflow protection
    }
    return res;
}

// Function to find floor of nth root of num
long long floorNthRoot(long long num, int n){
    if(num==0 || num==1) return num; // Edge cases

    long long low = 0, high = num, ans = 0;

    while(low <= high){
        long long mid = low + (high - low)/2;
        long long midPow = power(mid, n);

        if(midPow == num) return mid;   // Exact root
        else if(midPow < num){
            ans = mid;                  // Possible floor
            low = mid + 1;              // Try larger
        } else {
            high = mid - 1;             // mid too large
        }
    }

    return ans;                        // Floor of nth root
}

int main(){
    long long num = 27;
    int n = 3; // Cube root

    long long root = floorNthRoot(num, n);
    cout << "Floor of " << n << "th root of " << num << " = " << root << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
num=27, n=3
Low=0, High=27

Iteration1: mid=(0+27)/2=13 → 13^3=2197>27 → high=12
Iteration2: mid=(0+12)/2=6 → 6^3=216>27 → high=5
Iteration3: mid=(0+5)/2=2 → 2^3=8<27 → ans=2 → low=3
Iteration4: mid=(3+5)/2=4 → 4^3=64>27 → high=3
Iteration5: mid=(3+3)/2=3 → 3^3=27==27 → exact → return 3

Output: Floor of 3th root of 27 = 3

```

---

## **Question: 40 Search in bitonic array Find peak → binary search sides**

**Approach:**
Question: Search in Bitonic Array Using Binary Search

Approach:
A bitonic array first strictly increases then strictly decreases. We are given a key and need to find its index.

Steps:

1. Find the peak element (maximum) in bitonic array using binary search:
   a. mid = (low + high)/2
   b. If arr[mid] > arr[mid-1] && arr[mid] > arr[mid+1] → peak found
   c. If arr[mid] < arr[mid+1] → peak on right → low = mid+1
   d. Else → peak on left → high = mid-1
2. Binary search key in increasing part (0 → peak)
3. Binary search key in decreasing part (peak+1 → n-1) using reverse binary search
4. Return index if found, else -1

Time Complexity: O(log n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find peak index in bitonic array
int findPeak(const vector<int>& arr){
    int low = 0, high = arr.size()-1;

    while(low <= high){
        int mid = low + (high - low)/2;
        if(mid > 0 && mid < arr.size()-1){
            if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid+1])
                return mid;                 // Peak found
            else if(arr[mid] < arr[mid+1])
                low = mid + 1;              // Peak on right
            else
                high = mid - 1;             // Peak on left
        } else if(mid == 0){
            return arr[0] > arr[1] ? 0 : 1;
        } else if(mid == arr.size()-1){
            return arr[arr.size()-1] > arr[arr.size()-2] ? arr.size()-1 : arr.size()-2;
        }
    }
    return -1;
}

// Binary search in increasing order
int binarySearchInc(const vector<int>& arr, int low, int high, int key){
    while(low <= high){
        int mid = low + (high - low)/2;
        if(arr[mid] == key) return mid;
        else if(arr[mid] < key) low = mid +1;
        else high = mid -1;
    }
    return -1;
}

// Binary search in decreasing order
int binarySearchDec(const vector<int>& arr, int low, int high, int key){
    while(low <= high){
        int mid = low + (high - low)/2;
        if(arr[mid] == key) return mid;
        else if(arr[mid] > key) low = mid +1;   // reversed
        else high = mid -1;
    }
    return -1;
}

// Function to search key in bitonic array
int searchBitonic(const vector<int>& arr, int key){
    int peak = findPeak(arr);

    int idx = binarySearchInc(arr, 0, peak, key);   // Search increasing part
    if(idx != -1) return idx;
    return binarySearchDec(arr, peak+1, arr.size()-1, key); // Search decreasing part
}

int main(){
    vector<int> arr = {1, 3, 8, 12, 4, 2};
    int key = 4;

    in

// End of code
```

**Dry Run:**

```cpp
Array = {1,3,8,12,4,2}, key=4

Step1: Find peak
  mid=2, arr[2]=8, arr[1]=3, arr[3]=12 → 8<12 → move right → low=3
  mid=3, arr[3]=12, arr[2]=8, arr[4]=4 → 12>8 && 12>4 → peak=3

Step2: Search increasing part (0→3)
  binary search: 1,3,8,12 → key=4 → not found → returns -1

Step3: Search decreasing part (4→5)
  arr[4]=4 → found → index=4

Output: Key found at index 4

```

---

## **Question: Title**

**Approach:**
Question: Find Peak Element in 1D Array Using Binary Search Variant

Approach:
A peak element is greater than its neighbors. For corner elements, only one neighbor is considered. The goal is to find any peak element efficiently using binary search.

Steps:

1. Initialize search space: low = 0, high = n-1
2. While low <= high:
   a. mid = (low + high)/2
   b. If mid is peak → return mid - If mid==0 → compare with arr[1] - If mid==n-1 → compare with arr[n-2] - Else → compare with arr[mid-1] and arr[mid+1]
   c. If arr[mid] < arr[mid+1] → move right → low = mid+1
   d. Else → move left → high = mid-1
3. Return the peak index found

Time Complexity: O(log n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find a peak element in 1D array
int findPeak1D(const vector<int>& arr){
    int n = arr.size();
    int low = 0, high = n-1;

    while(low <= high){
        int mid = low + (high - low)/2;

        // Check if mid is peak
        bool leftOK = (mid==0) || (arr[mid] > arr[mid-1]);
        bool rightOK = (mid==n-1) || (arr[mid] > arr[mid+1]);

        if(leftOK && rightOK) return mid; // Peak found

        if(mid < n-1 && arr[mid] < arr[mid+1]) low = mid + 1; // Move right
        else high = mid -1;                                   // Move left
    }

    return -1; // Should never reach here if array has at least one peak
}

int main(){
    vector<int> arr = {1, 3, 20, 4, 1, 0};

    int peakIndex = findPeak1D(arr);
    cout << "Peak element at index " << peakIndex
         << " = " << arr[peakIndex] << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {1,3,20,4,1,0}

Iteration1: low=0, high=5, mid=2
  arr[2]=20, arr[1]=3, arr[3]=4
  leftOK = 20>3=true
  rightOK=20>4=true → peak found
Output: Peak element at index 2 = 20

```

---

## **Question: 42 Minimum days to complete jobs (CP) Binary search on answer**

**Approach:**
Question: Minimum Days to Complete Jobs Using Binary Search on Answer

Approach:
We are given an array of job sizes (work units) and a number of workers. Each worker can do jobs in sequence. We need to find the minimum number of days to complete all jobs, assuming each worker works on contiguous jobs per day.

Steps:

1. Define search space for days:
   a. Low = max(job sizes) → a worker must at least do the largest job
   b. High = sum of all job sizes → one worker does all jobs in one day
2. Binary search on candidate days (mid):
   a. Count required workers if maximum work per worker = mid - Assign jobs sequentially - If current sum + job > mid → assign new worker - Count workers
   b. If workers required ≤ given workers → feasible → try smaller days (high=mid-1)
   c. Else → increase days (low=mid+1)
3. Return low → minimum number of days to finish jobs

Time Complexity: O(n log(sum-max))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
using namespace std;

// Helper: check if all jobs can be done in <= given workers with maxWorkPerDay
bool canComplete(const vector<int>& jobs, int workers, int maxWorkPerDay){
    int requiredWorkers = 1;     // Start with first worker
    int currentLoad = 0;

    for(int job : jobs){
        if(job > maxWorkPerDay) return false; // Single job exceeds maxWorkPerDay
        if(currentLoad + job <= maxWorkPerDay){
            currentLoad += job;  // Assign to current worker
        } else {
            requiredWorkers++;   // Assign new worker
            currentLoad = job;
        }
    }

    return requiredWorkers <= workers;
}

// Function to find minimum days to complete jobs
int minDaysToCompleteJobs(const vector<int>& jobs, int workers){
    int low = *max_element(jobs.begin(), jobs.end()); // minimum possible
    int high = accumulate(jobs.begin(), jobs.end(), 0); // maximum possible
    int result = high;

    while(low <= high){
        int mid = low + (high - low)/2;
        if(canComplete(jobs, workers, mid)){
            result = mid;        // feasible → try smaller
            high = mid -1;
        } else {
            low = mid +1;        // not feasible → increase max per day
        }
    }

    return result;
}

int main(){
    vector<int> jobs = {7,2,5,10,8};
    int workers = 2;

    int minDays = minDaysToCompleteJobs(jobs, workers);
    cout << "Minimum days to complete jobs = " << minDays << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Jobs = {7,2,5,10,8}, workers=2
Low = max=10, High = sum=32

Iteration1: mid=(10+32)/2=21
  Assign jobs: 7+2+5=14 → next 10 → new worker sum=10 → next 8 → sum=18 → workers used=2 ≤2 → feasible → result=21 → high=20

Iteration2: mid=(10+20)/2=15
  Assign jobs: 7+2+5=14 → next 10 → new worker sum=10 → next 8 → new worker sum=8 → workers used=3>2 → not feasible → low=16

Iteration3: mid=(16+20)/2=18
  Assign jobs: 7+2+5=14 → next 10 → new worker sum=10 → next 8 → sum=18 → workers used=2 ≤2 → feasible → result=18 → high=17

Iteration4: mid=(16+17)/2=16
  Assign jobs: 7+2+5=14 → next 10 → new worker sum=10 → next 8 → new worker sum=8 → workers used=3>2 → not feasible → low=17

Iteration5: mid=17
  Assign jobs: 7+2+5=14 → next 10 → new worker sum=10 → next 8 → new worker sum=8 → workers used=3>2 → not feasible → low=18

Loop ends → minDays=18
Output: Minimum days to complete jobs = 18

```

---

## **Question: 43 Max distance to closest person (LeetCode style) Binary search on answer**

**Approach:**
Question: Max Distance to Closest Person Using Binary Search on Answer

Approach:
We are given an array representing seats (0=empty, 1=occupied). We want to place a new person in an empty seat so that the distance to the closest person is maximized.

Steps:

1. Define search space for distance:
   a. Low = 0
   b. High = n (max possible distance)
2. Binary search on distance (mid):
   a. Check if there exists an empty seat such that distance to closest occupied seat >= mid - Scan array, keep track of last occupied seat - Compute distances
   b. If possible → feasible → try larger distance (low=mid+1)
   c. Else → decrease distance (high=mid-1)
3. Return largest feasible distance

Time Complexity: O(n log n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Helper: check if distance d is feasible
bool isFeasible(const vector<int>& seats, int d){
    int lastOccupied = -1; // last occupied seat index
    int n = seats.size();

    for(int i=0;i<n;i++){
        if(seats[i]==1){
            lastOccupied = i;
        } else {
            int leftDist = lastOccupied == -1 ? n : i - lastOccupied;
            int rightDist = n; // distance to next occupied
            for(int j=i+1;j<n;j++){
                if(seats[j]==1){
                    rightDist = j-i;
                    break;
                }
            }
            int closest = min(leftDist, rightDist);
            if(closest >= d) return true;
        }
    }
    return false;
}

// Function to find max distance to closest person
int maxDistToClosest(vector<int>& seats){
    int low = 0, high = seats.size(), result = 0;

    while(low <= high){
        int mid = low + (high - low)/2;
        if(isFeasible(seats, mid)){
            result = mid;       // feasible → try larger
            low = mid + 1;
        } else {
            high = mid -1;      // not feasible → try smaller
        }
    }

    return result;
}

int main(){
    vector<int> seats = {1,0,0,0,1,0,1};

    int maxDist = maxDistToClosest(seats);
    cout << "Maximum distance to closest person = " << maxDist << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Seats = {1,0,0,0,1,0,1}

Binary search distance:
Low=0, High=7

Iteration1: mid=3
  Check if distance 3 feasible → positions 2,3: closest occupied <3 → not feasible
  high=2

Iteration2: mid=1
  Check distance 1 → feasible → result=1 → try larger → low=2

Iteration3: mid=2
  Check distance 2 → feasible (seat 2 or 3) → result=2 → try larger → low=3

Loop ends → maximum distance = 2
Output: Maximum distance to closest person = 2

```

---

## **Question: 44 Allocate minimum maximum time for machines Binary search on answer**

**Approach:**
Question: Allocate Minimum Maximum Time for Machines Using Binary Search on Answer

Approach:
We are given an array of job times and m machines. Each machine can process consecutive jobs. The goal is to allocate jobs such that maximum time taken by any machine is minimized.

Steps:

1. Define search space:
   a. Low = max(job times) → minimum time required by a machine
   b. High = sum of all job times → one machine does all jobs
2. Binary search on candidate maximum time (mid):
   a. Count required machines if max per machine = mid - Assign jobs sequentially - If current sum + job > mid → assign to next machine - Count machines
   b. If required machines ≤ m → feasible → try smaller maximum time (high=mid-1)
   c. Else → increase maximum time (low=mid+1)
3. Return low → minimum possible maximum time per machine

Time Complexity: O(n log(sum-max))  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
using namespace std;

// Helper: check if all jobs can be allocated to m machines within maxTime
bool canAllocate(const vector<int>& jobs, int machines, int maxTime){
    int required = 1;       // Start with first machine
    int currentSum = 0;

    for(int job : jobs){
        if(job > maxTime) return false; // Single job exceeds maxTime
        if(currentSum + job <= maxTime){
            currentSum += job;          // Assign to current machine
        } else {
            required++;                 // Assign new machine
            currentSum = job;
        }
    }

    return required <= machines;
}

// Function to find minimum maximum time per machine
int minMaxTime(vector<int>& jobs, int machines){
    int low = *max_element(jobs.begin(), jobs.end());
    int high = accumulate(jobs.begin(), jobs.end(), 0);
    int result = high;

    while(low <= high){
        int mid = low + (high - low)/2;
        if(canAllocate(jobs, machines, mid)){
            result = mid;        // feasible → try smaller
            high = mid -1;
        } else {
            low = mid +1;        // not feasible → increase maxTime
        }
    }

    return result;
}

int main(){
    vector<int> jobs = {10, 20, 30, 40};
    int machines = 2;

    int minTime = minMaxTime(jobs, machines);
    cout << "Minimum maximum time per machine = " << minTime << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Jobs = {10,20,30,40}, Machines = 2
Low=max=40, High=sum=100

Iteration1: mid=(40+100)/2=70
  Assign: 10+20+30=60 → next 40 → new machine → machines used=2 ≤2 → feasible → result=70 → high=69

Iteration2: mid=(40+69)/2=54
  Assign: 10+20=30 → next 30 → new machine → next 40 → new machine → machines used=3>2 → not feasible → low=55

Iteration3: mid=(55+69)/2=62
  Assign: 10+20+30=60 → next 40 → new machine → machines used=2 → feasible → result=62 → high=61

Iteration4: mid=(55+61)/2=58
  Assign: 10+20+30=60 → exceeds 58 → new machine → next 40 → new machine → machines used=3>2 → not feasible → low=59

Iteration5: mid=(59+61)/2=60
  Assign: 10+20+30=60 → next 40 → new machine → machines used=2 → feasible → result=60 → high=59

Loop ends → minMaxTime=60
Output: Minimum maximum time per machine = 60

```

---

## **Question: 45 Search in unknown size array / virtual array Binary search variant**

**Approach:**
Question: Search in Unknown Size / Virtual Array Using Binary Search

Approach:
We are given an array-like structure where size is unknown. Accessing out-of-bounds may throw error or return INF. Goal is to search for a key efficiently.

Steps:

1. Exponentially find bounds:
   a. Initialize index = 1
   b. While element at index < key → double index (1,2,4,8,...)
   c. This gives a range [index/2, index] that may contain the key
2. Perform binary search within found bounds:
   a. mid = (low + high)/2
   b. Compare mid with key → adjust low/high accordingly
3. Return index if found, else -1

Time Complexity: O(log n) (first find range log n + binary search log n)  
Space Complexity: O(1)

**Code:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to perform binary search in known range
int binarySearch(const vector<int>& arr, int low, int high, int key){
    while(low <= high){
        int mid = low + (high - low)/2;
        if(arr[mid] == key) return mid;
        else if(arr[mid] < key) low = mid +1;
        else high = mid -1;
    }
    return -1;
}

// Function to search in unknown size array
int searchUnknownSize(const vector<int>& arr, int key){
    int index = 1;

    // Exponentially find the bound
    while(index < arr.size() && arr[index] < key){
        index *= 2;
    }

    // Binary search within found range
    int low = index/2;
    int high = min(index, (int)arr.size()-1);

    return binarySearch(arr, low, high, key);
}

int main(){
    vector<int> arr = {1,3,5,7,9,12,15,18,20};
    int key = 12;

    int idx = searchUnknownSize(arr, key);
    if(idx != -1) cout << "Key found at index " << idx << endl;
    else cout << "Key not found" << endl;

    return 0;
}
// End of code

// End of code
```

**Dry Run:**

```cpp
Array = {1,3,5,7,9,12,15,18,20}, key=12

Step1: Exponentially find bound
  index=1 → arr[1]=3 <12 → index=2
  index=2 → arr[2]=5 <12 → index=4
  index=4 → arr[4]=9 <12 → index=8
  index=8 → arr[8]=20 ≥12 → bound found [4,8]

Step2: Binary search in [4,8]
  mid=(4+8)/2=6 → arr[6]=15>12 → high=5
  mid=(4+5)/2=4 → arr[4]=9<12 → low=5
  mid=5 → arr[5]=12 → found → return 5

Output: Key found at index 5

```

---
