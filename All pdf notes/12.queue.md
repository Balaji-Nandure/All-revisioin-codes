## **Question: Implement queue using array**

**Approach:**
PROBLEM STATEMENT:
Implement a simple queue using a fixed-size array supporting:

1. enqueue(x) → insert element at rear
2. dequeue() → remove element from front
3. peek() → get front element
4. isEmpty() → check if queue is empty
5. isFull() → check if queue is full

Queue follows FIFO (First-In-First-Out).

---

APPROACH:

BRUTE FORCE:

1. Use a simple array of size N.
2. Maintain two pointers:
   - front → index of first element (starts at 0)
   - rear → index of last element (starts at -1)
3. enqueue(x):
   - If rear < capacity-1, increment rear and insert element.
   - Else → queue overflow.
4. dequeue():
   - If front <= rear, increment front → removes element.
   - Else → queue underflow.
5. peek() → return arr[front] if not empty.
6. size = rear - front + 1

OPTIMAL:

- For basic queue using array, above is sufficient.
- Circular wrap-around not needed here.
- All operations O(1) time.

**Code:**

```cpp
#include <iostream>
using namespace std;

class Queue {
    int *arr;      // array to store elements
    int capacity;  // max size
    int front;     // index of front element
    int rear;      // index of last element

public:
    Queue(int size) {
        arr = new int[size];  // allocate array
        capacity = size;
        front = 0;            // front at 0
        rear = -1;            // rear before start
    }

    void enqueue(int x) {
        if (rear == capacity - 1) {       // check overflow
            cout << "Queue Overflow! Cannot insert " << x << endl;
            return;
        }
        rear++;                  // move rear
        arr[rear] = x;           // insert element
        cout << "Inserted " << x << endl;
    }

    void dequeue() {
        if (front > rear) {      // check underflow
            cout << "Queue Underflow! Nothing to remove" << endl;
            return;
        }
        cout << "Removed " << arr[front] << endl;
        front++;                 // move front
    }

    int peek() {
        if (front > rear) {
            cout << "Queue is empty\n";
            return -1;
        }
        return arr[front];       // return front element
    }

    bool isEmpty() { return front > rear; }
    bool isFull() { return rear == capacity - 1; }
    int size() { return rear - front + 1; }
};

// ----------------------
// Driver Code
// ----------------------
int main() {
    Queue q(5);

    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);

    cout << "Front element: " << q.peek() << endl;

    q.dequeue();
    q.enqueue(40);
    q.enqueue(50);
    q.enqueue(60); // overflow here

    cout << "Queue size: " << q.size() << endl;

    q.dequeue();
    q.dequeue();
    q.dequeue();
    q.dequeue(); // underflow

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Capacity = 5, front=0, rear=-1

enqueue(10) → rear=0, arr[0]=10
enqueue(20) → rear=1, arr[1]=20
enqueue(30) → rear=2, arr[2]=30
peek() → arr[front]=arr[0]=10
dequeue() → removes arr[0]=10, front=1
enqueue(40) → rear=3, arr[3]=40
enqueue(50) → rear=4, arr[4]=50
enqueue(60) → rear=5 → Overflow
size() → rear-front+1 = 4
dequeue x4 → removes 20,30,40,50
next dequeue → Underflow

```

---

## **Question: Implement queue using linked list**

**Approach:**
PROBLEM STATEMENT:
Implement a queue using a linked list supporting:

1. enqueue(x) → insert element at rear
2. dequeue() → remove element from front
3. peek() → get front element
4. isEmpty() → check if queue is empty

Queue follows FIFO (First-In-First-Out).

---

APPROACH:

BRUTE FORCE:

- Use a singly linked list.
- Maintain two pointers:
  1.  front → points to first node
  2.  rear → points to last node
- enqueue(x):
  - Create a new node
  - Attach it at rear->next
  - Move rear to new node
- dequeue():
  - Remove front node
  - Move front to front->next
- peek():
  - Return front->data
- isEmpty():
  - front == NULL

OPTIMAL:

- Same as above (linked list naturally supports dynamic size)
- All operations O(1) time
- No overflow issues (dynamic memory)

**Code:**

```cpp
#include <iostream>
using namespace std;

// Node of linked list
struct Node {
    int data;       // store value
    Node* next;     // pointer to next node
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

class Queue {
    Node* front;    // pointer to first element
    Node* rear;     // pointer to last element

public:
    Queue() {
        front = rear = nullptr; // initially empty
    }

    void enqueue(int x) {
        Node* temp = new Node(x); // create new node
        if (rear == nullptr) {    // empty queue
            front = rear = temp;
            return;
        }
        rear->next = temp;        // attach at rear
        rear = temp;              // move rear pointer
    }

    void dequeue() {
        if (front == nullptr) {   // empty queue
            cout << "Queue Underflow!" << endl;
            return;
        }
        Node* temp = front;       // store front
        front = front->next;      // move front
        if (front == nullptr) {   // queue became empty
            rear = nullptr;
        }
        cout << "Removed " << temp->data << endl;
        delete temp;              // free memory
    }

    int peek() {
        if (front == nullptr) {
            cout << "Queue is empty\n";
            return -1;
        }
        return front->data;       // front element
    }

    bool isEmpty() { return front == nullptr; }
};

// ----------------------
// Driver Code
// ----------------------
int main() {
    Queue q;

    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);

    cout << "Front element: " << q.peek() << endl; // 10

    q.dequeue();
    q.enqueue(40);
    q.enqueue(50);

    q.dequeue();
    q.dequeue();
    q.dequeue();
    q.dequeue(); // underflow

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Queue initially: front=null, rear=null

enqueue(10) → new node(10), front=rear=node10
enqueue(20) → attach node20 at rear, rear=node20
enqueue(30) → attach node30 at rear, rear=node30

peek() → front=10

dequeue() → remove front(10), front=node20
enqueue(40) → attach node40 at rear, rear=node40
enqueue(50) → attach node50 at rear, rear=node50

dequeue → remove 20
dequeue → remove 30
dequeue → remove 40
dequeue → remove 50
next dequeue → underflow

```

---

## **Question: Circular queue using array**

**Approach:**
PROBLEM STATEMENT:
Implement a circular queue using a fixed-size array supporting:

1. enqueue(x) → insert element at rear
2. dequeue() → remove element from front
3. peek() → get front element
4. isEmpty() → check if queue is empty
5. isFull() → check if queue is full

Queue follows FIFO (First-In-First-Out) and reuses freed space (circular wrap).

---

APPROACH:

BRUTE FORCE:

- Simple array queue wastes space once rear reaches end.
- Cannot reuse empty slots at front.

OPTIMAL (Circular Queue):

1. Maintain front, rear pointers and current size (count).
2. Enqueue:
   - If not full, rear = (rear + 1) % capacity → arr[rear] = x → count++
3. Dequeue:
   - If not empty, front = (front + 1) % capacity → count--
4. Peek:
   - Return arr[front] if not empty
5. isEmpty → count == 0
6. isFull → count == capacity
7. Advantages:
   - All operations O(1)
   - Efficient space utilization

**Code:**

```cpp
#include <iostream>
using namespace std;

class CircularQueue {
    int *arr;       // array to store queue elements
    int capacity;   // max size
    int front;      // index of front element
    int rear;       // index of last element
    int count;      // current number of elements

public:
    CircularQueue(int size) {
        arr = new int[size];   // allocate array
        capacity = size;
        front = 0;             // front at 0
        rear = -1;             // rear before start
        count = 0;             // empty queue
    }

    void enqueue(int x) {
        if (isFull()) {       // check overflow
            cout << "Queue Overflow! Cannot insert " << x << endl;
            return;
        }
        rear = (rear + 1) % capacity; // circular increment
        arr[rear] = x;                // insert element
        count++;                       // increase size
        cout << "Inserted " << x << endl;
    }

    void dequeue() {
        if (isEmpty()) {      // check underflow
            cout << "Queue Underflow!\n";
            return;
        }
        cout << "Removed " << arr[front] << endl;
        front = (front + 1) % capacity; // circular increment
        count--;                        // decrease size
    }

    int peek() {
        if (isEmpty()) {
            cout << "Queue is empty\n";
            return -1;
        }
        return arr[front];    // front element
    }

    bool isEmpty() { return count == 0; }
    bool isFull() { return count == capacity; }
    int size() { return count; }
};

// ----------------------
// Driver Code
// ----------------------
int main() {
    CircularQueue q(5); // size 5

    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    q.enqueue(50);

    q.enqueue(60); // overflow test

    cout << "Front element: " << q.peek() << endl;

    q.dequeue();
    q.dequeue();

    q.enqueue(60); // now insertion works due to circular wrap
    q.enqueue(70); // again insertion

    while(!q.isEmpty()) q.dequeue(); // empty the queue

    q.dequeue(); // underflow test

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Capacity = 5, front=0, rear=-1, count=0

enqueue(10) → rear=( -1+1)%5=0, arr[0]=10, count=1
enqueue(20) → rear=(0+1)%5=1, arr[1]=20, count=2
enqueue(30) → rear=2, arr[2]=30, count=3
enqueue(40) → rear=3, arr[3]=40, count=4
enqueue(50) → rear=4, arr[4]=50, count=5
enqueue(60) → overflow

dequeue() → remove arr[0]=10, front=1, count=4
dequeue() → remove arr[1]=20, front=2, count=3

enqueue(60) → rear=(4+1)%5=0, arr[0]=60, count=4
enqueue(70) → rear=(0+1)%5=1, arr[1]=70, count=5

Final queue order logically: [30,40,50,60,70] (front=2, rear=1)
dequeue all → removes 30,40,50,60,70
next dequeue → underflow

```

---

## **Question: Double-ended queue (Deque) implementation**

**Approach:**
PROBLEM STATEMENT:
Implement a double-ended queue (deque) using a fixed-size array supporting:

1. insertFront(x) → insert element at the front
2. insertRear(x) → insert element at the rear
3. deleteFront() → remove element from the front
4. deleteRear() → remove element from the rear
5. getFront() → get front element
6. getRear() → get rear element
7. isEmpty() → check if deque is empty
8. isFull() → check if deque is full

Deque allows insertion and deletion from both ends (FIFO/LIFO combined).

---

APPROACH:

1. Use a circular array of size capacity.
2. Maintain two pointers:
   - front → index of front element
   - rear → index of last element
3. Operations:

INSERT FRONT:

- If not full:
  - front = (front-1+capacity)%capacity
  - arr[front] = x

INSERT REAR:

- If not full:
  - rear = (rear+1)%capacity
  - arr[rear] = x

DELETE FRONT:

- If not empty:
  - front = (front+1)%capacity

DELETE REAR:

- If not empty:
  - rear = (rear-1+capacity)%capacity

GET FRONT/REAR:

- Return arr[front]/arr[rear] if not empty

4. Keep a count to track current size (optional, helps in isEmpty/isFull)
5. All operations O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

class Deque {
    int *arr;       // array to store elements
    int capacity;   // max size
    int front;      // index of front element
    int rear;       // index of rear element
    int count;      // current number of elements

public:
    Deque(int size) {
        arr = new int[size];
        capacity = size;
        front = 0;       // front points to first element
        rear = -1;       // rear before start
        count = 0;       // initially empty
    }

    bool isFull() { return count == capacity; }
    bool isEmpty() { return count == 0; }

    void insertFront(int x) {
        if (isFull()) {
            cout << "Deque Overflow at front!" << endl;
            return;
        }
        front = (front - 1 + capacity) % capacity; // circular decrement
        arr[front] = x;
        count++;
        cout << "Inserted " << x << " at front" << endl;
    }

    void insertRear(int x) {
        if (isFull()) {
            cout << "Deque Overflow at rear!" << endl;
            return;
        }
        rear = (rear + 1) % capacity; // circular increment
        arr[rear] = x;
        count++;
        cout << "Inserted " << x << " at rear" << endl;
    }

    void deleteFront() {
        if (isEmpty()) {
            cout << "Deque Underflow at front!" << endl;
            return;
        }
        cout << "Removed " << arr[front] << " from front" << endl;
        front = (front + 1) % capacity;
        count--;
    }

    void deleteRear() {
        if (isEmpty()) {
            cout << "Deque Underflow at rear!" << endl;
            return;
        }
        cout << "Removed " << arr[rear] << " from rear" << endl;
        rear = (rear - 1 + capacity) % capacity;
        count--;
    }

    int getFront() {
        if (isEmpty()) { cout << "Deque empty\n"; return -1; }
        return arr[front];
    }

    int getRear() {
        if (isEmpty()) { cout << "Deque empty\n"; return -1; }
        return arr[rear];
    }
};

// ----------------------
// Driver Code
// ----------------------
int main() {
    Deque dq(5);

    dq.insertRear(10);
    dq.insertRear(20);
    dq.insertFront(5);

    cout << "Front: " << dq.getFront() << endl; // 5
    cout << "Rear: " << dq.getRear() << endl;   // 20

    dq.deleteFront();
    dq.deleteRear();

    dq.insertFront(15);
    dq.insertRear(25);

    while(!dq.isEmpty()) dq.deleteFront(); // empty deque
    dq.deleteRear(); // underflow

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Capacity = 5, front=0, rear=-1, count=0

insertRear(10) → rear=0, arr[0]=10, count=1
insertRear(20) → rear=1, arr[1]=20, count=2
insertFront(5) → front=(0-1+5)%5=4, arr[4]=5, count=3

getFront → arr[front]=arr[4]=5
getRear  → arr[rear]=arr[1]=20

deleteFront → remove arr[4]=5, front=0, count=2
deleteRear → remove arr[1]=20, rear=0, count=1

insertFront(15) → front=(0-1+5)%5=4, arr[4]=15, count=2
insertRear(25) → rear=(0+1)%5=1, arr[1]=25, count=3

deleteFront x3 → removes 10,15,25
next deleteRear → underflow

```

---

## **Question: Implement a queue with dynamic array resizing**

**Approach:**
PROBLEM STATEMENT:
Implement a queue using an array that can dynamically resize when full.
Supported operations:

1. enqueue(x) → insert element at rear
2. dequeue() → remove element from front
3. peek() → get front element
4. isEmpty() → check if queue is empty
5. size() → return current number of elements

Queue follows FIFO (First-In-First-Out).

---

APPROACH:

BRUTE FORCE:

- Use a simple fixed-size array.
- When full, we cannot insert → Overflow.
- Problem: wastes memory or limits queue size.

OPTIMAL (Dynamic resizing):

1. Use a dynamically allocated array.
2. Maintain front and rear indices.
3. Maintain current capacity and size.
4. enqueue(x):
   - If size == capacity → resize array:
     a. Allocate new array double the capacity
     b. Copy existing elements from front→rear in order
     c. Reset front=0, rear=size-1
     d. Delete old array
   - Increment rear, insert element, increment size
5. dequeue():
   - Remove front element, increment front, decrement size
   - Optional: shrink array when size << capacity
6. peek() → return arr[front] if size > 0
7. All operations amortized O(1)

**Code:**

```cpp
#include <iostream>
using namespace std;

class DynamicQueue {
    int *arr;       // pointer to array storing elements
    int capacity;   // current capacity of array
    int front;      // index of front element
    int rear;       // index of last element
    int size;       // current number of elements

    // Function to resize array when full
    void resize() {
        int newCapacity = capacity * 2;            // double the capacity
        int *newArr = new int[newCapacity];        // allocate new array

        // Copy elements in order from front to rear
        for(int i = 0; i < size; i++) {
            newArr[i] = arr[(front + i) % capacity];
        }

        delete[] arr;          // free old array memory
        arr = newArr;          // point to new array
        capacity = newCapacity;
        front = 0;             // reset front to 0
        rear = size - 1;       // reset rear to last element
        cout << "Resized array to capacity " << capacity << endl;
    }

public:
    DynamicQueue(int initialCapacity = 4) {
        arr = new int[initialCapacity];  // initial allocation
        capacity = initialCapacity;
        front = 0;       // front at 0
        rear = -1;       // rear before start
        size = 0;        // initially empty
    }

    // Insert element at rear
    void enqueue(int x) {
        if(size == capacity) {  // array full, resize needed
            resize();
        }
        rear = (rear + 1) % capacity;  // circular increment
        arr[rear] = x;                 // store element
        size++;                         // increment size
        cout << "Inserted " << x << endl;
    }

    // Remove element from front
    void dequeue() {
        if(size == 0) {       // empty queue
            cout << "Queue Underflow!" << endl;
            return;
        }
        cout << "Removed " << arr[front] << endl;
        front = (front + 1) % capacity; // circular increment front
        size--;                         // decrement size
    }

    // Get front element
    int peek() {
        if(size == 0) {
            cout << "Queue is empty!" << endl;
            return -1;
        }
        return arr[front];
    }

    bool isEmpty() { return size == 0; }
    int getSize() { return size; }
};

// ----------------------
// Driver Code
// ----------------------
int main() {
    DynamicQueue q(2); // initial capacity 2

    // Inserting elements
    q.enqueue(10);   // rear=0, front=0
    q.enqueue(20);   // rear=1, front=0
    q.enqueue(30);   // triggers resize → capacity=4
    q.enqueue(40);   // rear=3
    q.enqueue(50);   // triggers resize → capacity=8

    cout << "Front element: " << q.peek() << endl; // 10

    // Removing elements
    q.dequeue(); // removes 10
    q.dequeue(); // removes 20
    q.dequeue(); // removes 30

    // Inserting more elements
    q.enqueue(60);
    q.enqueue(70);

    // Empty the queue
    while(!q.isEmpty()) q.dequeue();

    q.dequeue(); // underflow test

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Initial capacity = 2
enqueue(10) → arr=[10,_], front=0, rear=0, size=1
enqueue(20) → arr=[10,20], front=0, rear=1, size=2
enqueue(30) → size==capacity → resize to 4
  Copy old: 10,20 → new arr=[10,20,_,_], front=0, rear=1
  Insert 30 → rear=2, arr=[10,20,30,_], size=3
enqueue(40) → rear=3, arr=[10,20,30,40], size=4
enqueue(50) → size==capacity → resize to 8
  Copy old: 10,20,30,40 → new arr=[10,20,30,40,_,_,_,_], front=0, rear=3
  Insert 50 → rear=4, arr=[10,20,30,40,50,_,_,_], size=5

Front element: 10

dequeue() → remove 10, front=1, size=4
dequeue() → remove 20, front=2, size=3
dequeue() → remove 30, front=3, size=2

enqueue(60) → rear=5, arr[5]=60, size=3
enqueue(70) → rear=6, arr[6]=70, size=4

Dequeue remaining → removes 40,50,60,70
next dequeue → Queue Underflow!

```

---

## **Question: Reverse a queue**

**Approach:**
PROBLEM STATEMENT:
Given a queue, reverse its elements using stack or recursion.

Operations:

1. enqueue(x) → add element to rear
2. dequeue() → remove element from front
3. peek() → get front element

Goal: Reverse the order of elements in the queue.

---

APPROACH:

BRUTE FORCE:

1. Use an auxiliary array/vector:
   - Dequeue all elements into array.
   - Re-enqueue elements from array in reverse order.
   - Time: O(n), Space: O(n)

OPTIMAL (Using Stack):

1. Initialize an empty stack.
2. Dequeue elements from queue and push into stack.
3. Pop elements from stack and enqueue back to queue.
4. Time: O(n), Space: O(n)

OPTIMAL RECURSION (Without extra stack):

1. Base case: queue empty → return
2. Dequeue front element, call reverse on remaining queue
3. Enqueue the dequeued element back
4. Time: O(n), Space: O(n) due to recursion

**Code:**

```cpp
#include <iostream>
#include <queue>
#include <stack>
using namespace std;

// Function to reverse a queue using stack
void reverseQueue(queue<int> &q) {
    stack<int> st; // auxiliary stack

    // Step 1: Push all queue elements into stack
    while(!q.empty()) {
        st.push(q.front());   // get front element
        q.pop();              // remove from queue
    }

    // Step 2: Pop elements from stack and enqueue back to queue
    while(!st.empty()) {
        q.push(st.top());     // insert back into queue
        st.pop();             // remove from stack
    }
}

// Function to print queue
void printQueue(queue<int> q) {
    while(!q.empty()) {
        cout << q.front() << " ";
        q.pop();
    }
    cout << endl;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    queue<int> q;

    // enqueue elements
    q.push(10);
    q.push(20);
    q.push(30);
    q.push(40);
    q.push(50);

    cout << "Original Queue: ";
    printQueue(q);

    // Reverse queue
    reverseQueue(q);

    cout << "Reversed Queue: ";
    printQueue(q);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Original queue: front→ [10,20,30,40,50] ←rear

Step 1: Push into stack
stack: bottom→10 20 30 40 50←top
queue empty

Step 2: Pop from stack & enqueue back
pop 50 → enqueue → queue: [50]
pop 40 → enqueue → queue: [50,40]
pop 30 → enqueue → queue: [50,40,30]
pop 20 → enqueue → queue: [50,40,30,20]
pop 10 → enqueue → queue: [50,40,30,20,10]

Reversed queue: front→ [50,40,30,20,10] ←rear

```

---

## **Question: Generate first N binary numbers using a queue**

**Approach:**
PROBLEM STATEMENT:
Given a number N, generate the first N binary numbers (from 1 to N) in order using a queue.

Example: N=5 → 1, 10, 11, 100, 101

---

APPROACH:

BRUTE FORCE:

1. Convert every number from 1 to N into binary using built-in conversion.
2. Time: O(N log N) (log N for binary conversion)
3. Space: O(N)

OPTIMAL (Using Queue):

1. Initialize a queue of strings.
2. Enqueue "1" (first binary number).
3. Loop N times:
   a. Dequeue front element → this is the next binary number
   b. Print/store it
   c. Append "0" and "1" to it, enqueue both back into queue
4. This method generates binary numbers in order directly.
5. Time: O(N), Space: O(N) (queue stores strings)

**Code:**

```cpp
#include <iostream>
#include <queue>
using namespace std;

void generateBinaryNumbers(int N) {
    queue<string> q;      // queue to generate numbers
    q.push("1");          // first binary number

    for(int i = 0; i < N; i++) {
        string curr = q.front(); // get front element
        q.pop();                 // remove from queue

        cout << curr << " ";     // print current binary number

        // Append "0" and "1" and enqueue back
        q.push(curr + "0");
        q.push(curr + "1");
    }
    cout << endl;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    int N = 10;
    cout << "First " << N << " binary numbers: ";
    generateBinaryNumbers(N);
    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Queue initially: ["1"]

i=0:
curr="1", print 1
enqueue "10", "11" → queue=["10","11"]

i=1:
curr="10", print 10
enqueue "100","101" → queue=["11","100","101"]

i=2:
curr="11", print 11
enqueue "110","111" → queue=["100","101","110","111"]

i=3:
curr="100", print 100
enqueue "1000","1001" → queue=["101","110","111","1000","1001"]

i=4:
curr="101", print 101
enqueue "1010","1011" → queue=["110","111","1000","1001","1010","1011"]

... and so on until i=9

Final Output Sequence:
1 10 11 100 101 110 111 1000 1001 1010

```

---

## **Question: Implement queue using two stacks**

**Approach:**
PROBLEM STATEMENT:
Implement a queue using two stacks supporting:

1. enqueue(x) → insert element at rear
2. dequeue() → remove element from front
3. peek() → get front element
4. isEmpty() → check if queue is empty

Queue should follow FIFO behavior, but we can only use stack operations (LIFO).

---

APPROACH:

METHOD 1 (Costly enqueue, O(n) enqueue):

1. Maintain two stacks: s1 and s2
2. enqueue(x):
   - Move all elements from s1 → s2
   - Push x into s1
   - Move all elements back from s2 → s1
3. dequeue():
   - Pop from s1
4. peek():
   - Return top of s1
5. isEmpty:
   - s1 empty?

METHOD 2 (Costly dequeue, amortized O(1) enqueue):

1. Maintain two stacks: s1 (input stack), s2 (output stack)
2. enqueue(x):
   - Push x into s1
3. dequeue():
   - If s2 is empty:
     - Move all elements from s1 → s2
   - Pop from s2
4. peek():
   - If s2 is empty, move s1 → s2
   - Return top of s2
5. isEmpty:
   - s1.empty() && s2.empty()
6. Time Complexity: Amortized O(1) per operation for method 2

**Code:**

```cpp
#include <iostream>
#include <stack>
using namespace std;

class QueueUsingTwoStacks {
    stack<int> s1; // input stack
    stack<int> s2; // output stack

public:
    // Insert element at rear
    void enqueue(int x) {
        s1.push(x);  // push directly into input stack
        cout << "Enqueued " << x << endl;
    }

    // Remove element from front
    void dequeue() {
        if(s2.empty()) {           // output stack empty
            if(s1.empty()) {       // both stacks empty → queue empty
                cout << "Queue Underflow!\n";
                return;
            }
            // Move all elements from s1 → s2
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        cout << "Dequeued " << s2.top() << endl;
        s2.pop(); // remove front element
    }

    // Get front element
    int peek() {
        if(s2.empty()) {
            if(s1.empty()) {
                cout << "Queue is empty!\n";
                return -1;
            }
            while(!s1.empty()) {   // move elements to output stack
                s2.push(s1.top());
                s1.pop();
            }
        }
        return s2.top();
    }

    bool isEmpty() {
        return s1.empty() && s2.empty();
    }
};

// ----------------------
// Driver Code
// ----------------------
int main() {
    QueueUsingTwoStacks q;

    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);

    cout << "Front element: " << q.peek() << endl;

    q.dequeue(); // removes 10
    q.enqueue(40);
    q.dequeue(); // removes 20
    q.dequeue(); // removes 30
    q.dequeue(); // removes 40
    q.dequeue(); // underflow

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Step 1: enqueue(10)
s1=[10], s2=[]
Step 2: enqueue(20)
s1=[10,20], s2=[]
Step 3: enqueue(30)
s1=[10,20,30], s2=[]

peek():
s2 empty → move s1 → s2
s1=[], s2=[30,20,10] (top=10)
Front element: 10

dequeue():
s2 not empty → pop 10
s2=[30,20]

enqueue(40):
s1=[40], s2=[30,20]

dequeue():
s2 not empty → pop 20
s2=[30]

dequeue():
s2 not empty → pop 30
s2=[]

dequeue():
s2 empty → move s1 → s2
s1=[], s2=[40] → pop 40
s2=[]

dequeue():
both empty → Queue Underflow

```

---

## **Question: Implement k-queues in a single array**

**Approach:**
PROBLEM STATEMENT:
Implement K queues using a single array of size N, supporting:

1. enqueue(x, qn) → insert element x into queue number qn (1 ≤ qn ≤ K)
2. dequeue(qn) → remove element from queue number qn
3. isEmpty(qn) → check if queue number qn is empty
4. isFull() → check if array is full

Goal: Efficiently manage multiple queues using one array without wasting space.

---

APPROACH:

OPTIMAL (Using Auxiliary Arrays - “Efficient K Queues”):

1. Use an array `arr[N]` to store actual elements.
2. Use `front[K]` → front index of each queue.
3. Use `rear[K]` → rear index of each queue.
4. Use `next[N]` → next free slot or next element in queue.
5. Maintain `free` → beginning index of free list.
6. enqueue(x, qn):
   a. Check if free==-1 → array full
   b. Use free index to insert x
   c. Update free to next[free]
   d. If queue empty → front[qn]=i else next[rear[qn]]=i
   e. Update rear[qn]=i, next[i]=-1
7. dequeue(qn):
   a. If front[qn]==-1 → queue empty
   b. Get index i = front[qn]
   c. Move front[qn] = next[i]
   d. Add i to free list: next[i]=free, free=i
   e. Return arr[i]
8. Time Complexity: O(1) for enqueue and dequeue
9. Space Complexity: O(N + K)

**Code:**

```cpp
#include <iostream>
using namespace std;

class KQueue {
    int *arr;    // array to store elements
    int *front;  // front indices of k queues
    int *rear;   // rear indices of k queues
    int *next;   // next indices or free list
    int n, k;    // n=size of array, k=number of queues
    int free;    // beginning index of free list

public:
    KQueue(int k1, int n1) {
        k = k1; n = n1;
        arr = new int[n];
        front = new int[k];
        rear = new int[k];
        next = new int[n];

        // initialize all queues as empty
        for(int i=0;i<k;i++) front[i]=-1, rear[i]=-1;

        // initialize free list
        for(int i=0;i<n-1;i++) next[i]=i+1;
        next[n-1]=-1;
        free=0; // first free index
    }

    bool isFull() { return free==-1; }
    bool isEmpty(int qn) { return front[qn]==-1; }

    void enqueue(int x, int qn) {
        if(isFull()) {
            cout << "Queue Overflow!" << endl;
            return;
        }
        int i = free;           // get free index
        free = next[i];         // update free to next free slot

        if(isEmpty(qn)) {
            front[qn]=i;        // first element
        } else {
            next[rear[qn]] = i; // link new element at end
        }
        rear[qn] = i;           // update rear
        next[i] = -1;           // last element points to -1
        arr[i] = x;             // store element
        cout << "Enqueued " << x << " to queue " << qn << endl;
    }

    void dequeue(int qn) {
        if(isEmpty(qn)) {
            cout << "Queue Underflow!" << endl;
            return;
        }
        int i = front[qn];       // index to remove
        front[qn] = next[i];     // update front to next element
        if(front[qn]==-1) rear[qn]=-1; // queue became empty

        next[i] = free;           // add index to free list
        free = i;

        cout << "Dequeued " << arr[i] << " from queue " << qn << endl;
    }
};

// ----------------------
// Driver Code
// ----------------------
int main() {
    int k = 3, n = 10;
    KQueue q(k,n);

    // Enqueue elements in different queues
    q.enqueue(10,0);
    q.enqueue(20,0);
    q.enqueue(30,1);
    q.enqueue(40,2);
    q.enqueue(50,1);
    q.enqueue(60,2);

    // Dequeue elements
    q.dequeue(0);
    q.dequeue(1);
    q.dequeue(2);
    q.dequeue(2);
    q.dequeue(1);
    q.dequeue(0); // underflow

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Initial:
arr=[_,_,_,_,_,_,_,_,_,_], free=0
front=[-1,-1,-1], rear=[-1,-1,-1]

enqueue(10,0):
i=0, free=1, queue0 empty → front[0]=0, rear[0]=0, arr[0]=10

enqueue(20,0):
i=1, free=2, link rear[0] →1, rear[0]=1, arr[1]=20

enqueue(30,1):
i=2, free=3, front[1]=2, rear[1]=2, arr[2]=30

enqueue(40,2):
i=3, free=4, front[2]=3, rear[2]=3, arr[3]=40

enqueue(50,1):
i=4, free=5, link rear[1] →4, rear[1]=4, arr[4]=50

enqueue(60,2):
i=5, free=6, link rear[2] →5, rear[2]=5, arr[5]=60

dequeue(0):
i=0, front[0]=next[0]=1, free=0, arr[0]=10 removed

dequeue(1):
i=2, front[1]=next[2]=4, free=2, arr[2]=30 removed

dequeue(2):
i=3, front[2]=next[3]=5, free=3, arr[3]=40 removed

dequeue(2):
i=5, front[2]=next[5]=-1, rear[2]=-1, free=5, arr[5]=60 removed

dequeue(1):
i=4, front[1]=next[4]=-1, rear[1]=-1, free=4, arr[4]=50 removed

dequeue(0):
i=1, front[0]=-1, rear[0]=-1, free=1, arr[1]=20 removed → underflow next

```

---

## **Question: Find first non-repeating element in a stream**

**Approach:**
PROBLEM STATEMENT:
Given a stream of characters/numbers, at each point, find the first non-repeating element from the stream seen so far.

Example:
Input stream: a, a, b, c, b
Output: a, -1, b, b, c
(-1 indicates no non-repeating element at that point)

---

APPROACH:

BRUTE FORCE:

1. For each incoming element, scan all previous elements to check if non-repeating.
2. Time Complexity: O(N^2)
3. Space Complexity: O(N)

OPTIMAL (Using Queue + Hash Map):

1. Maintain:
   - A queue to store potential non-repeating elements
   - A hash map to count frequency of each element
2. For each incoming element x:
   a. Increment count[x] in hash map
   b. Push x into queue
   c. While queue is not empty and count[queue.front()] > 1 → pop front
   d. If queue empty → no non-repeating → print -1
   Else → print queue.front()
3. Time Complexity: O(N)
4. Space Complexity: O(N)

**Code:**

```cpp
#include <iostream>
#include <queue>
#include <unordered_map>
using namespace std;

void firstNonRepeating(int arr[], int n) {
    queue<int> q;                       // queue to store potential non-repeating elements
    unordered_map<int,int> freq;        // map to store frequency of elements

    for(int i = 0; i < n; i++) {
        int x = arr[i];
        freq[x]++;           // increment frequency of current element
        q.push(x);           // add element to queue

        // remove all repeating elements from front
        while(!q.empty() && freq[q.front()] > 1) {
            q.pop();
        }

        // front of queue is first non-repeating
        if(q.empty()) {
            cout << -1 << " ";
        } else {
            cout << q.front() << " ";
        }
    }
    cout << endl;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    int arr[] = {4, 5, 4, 5, 3, 4, 5, 3, 2};
    int n = sizeof(arr)/sizeof(arr[0]);

    cout << "First Non-Repeating elements: ";
    firstNonRepeating(arr, n);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Input: 4 5 4 5 3 4 5 3 2
Queue: empty initially, freq={}

Step 0: x=4 → freq[4]=1, q=[4] → first non-repeating = 4
Step 1: x=5 → freq[5]=1, q=[4,5] → first non-repeating = 4
Step 2: x=4 → freq[4]=2, q=[4,5] → remove 4 (freq>1), first non-repeating=5
Step 3: x=5 → freq[5]=2, q=[5] → remove 5, queue empty → -1
Step 4: x=3 → freq[3]=1, q=[3] → first non-repeating =3
Step 5: x=4 → freq[4]=3, q=[3,4] → first non-repeating =3
Step 6: x=5 → freq[5]=3, q=[3,4,5] → first non-repeating =3
Step 7: x=3 → freq[3]=2, q=[3,4,5] → remove 3 → first non-repeating=4
Step 8: x=2 → freq[2]=1, q=[4,5,2] → first non-repeating=4

Final output sequence: 4 4 5 -1 3 3 3 4 4

```

---

## **Question: Interleave first half and second half of a queue**

**Approach:**
PROBLEM STATEMENT:
Given a queue of even length, interleave its first half and second half.

Example:
Input: 1 2 3 4 5 6
Output: 1 4 2 5 3 6

---

APPROACH:

BRUTE FORCE:

1. Use an auxiliary array/vector to split first half and second half.
2. Merge alternately into queue.
3. Time: O(n), Space: O(n)

OPTIMAL (Using Queue + Stack):

1. Let n = size of queue
2. Push first half elements into a stack
3. Pop from stack and enqueue back → first half reversed at rear
4. Move first half to rear → now second half at front, first half at rear
5. Push first half elements (from stack) again to interleave
6. Dequeue and enqueue elements to achieve interleaving
7. Time: O(n), Space: O(n/2) stack

**Code:**

```cpp
#include <iostream>
#include <queue>
#include <stack>
using namespace std;

void interleaveQueue(queue<int> &q) {
    if(q.size() % 2 != 0) {
        cout << "Queue size must be even!" << endl;
        return;
    }

    int n = q.size() / 2;
    stack<int> st;

    // Step 1: Push first half into stack
    for(int i = 0; i < n; i++) {
        st.push(q.front());
        q.pop();
    }

    // Step 2: Enqueue stack elements back → reverses first half
    while(!st.empty()) {
        q.push(st.top());
        st.pop();
    }

    // Step 3: Move first half to rear → second half in front
    for(int i = 0; i < n; i++) {
        q.push(q.front());
        q.pop();
    }

    // Step 4: Push first half (reversed) into stack
    for(int i = 0; i < n; i++) {
        st.push(q.front());
        q.pop();
    }

    // Step 5: Interleave elements from stack and queue
    while(!st.empty()) {
        q.push(st.top()); // element from first half
        st.pop();
        q.push(q.front()); // element from second half
        q.pop();
    }
}

// Function to print queue
void printQueue(queue<int> q) {
    while(!q.empty()) {
        cout << q.front() << " ";
        q.pop();
    }
    cout << endl;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    queue<int> q;
    for(int i = 1; i <= 6; i++) q.push(i);

    cout << "Original Queue: ";
    printQueue(q);

    interleaveQueue(q);

    cout << "Interleaved Queue: ";
    printQueue(q);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Original Queue: front→ [1 2 3 4 5 6] ←rear
n = 3

Step 1: push first half to stack → st=[3 2 1], q=[4 5 6]
Step 2: enqueue stack back → q=[4 5 6 1 2 3], st=[]
Step 3: move first half (3 elements) to rear → q=[1 2 3 4 5 6]
Step 4: push first half to stack → st=[3 2 1], q=[4 5 6]
Step 5: interleave:
    pop 1 → enqueue → q=[4 5 6 1]
    pop 4 → enqueue → q=[5 6 1 4]
    pop 2 → enqueue → q=[5 6 1 4 2]
    pop 5 → enqueue → q=[6 1 4 2 5]
    pop 3 → enqueue → q=[6 1 4 2 5 3]
    pop 6 → enqueue → q=[1 4 2 5 3 6]

Final Interleaved Queue: front→ [1 4 2 5 3 6] ←rear

```

---

## **Question: Sort a queue using recursion**

**Approach:**
PROBLEM STATEMENT:
Given a queue of integers, sort it in ascending order using recursion.
You are not allowed to use loops (only recursion) or additional data structures except function call stack.

Example:
Input: 5 1 3 2 4
Output: 1 2 3 4 5

---

APPROACH:

BRUTE FORCE:

1. Dequeue all elements into an array/vector.
2. Sort using built-in sort → O(n log n)
3. Enqueue elements back into queue.
4. Time: O(n log n), Space: O(n)

OPTIMAL (Recursion):

1. Base case: queue empty → return
2. Dequeue front element x
3. Recursively sort remaining queue
4. Insert x back in sorted order using recursive helper
   a. If queue empty or front >= x → enqueue x
   b. Else → dequeue front, insert x recursively, then enqueue front
5. Time: O(n^2) (due to recursive insertion), Space: O(n) recursion stack

**Code:**

```cpp
#include <iostream>
#include <queue>
using namespace std;

// Recursive function to insert x into sorted queue
void sortedInsert(queue<int> &q, int x) {
    // Base case: queue empty or front element >= x
    if(q.empty() || q.front() >= x) {
        q.push(x);  // insert x at correct position
        return;
    }

    int temp = q.front(); // store front
    q.pop();              // remove front
    sortedInsert(q, x);   // insert x recursively
    q.push(temp);         // push back the stored element
}

// Recursive function to sort queue
void sortQueue(queue<int> &q) {
    if(q.empty()) return;     // base case
    int x = q.front();        // dequeue front
    q.pop();
    sortQueue(q);             // sort remaining queue recursively
    sortedInsert(q, x);       // insert x at correct position
}

// Function to print queue
void printQueue(queue<int> q) {
    while(!q.empty()) {
        cout << q.front() << " ";
        q.pop();
    }
    cout << endl;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    queue<int> q;
    q.push(5);
    q.push(1);
    q.push(3);
    q.push(2);
    q.push(4);

    cout << "Original Queue: ";
    printQueue(q);

    sortQueue(q);

    cout << "Sorted Queue: ";
    printQueue(q);

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Original Queue: front→ [5 1 3 2 4] ←rear

sortQueue:
dequeue 5 → q=[1 3 2 4]
sortQueue:
dequeue 1 → q=[3 2 4]
sortQueue:
dequeue 3 → q=[2 4]
sortQueue:
dequeue 2 → q=[4]
sortQueue:
dequeue 4 → q=[]
base case → return

sortedInsert 4 → queue empty → enqueue 4 → q=[4]
sortedInsert 2:
  front=4 ≥ 2 → enqueue 2 → q=[4,2] (will be rearranged in unwind)
  Actually recursively:
    dequeue 4 → insert 2 → enqueue 2 → enqueue 4 → q=[2,4]
sortedInsert 3:
  front=2<3 → dequeue 2, insert 3 → queue=[4], enqueue 3 → queue=[4,3], enqueue 2 → q=[2,3,4]
sortedInsert 1:
  front=2≥1 → enqueue 1 → q=[1,2,3,4]
sortedInsert 5:
  front=1<5 → dequeue 1, insert 5 → q=[2,3,4], enqueue 5 → q=[2,3,4,5], enqueue 1 → q=[1,2,3,4,5]

Sorted Queue: front→ [1 2 3 4 5] ←rear

```

---

## **Question: Maximum of all subarrays of size k using queue**

**Approach:**
PROBLEM STATEMENT:
Given an array of size n and an integer k, find the maximum element in every contiguous subarray of size k.

Example:
Input: arr = [1,3,-1,-3,5,3,6,7], k=3
Output: [3,3,5,5,6,7]

---

APPROACH:

BRUTE FORCE:

1. For every subarray of size k, scan all elements to find max.
2. Time Complexity: O(n\*k)
3. Space Complexity: O(1)

OPTIMAL (Using Deque):

1. Maintain a deque to store indices of useful elements (potential maxima).
2. For each element arr[i]:
   a. Remove indices from rear where arr[i] >= arr[deque.back()] → they can't be maxima
   b. Remove indices from front if they are out of current window (i-k+1)
   c. Add current index i to rear
   d. If i >= k-1 → current window max = arr[deque.front()]
3. Time Complexity: O(n), Space Complexity: O(k)
4. This method ensures each element is pushed and popped at most once.

**Code:**

```cpp
#include <iostream>
#include <deque>
#include <vector>
using namespace std;

vector<int> maxOfSubarrays(vector<int> &arr, int k) {
    deque<int> dq;             // stores indices of potential maxima
    vector<int> result;        // stores maximums of windows
    int n = arr.size();

    for(int i = 0; i < n; i++) {
        // Remove indices out of current window
        if(!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }

        // Remove indices whose values are less than arr[i]
        while(!dq.empty() && arr[i] >= arr[dq.back()]) {
            dq.pop_back();
        }

        // Add current index
        dq.push_back(i);

        // Record max for window (starting from i >= k-1)
        if(i >= k - 1) {
            result.push_back(arr[dq.front()]);
        }
    }

    return result;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    vector<int> arr = {1,3,-1,-3,5,3,6,7};
    int k = 3;

    vector<int> ans = maxOfSubarrays(arr, k);

    cout << "Maximum of all subarrays of size " << k << ": ";
    for(int x : ans) cout << x << " ";
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
arr = [1,3,-1,-3,5,3,6,7], k=3
deque stores indices of useful elements

i=0: arr[0]=1 → dq=[0]
i=1: arr[1]=3 ≥ arr[0] → pop 0, dq=[1]
i=2: arr[2]=-1 → dq=[1,2] → i>=k-1 → max = arr[1]=3
i=3: arr[3]=-3 → dq=[1,2,3] → max = arr[1]=3
i=4: arr[4]=5 → remove 1,2,3 <5 → dq=[4] → max=5
i=5: arr[5]=3 → dq=[4,5] → max=5
i=6: arr[6]=6 → remove 4,5 <6 → dq=[6] → max=6
i=7: arr[7]=7 → remove 6 <7 → dq=[7] → max=7

Result sequence: [3,3,5,5,6,7]

```

---

## **Question: Minimum of all subarrays of size k using queue**

**Approach:**
PROBLEM STATEMENT:
Given an array of size n and an integer k, find the minimum element in every contiguous subarray of size k.

Example:
Input: arr = [1,3,-1,-3,5,3,6,7], k=3
Output: [ -1, -3, -3, -3, 3, 3 ]

---

APPROACH:

BRUTE FORCE:

1. For every subarray of size k, scan all elements to find minimum.
2. Time Complexity: O(n\*k)
3. Space Complexity: O(1)

OPTIMAL (Using Deque / Monotonic Queue):

1. Maintain a deque to store indices of potential minima.
2. For each element arr[i]:
   a. Remove indices from rear where arr[i] <= arr[deque.back()] → they cannot be minimum.
   b. Remove indices from front if they are out of current window (i-k+1).
   c. Add current index i to rear.
   d. If i >= k-1 → current window min = arr[deque.front()].
3. Time Complexity: O(n), Space Complexity: O(k)

**Code:**

```cpp
#include <iostream>
#include <deque>
#include <vector>
using namespace std;

vector<int> minOfSubarrays(vector<int> &arr, int k) {
    deque<int> dq;             // stores indices of potential minima
    vector<int> result;        // stores minimums of windows
    int n = arr.size();

    for(int i = 0; i < n; i++) {
        // Remove indices out of current window
        if(!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }

        // Remove indices whose values are greater than arr[i]
        while(!dq.empty() && arr[i] <= arr[dq.back()]) {
            dq.pop_back();
        }

        // Add current index
        dq.push_back(i);

        // Record min for window (starting from i >= k-1)
        if(i >= k - 1) {
            result.push_back(arr[dq.front()]);
        }
    }

    return result;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    vector<int> arr = {1,3,-1,-3,5,3,6,7};
    int k = 3;

    vector<int> ans = minOfSubarrays(arr, k);

    cout << "Minimum of all subarrays of size " << k << ": ";
    for(int x : ans) cout << x << " ";
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
arr = [1,3,-1,-3,5,3,6,7], k=3
deque stores indices of potential minima

i=0: arr[0]=1 → dq=[0]
i=1: arr[1]=3 → dq=[0,1]
i=2: arr[2]=-1 → remove 1,0 >-1 → dq=[2] → i>=k-1 → min=arr[2]=-1
i=3: arr[3]=-3 → remove 2>-3 → dq=[3] → min=-3
i=4: arr[4]=5 → dq=[3,4] → min=-3
i=5: arr[5]=3 → remove 4>3 → dq=[3,5] → min=-3
i=6: arr[6]=6 → dq=[3,5,6] → remove 3 out of window? (i-k+1=4), dq=[5,6] → min=arr[5]=3
i=7: arr[7]=7 → dq=[5,6,7] → min=arr[5]=3

Result sequence: [-1, -3, -3, -3, 3, 3]

```

---

## **Question: Sliding window sum or average using queue**

**Approach:**
PROBLEM STATEMENT:
Given an array of size n and an integer k, calculate the sum or average of all contiguous subarrays of size k.

Example:
Input: arr = [1,3,2,6,-1,4,1,8,2], k=3
Output (sum): [6,11,7,9,4,13,11]
Output (average): [2, 11/3≈3.67, 7/3≈2.33, 3,...]

---

APPROACH:

BRUTE FORCE:

1. For each window of size k, sum all elements.
2. Time Complexity: O(n\*k)
3. Space Complexity: O(1)

OPTIMAL (Using Queue / Sliding Window Sum):

1. Maintain a queue (or simple window sum variable).
2. Initialize sum with first k elements.
3. For remaining elements:
   a. Remove element leaving the window
   b. Add new element entering the window
   c. Store/update sum or average
4. Time Complexity: O(n), Space Complexity: O(k) if using queue (O(1) if just variable)

**Code:**

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

// Function to compute sliding window sum
vector<int> slidingWindowSum(vector<int> &arr, int k) {
    vector<int> result;
    queue<int> q;
    int windowSum = 0;

    for(int i = 0; i < arr.size(); i++) {
        q.push(arr[i]);           // enqueue current element
        windowSum += arr[i];      // add to window sum

        // If queue size exceeds k, remove front
        if(q.size() > k) {
            windowSum -= q.front(); // remove leaving element
            q.pop();
        }

        // If window has reached size k, store sum
        if(q.size() == k) {
            result.push_back(windowSum);
        }
    }
    return result;
}

// Function to compute sliding window average
vector<double> slidingWindowAverage(vector<int> &arr, int k) {
    vector<int> sums = slidingWindowSum(arr, k);
    vector<double> averages;
    for(int s : sums) averages.push_back((double)s / k);
    return averages;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    vector<int> arr = {1,3,2,6,-1,4,1,8,2};
    int k = 3;

    vector<int> sumResult = slidingWindowSum(arr, k);
    cout << "Sliding window sums: ";
    for(int x : sumResult) cout << x << " ";
    cout << endl;

    vector<double> avgResult = slidingWindowAverage(arr, k);
    cout << "Sliding window averages: ";
    for(double x : avgResult) cout << x << " ";
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
arr=[1,3,2,6,-1,4,1,8,2], k=3
windowSum=0, queue empty

Step 0: enqueue 1 → q=[1], windowSum=1 → size<k → skip
Step 1: enqueue 3 → q=[1,3], windowSum=4 → size<k → skip
Step 2: enqueue 2 → q=[1,3,2], windowSum=6 → size=k → push 6
Step 3: enqueue 6 → q=[1,3,2,6], windowSum=12 → pop 1 → windowSum=11 → push 11
Step 4: enqueue -1 → q=[3,2,6,-1], pop 3 → windowSum=7 → push 7
Step 5: enqueue 4 → q=[2,6,-1,4], pop 2 → windowSum=9 → push 9
Step 6: enqueue 1 → q=[6,-1,4,1], pop 6 → windowSum=4 → push 4
Step 7: enqueue 8 → q=[-1,4,1,8], pop -1 → windowSum=13 → push 13
Step 8: enqueue 2 → q=[4,1,8,2], pop 4 → windowSum=11 → push 11

Sliding window sums: 6 11 7 9 4 13 11
Sliding window averages: 2 3.66667 2.33333 3 1.33333 4.33333 3.66667

```

---

## **Question: Design a queue that supports min() or max() in O(1)**

**Approach:**
PROBLEM STATEMENT:
Design a queue which supports the following operations in O(1) time:

1. enqueue(x) → insert element
2. dequeue() → remove element
3. getMin() / getMax() → return the minimum or maximum element currently in the queue

Example:
Input: enqueue(3), enqueue(1), enqueue(5), dequeue(), enqueue(0)
Output: getMin() = 0, getMax() = 5

---

APPROACH:

OPTIMAL (Using Auxiliary Deque):

1. Maintain two deques:
   a. minDeque → stores potential minima in increasing order
   b. maxDeque → stores potential maxima in decreasing order
2. Enqueue(x):
   a. Push x to the normal queue
   b. Remove all elements from rear of minDeque greater than x → maintain increasing order
   c. Remove all elements from rear of maxDeque smaller than x → maintain decreasing order
   d. Push x to both deques
3. Dequeue():
   a. Pop from normal queue
   b. If deque.front() == popped element → pop from deque
4. getMin() → minDeque.front()
5. getMax() → maxDeque.front()
6. All operations are O(1) amortized

**Code:**

```cpp
#include <iostream>
#include <queue>
#include <deque>
using namespace std;

class MinMaxQueue {
    queue<int> q;          // normal queue
    deque<int> minDeque;   // deque for minimum elements
    deque<int> maxDeque;   // deque for maximum elements

public:
    void enqueue(int x) {
        q.push(x);              // enqueue to normal queue

        // Maintain minDeque: remove all elements greater than x
        while(!minDeque.empty() && minDeque.back() > x) {
            minDeque.pop_back();
        }
        minDeque.push_back(x);   // push x to minDeque

        // Maintain maxDeque: remove all elements smaller than x
        while(!maxDeque.empty() && maxDeque.back() < x) {
            maxDeque.pop_back();
        }
        maxDeque.push_back(x);   // push x to maxDeque
    }

    void dequeue() {
        if(q.empty()) {
            cout << "Queue Underflow!" << endl;
            return;
        }
        int x = q.front();
        q.pop();                // remove from normal queue

        // Remove from minDeque if front equals dequeued element
        if(!minDeque.empty() && minDeque.front() == x) {
            minDeque.pop_front();
        }

        // Remove from maxDeque if front equals dequeued element
        if(!maxDeque.empty() && maxDeque.front() == x) {
            maxDeque.pop_front();
        }
    }

    int getMin() {
        if(minDeque.empty()) return -1; // queue empty
        return minDeque.front();
    }

    int getMax() {
        if(maxDeque.empty()) return -1; // queue empty
        return maxDeque.front();
    }

    void printQueue() {
        queue<int> temp = q;
        while(!temp.empty()) {
            cout << temp.front() << " ";
            temp.pop();
        }
        cout << endl;
    }
};

// ----------------------
// Driver Code
// ----------------------
int main() {
    MinMaxQueue mq;

    mq.enqueue(3);
    mq.enqueue(1);
    mq.enqueue(5);
    mq.enqueue(2);

    cout << "Queue: "; mq.printQueue();
    cout << "Min: " << mq.getMin() << ", Max: " << mq.getMax() << endl;

    mq.dequeue(); // remove 3
    cout << "Queue after dequeue: "; mq.printQueue();
    cout << "Min: " << mq.getMin() << ", Max: " << mq.getMax() << endl;

    mq.dequeue(); // remove 1
    cout << "Queue after dequeue: "; mq.printQueue();
    cout << "Min: " << mq.getMin() << ", Max: " << mq.getMax() << endl;

    mq.enqueue(0);
    cout << "Queue after enqueue 0: "; mq.printQueue();
    cout << "Min: " << mq.getMin() << ", Max: " << mq.getMax() << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Operations:
enqueue 3 → q=[3], minDeque=[3], maxDeque=[3]
enqueue 1 → q=[3,1], minDeque=[1], maxDeque=[3,1]
enqueue 5 → q=[3,1,5], minDeque=[1,5], maxDeque=[5]
enqueue 2 → q=[3,1,5,2], minDeque=[1,2], maxDeque=[5,2]

getMin()=1, getMax()=5

dequeue → remove 3 → q=[1,5,2], minDeque=[1,2], maxDeque=[5,2]
getMin()=1, getMax()=5

dequeue → remove 1 → q=[5,2], minDeque=[2], maxDeque=[5,2]
getMin()=2, getMax()=5

enqueue 0 → q=[5,2,0], minDeque=[0], maxDeque=[5,2,0]
getMin()=0, getMax()=5

```

---

## **Question: Sliding window for moving maximum / minimum**

**Approach:**
PROBLEM STATEMENT:
Given an array of size n and an integer k, for every contiguous subarray of size k, find:

1. Maximum element → Moving Maximum
2. Minimum element → Moving Minimum

Example:
Input: arr = [1,3,-1,-3,5,3,6,7], k=3
Output (Maximums): [3,3,5,5,6,7]
Output (Minimums): [-1,-3,-3,-3,3,3]

---

APPROACH (Monotonic Queue):

1. Maintain a deque to store indices of useful elements:
   a. For Maximum → store elements in decreasing order
   b. For Minimum → store elements in increasing order
2. For each element arr[i]:
   a. Remove indices out of current window (i-k+1)
   b. Remove indices from rear violating monotonic property - For max: remove elements smaller than arr[i] - For min: remove elements larger than arr[i]
   c. Add current index i to deque
   d. If i >= k-1 → record deque.front() as window maximum or minimum
3. Time Complexity: O(n), Space Complexity: O(k)
4. Each element is pushed and popped at most once → amortized O(1) per operation

**Code:**

```cpp
#include <iostream>
#include <deque>
#include <vector>
using namespace std;

// Function to compute sliding window maximum
vector<int> slidingWindowMaximum(vector<int> &arr, int k) {
    deque<int> dq;             // stores indices of potential maxima
    vector<int> result;
    int n = arr.size();

    for(int i = 0; i < n; i++) {
        // Remove indices out of current window
        if(!dq.empty() && dq.front() <= i - k)
            dq.pop_front();

        // Remove all smaller elements from rear
        while(!dq.empty() && arr[i] >= arr[dq.back()])
            dq.pop_back();

        dq.push_back(i);        // add current index

        if(i >= k - 1)
            result.push_back(arr[dq.front()]); // front is max of window
    }
    return result;
}

// Function to compute sliding window minimum
vector<int> slidingWindowMinimum(vector<int> &arr, int k) {
    deque<int> dq;             // stores indices of potential minima
    vector<int> result;
    int n = arr.size();

    for(int i = 0; i < n; i++) {
        // Remove indices out of current window
        if(!dq.empty() && dq.front() <= i - k)
            dq.pop_front();

        // Remove all larger elements from rear
        while(!dq.empty() && arr[i] <= arr[dq.back()])
            dq.pop_back();

        dq.push_back(i);        // add current index

        if(i >= k - 1)
            result.push_back(arr[dq.front()]); // front is min of window
    }
    return result;
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    vector<int> arr = {1,3,-1,-3,5,3,6,7};
    int k = 3;

    vector<int> maxRes = slidingWindowMaximum(arr, k);
    vector<int> minRes = slidingWindowMinimum(arr, k);

    cout << "Sliding Window Maximum: ";
    for(int x : maxRes) cout << x << " ";
    cout << endl;

    cout << "Sliding Window Minimum: ";
    for(int x : minRes) cout << x << " ";
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
arr = [1,3,-1,-3,5,3,6,7], k=3

Sliding Window Maximum:
i=0: dq=[0] → skip (window not full)
i=1: arr[1]=3 ≥ arr[0] → pop 0 → dq=[1]
i=2: arr[2]=-1 → dq=[1,2] → i>=k-1 → max=arr[1]=3
i=3: arr[3]=-3 → dq=[1,2,3] → max=arr[1]=3
i=4: arr[4]=5 → pop 1,2,3 <5 → dq=[4] → max=5
i=5: arr[5]=3 → dq=[4,5] → max=5
i=6: arr[6]=6 → pop 4,5 <6 → dq=[6] → max=6
i=7: arr[7]=7 → pop 6 <7 → dq=[7] → max=7
Max sequence: [3,3,5,5,6,7]

Sliding Window Minimum:
i=0: dq=[0] → skip
i=1: arr[1]=3 → dq=[0,1]
i=2: arr[2]=-1 → pop 1,0 >-1 → dq=[2] → min=-1
i=3: arr[3]=-3 → pop 2>-3 → dq=[3] → min=-3
i=4: arr[4]=5 → dq=[3,4] → min=-3
i=5: arr[5]=3 → pop 4>3 → dq=[3,5] → min=-3
i=6: arr[6]=6 → dq=[3,5,6], pop 3 out of window → dq=[5,6] → min=arr[5]=3
i=7: arr[7]=7 → dq=[5,6,7] → min=arr[5]=3
Min sequence: [-1,-3,-3,-3,3,3]

```

---

## **Question: Implement circular deque operations (insertFront, insertRear, deleteFront, deleteRear)**

**Approach:**
PROBLEM STATEMENT:
Implement a circular deque of fixed size k supporting the following operations:

1. insertFront(x) → insert at front
2. insertRear(x) → insert at rear
3. deleteFront() → remove from front
4. deleteRear() → remove from rear
5. getFront() → return front element
6. getRear() → return rear element
7. isEmpty(), isFull() → check if deque is empty/full

All operations should be in O(1) time.

Example:
Capacity = 5
Operations: insertRear(1), insertFront(2), deleteRear(), insertFront(3), getFront()

**Code:**

```cpp
#include <iostream>
using namespace std;

class CircularDeque {
    int *arr;
    int capacity;
    int front, rear;
    int size;

public:
    CircularDeque(int k) {
        capacity = k;
        arr = new int[k];
        front = 0;      // front index
        rear = -1;      // rear index
        size = 0;       // current size
    }

    bool isFull() { return size == capacity; }   // check if deque is full
    bool isEmpty() { return size == 0; }        // check if deque is empty

    // Insert at front
    bool insertFront(int x) {
        if(isFull()) return false;
        front = (front - 1 + capacity) % capacity; // move front backward
        arr[front] = x;
        size++;
        return true;
    }

    // Insert at rear
    bool insertRear(int x) {
        if(isFull()) return false;
        rear = (rear + 1) % capacity;  // move rear forward
        arr[rear] = x;
        size++;
        return true;
    }

    // Delete from front
    bool deleteFront() {
        if(isEmpty()) return false;
        front = (front + 1) % capacity; // move front forward
        size--;
        return true;
    }

    // Delete from rear
    bool deleteRear() {
        if(isEmpty()) return false;
        rear = (rear - 1 + capacity) % capacity; // move rear backward
        size--;
        return true;
    }

    int getFront() {
        if(isEmpty()) return -1;
        return arr[front];
    }

    int getRear() {
        if(isEmpty()) return -1;
        return arr[rear];
    }

    void printDeque() {
        if(isEmpty()) { cout << "Deque is empty\n"; return; }
        int idx = front;
        for(int i = 0; i < size; i++) {
            cout << arr[idx] << " ";
            idx = (idx + 1) % capacity;
        }
        cout << endl;
    }
};

// ----------------------
// Driver Code
// ----------------------
int main() {
    CircularDeque dq(5);

    dq.insertRear(1);
    dq.insertRear(2);
    dq.insertFront(3);
    dq.insertFront(4);

    cout << "Deque: "; dq.printDeque();
    cout << "Front: " << dq.getFront() << ", Rear: " << dq.getRear() << endl;

    dq.deleteFront();
    dq.deleteRear();

    cout << "Deque after deletions: "; dq.printDeque();
    cout << "Front: " << dq.getFront() << ", Rear: " << dq.getRear() << endl;

    dq.insertRear(5);
    dq.insertFront(6);

    cout << "Deque after more insertions: "; dq.printDeque();
    cout << "Front: " << dq.getFront() << ", Rear: " << dq.getRear() << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Operations:
insertRear(1) → dq=[1], front=0, rear=0
insertRear(2) → dq=[1 2], front=0, rear=1
insertFront(3) → front=(0-1+5)%5=4 → dq=[3 1 2], rear=1
insertFront(4) → front=(4-1+5)%5=3 → dq=[4 3 1 2], rear=1

Front: arr[front]=4, Rear: arr[rear]=2

deleteFront → front=(3+1)%5=4 → dq=[3 1 2], size=3
deleteRear → rear=(1-1+5)%5=0 → dq=[3 1], size=2

insertRear(5) → rear=(0+1)%5=1 → dq=[3 1 5]
insertFront(6) → front=(4-1+5)%5=3 → dq=[6 3 1 5]

Final Deque sequence: 6 3 1 5
Front=6, Rear=5

```

---

## **Question: Reverse first k elements of a queue**

**Approach:**
PROBLEM STATEMENT:
Given a queue of size n and an integer k (<= n), reverse the first k elements of the queue, leaving the other elements in the same order.

Example:
Input: queue = [1,2,3,4,5,6], k=3
Output: [3,2,1,4,5,6]

---

APPROACH:

1. Use a stack to reverse the first k elements:
   a. Dequeue first k elements and push them onto a stack → reverses order
   b. Pop elements from stack and enqueue back → first k elements reversed
2. Move the remaining (n-k) elements to the back to maintain original order:
   a. Dequeue and enqueue (n-k) times
3. Time Complexity: O(n), Space Complexity: O(k)

**Code:**

```cpp
#include <iostream>
#include <queue>
#include <stack>
using namespace std;

void reverseFirstK(queue<int> &q, int k) {
    if(q.empty() || k <= 0) return;

    stack<int> s;

    // Step 1: Push first k elements onto stack
    for(int i = 0; i < k; i++) {
        s.push(q.front());   // push front element
        q.pop();             // remove from queue
    }

    // Step 2: Enqueue elements from stack back to queue
    while(!s.empty()) {
        q.push(s.top());     // enqueue reversed element
        s.pop();
    }

    // Step 3: Move remaining (n-k) elements to back to maintain order
    int n = q.size();
    for(int i = 0; i < n - k; i++) {
        q.push(q.front());   // dequeue and enqueue
        q.pop();
    }
}

// ----------------------
// Driver Code
// ----------------------
int main() {
    queue<int> q;
    int arr[] = {1,2,3,4,5,6};
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 3;

    for(int i = 0; i < n; i++) q.push(arr[i]);

    cout << "Original Queue: ";
    queue<int> temp = q;
    while(!temp.empty()) { cout << temp.front() << " "; temp.pop(); }
    cout << endl;

    reverseFirstK(q, k);

    cout << "Queue after reversing first " << k << " elements: ";
    while(!q.empty()) { cout << q.front() << " "; q.pop(); }
    cout << endl;

    return 0;
}

// End of code
```

**Dry Run:**

```cpp
Original Queue: [1 2 3 4 5 6]

Step 1: Push first k=3 elements onto stack
Stack: [1 2 3] → top=3

Step 2: Pop from stack and enqueue
Queue now: [3 2 1 4 5 6]

Step 3: Move remaining n-k=3 elements to back
- dequeue 4 → enqueue 4 → [3 2 1 5 6 4]
- dequeue 5 → enqueue 5 → [3 2 1 6 4 5]
- dequeue 6 → enqueue 6 → [3 2 1 4 5 6]

Final Queue: [3 2 1 4 5 6]

```

---
